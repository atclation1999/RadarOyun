<!DOCTYPE html>
<html lang="tr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Radar Yaklaşma Oyunu</title>








<style>

/* Bilgilendirme Pop-up Stilleri */
.info-popup-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.75); /* Yarı saydam koyu arka plan */
    display: none; /* Başlangıçta gizli */
    align-items: center;
    justify-content: center;
    z-index: 2000; /* Diğer her şeyin üzerinde olmalı */
    opacity: 0;
    transition: opacity 0.3s ease-in-out;
}

.info-popup-overlay.visible {
    display: flex;
    opacity: 1;
}

.info-popup-content {
    background-color: #3a3a3a; /* Koyu gri bir arka plan */
    color: #f0f0f0; /* Açık renk metin */
    padding: 25px 30px;
    border-radius: 8px;
    border: 2px solid #0f0; /* Yeşil kenarlık */
    box-shadow: 0 5px 25px rgba(0, 0, 0, 0.5);
    width: 90%;
    max-width: 600px; /* Pop-up maksimum genişliği */
    max-height: 85vh; /* Pop-up maksimum yüksekliği */
    overflow-y: auto; /* İçerik taşarsa scroll bar */
    text-align: left; /* İçerik sola yaslı */
    font-family: Arial, sans-serif; /* Okunabilir bir font */
}

.info-popup-content h2 {
    color: #0f0; /* Yeşil başlık */
    margin-top: 0;
    margin-bottom: 20px;
    font-size: 22px;
    text-align: center;
}

.info-popup-content p,
.info-popup-content li {
    font-size: 15px;
    line-height: 1.7;
    margin-bottom: 12px;
}

.info-popup-content ul {
    margin-bottom: 20px;
    padding-left: 25px; /* Madde işaretleri için iç boşluk */
}

.info-popup-content strong {
    color: #ffc107; /* Vurgu için sarımsı renk */
}

#infoPopupCloseButton {
    display: block; /* Butonu blok element yap */
    margin: 25px auto 0; /* Üstte boşluk bırak ve ortala */
    padding: 10px 30px;
    font-size: 16px;
    background-color: #0f0; /* Yeşil buton */
    color: black;
    border-color: #0a0;
}

#infoPopupCloseButton:hover {
    background-color: #0d0; /* Hover rengi */
}

/* Pop-up scrollbar stilleri (isteğe bağlı) */
.info-popup-content::-webkit-scrollbar {
    width: 10px;
}
.info-popup-content::-webkit-scrollbar-track {
    background: #2c2c2c;
    border-radius: 5px;
}
.info-popup-content::-webkit-scrollbar-thumb {
    background-color: #0f0;
    border-radius: 5px;
    border: 2px solid #2c2c2c;
}
.info-popup-content {
    scrollbar-width: thin;
    scrollbar-color: #0f0 #2c2c2c;
}














    /* Temel stiller */
    html, body { height: 100%; margin: 0; overflow: hidden; /* Kaydırma çubuklarını engelle */ background-color: #333; color: white; font-family: Arial, sans-serif; display: flex; /* Flexbox ile canvas'ı ortala */ align-items: center; /* Dikey ortala */ justify-content: center; /* Yatay ortala */ }
    canvas { display: block; /* margin: auto kaldırıldı */ background: rgba(160, 160, 160, 0.5); cursor: grab; /* max-width/height kaldırıldı, JS ile ayarlanacak */ border: none; /* Kenarlık olmadığından emin ol */ }
    button { cursor: pointer; } /* Genel buton stili */

    /* Kontrol Butonları */
    .control-button { padding: 8px 15px; background: #555; border: 1px solid #0f0; color: #fff; font-weight: bold; border-radius: 3px; margin-bottom: 5px; text-align: center; z-index: 10; transition: background-color 0.2s, color 0.2s, border-color 0.2s; }
    .control-button.active { background: #0f0; color: black; }
    .control-button:disabled { background: #777; color: #aaa; border-color: #666; cursor: not-allowed; }

    /* Sol Üst Kontroller */
    #topLeftControls { position: absolute; top: 10px; left: 10px; z-index: 10; display: flex; flex-direction: column; }
    #fullscreenButton { /* control-button stilini kullanır */ }
    .loc-btn { /* control-button stilini kullanır */ }

    /* Üst Orta Kontroller */
    #topCenterControls {
        position: absolute;
        top: 10px;
        left: 50%;
        transform: translateX(-50%);
        z-index: 10;
        display: flex;
        gap: 10px; /* Butonlar arası boşluk */
    }
    #interceptButton033, #interceptButton21L { /* Ortak Intercept Buton Stili */
        background-color: #6c757d; /* Başlangıçta gri */
        border-color: #888;
    }
    #interceptButton033:not(:disabled), #interceptButton21L:not(:disabled) { /* Aktifken */
        background-color: #ffc107; /* Sarı */
        color: black;
        border-color: #ffc107;
    }
    #interceptButton033:not(:disabled):hover, #interceptButton21L:not(:disabled):hover {
        background-color: #e0a800;
        border-color: #e0a800;
    }
    #towerButton { background-color: #17a2b8; border-color: #17a2b8; }
    #towerButton.handed-off { background-color: #0d6efd; border-color: #0d6efd; } /* Kuleye devredilince farklı renk */
    #removeButton { background-color: #dc3545; border-color: #dc3545; }

    /* Sağ Üst Kontroller (Vector) */
    #vectorControls {
        position: absolute;
        top: 10px;
        right: 10px;
        display: flex;
        flex-direction: column; /* Dakika butonları dikey sıralanacak */
        gap: 5px; /* Elemanlar arasında dikey boşluk */
        z-index: 10;
    }
    #vectorToggleWrapper {
        display: flex;
        flex-direction: row; /* Timer ve vectorToggle yan yana */
        align-items: center;
        gap: 10px; /* Timer ile buton arasında boşluk */
    }
    #gameTimer {
        color: white;
        font-weight: bold;
        font-size: 14px;
        font-family: Arial, sans-serif;
        background: rgba(50, 50, 50, 0.2);
        padding: 5px 10px;
        border: 1px solid #0f0;
        border-radius: 3px;
    }
    #vectorToggle { background: #a00; color: white; }
    #vectorToggle.active { background: #0f0; color: black; }

    /* Sol Alt Kontroller */
    #bottomLeftControls { position: absolute; bottom: 10px; left: 10px; z-index: 10; display: flex; flex-direction: column; align-items: flex-start; /* Butonları sola yasla */ }
    #bottomLeftControls .control-button {
        width: 130px; /* Sabit veya max-width ayarlanabilir */
        box-sizing: border-box; /* Padding dahil */
    }
    #measureButton { background-color: #17a2b8; /* Farklı renk */ }
    #measureButton.measuring { background: cyan; color: black; border-color: black; } /* Ölçüm rengi */
    #addAircraftButton { background-color: #007bff; }
    #addAircraftButton.placing { background: #ffc107; color: black; }
    #speedButton { background-color: #fd7e14; /* Turuncu */ }
    #speedControlContainer {
        background: rgba(50, 50, 50, 0.8);
        padding: 10px;
        border: 1px solid #0f0;
        border-radius: 5px;
        margin-bottom: 5px;
        display: none; /* Başlangıçta gizli */
        width: 130px; /* Butonlarla aynı genişlik */
        box-sizing: border-box;
    }
    #speedSlider { width: 100%; margin-top: 5px; /* Üst boşluk eklendi */ }
    #speedValue { display: none; text-align: center; margin-top: 5px; font-weight: bold; }
    #playPauseButton { background-color: #28a745; border-color: #28a745; } /* Yeşil */
    #playPauseButton.paused { background-color: #ffc107; border-color: #ffc107; color: black; } /* Sarı */
    #takeoffButton { background-color: #6f42c1; border-color: #6f42c1; } /* Mor */
    #takeoffOptionsContainer {
        background: rgba(50, 50, 50, 0.9);
        padding: 10px;
        border: 1px solid #6f42c1;
        border-radius: 5px;
        margin-bottom: 5px;
        width: 130px; /* Butonlarla aynı genişlik */
        box-sizing: border-box;
        display: flex;
        flex-direction: column; /* Seçenekleri alt alta */
        gap: 5px; /* Seçenekler arası boşluk */
    }
    .takeoff-option-btn {
        width: 100%; /* Konteyner genişliğini doldur */
        padding: 5px;
        background-color: #5a379e;
        border: 1px solid #8a63d2;
        color: white;
        font-size: 12px;
        text-align: center;
        border-radius: 3px;
        cursor: pointer;
        transition: background-color 0.2s;
    }
    .takeoff-option-btn:hover {
        background-color: #8a63d2;
    }
    .takeoff-runway-option {
        display: flex;
        flex-direction: column;
        margin-bottom: 5px;
    }
    .waypoint-select {
        width: 100%;
        padding: 5px;
        background-color: #5a379e;
        border: 1px solid #8a63d2;
        color: white;
        font-size: 12px;
        border-radius: 3px;
        margin-top: 3px;
    }
    .waypoint-select:hover {
        background-color: #8a63d2;
    }

    /* Sağ Alt Kontroller (Label Size) */
    #labelControls { position: absolute; bottom: 10px; right: 10px; background: rgba(50, 50, 50, 0.8); padding: 10px; border: 1px solid #0f0; z-index: 10; border-radius: 5px; }
    #labelControls label { color: white; display: block; margin-bottom: 5px; font-size: 12px; }
    #labelSize { width: 100%; }

    /* Popup Menü */
    #popup { position: absolute; background: rgba(50, 50, 50, 0.3); /* Saydamlık */ border: 1px solid #0f0; padding: 8px; display: none; z-index: 20; font-family: monospace; color: white; max-height: 200px; overflow-y: auto; scrollbar-width: thin; scrollbar-color: #0f0 #555; border-radius: 4px; backdrop-filter: blur(2px); /* Hafif bulanıklık efekti */ }
    #popup::-webkit-scrollbar { width: 8px; }
    #popup::-webkit-scrollbar-track { background: #555; border-radius: 4px;}
    #popup::-webkit-scrollbar-thumb { background-color: #0f0; border-radius: 4px; border: 1px solid #555;}
    #popup div:not(#turnButtons) { margin: 2px 0; padding: 4px 8px; cursor: pointer; border-bottom: 1px solid #666; font-size: 13px; transition: background-color 0.1s, color 0.1s; /* Yumuşak geçiş */ }
    #popup div:not(#turnButtons):last-child { border-bottom: none; }
    #popup div:not(#turnButtons):hover { background-color: #0f0; color: black; } /* Hover efekti */
    #popup div.current-value:not(#headingValues div) { /* Sadece hız, irtifa, rod için */
        font-weight: bold; color: #0f0 !important; background-color: rgba(0, 255, 0, 0.1);
    }
    #turnButtons { display: flex; justify-content: space-between; margin-top: 8px; padding-top: 8px; border-top: 1px solid #777; position: sticky; bottom: 0; background: rgba(50, 50, 50, 0.3); /* Saydamlık */ padding-bottom: 2px; }
    .turn-btn { background: #444; border: 1px solid #0f0; color: #0f0; flex-grow: 1; margin: 0 2px; height: 25px; border-radius: 3px; cursor: pointer; font-size: 12px; display: flex; align-items: center; justify-content: center; font-weight: bold; }
    .turn-btn:hover { background: #0f0; color: black; }
    .turn-btn.active { background: #0f0; color: black; border: 1px solid black; }

    /* --- YENİ VE GÜNCELLENMİŞ ETİKET STİLLERİ --- */
    .dynamic-label { /* Ortak stil */
        position: absolute;
        font-family: monospace;
        pointer-events: auto; /* Olayları yakalaması için */
        white-space: nowrap;
        z-index: 5;
        color: black !important; /* YENİ: Metin rengi siyah */
        font-weight: bold !important; /* YENİ: Metin kalın */
        background: transparent !important; /* YENİ: Tamamen transparan */
        padding: 3px 6px;
        border: none; /* YENİ: Kenarlık yok */
        border-radius: 3px;
        cursor: default; /* Varsayılan imleç, sürükleme orta tuşla */
        user-select: none;
        /* font-size: 12px; Bu JS ile ayarlanıyor */
        transform-origin: left center;
    }
	
	.dynamic-label .label-line {
    line-height: 0.9; /* Satırları birbirine daha da yaklaştırır, değeri ayarlayarak deneyin */
    /* padding: 0; */ /* Eğer tüm label-line'lar için padding'i sıfırlamak isterseniz */
    /* margin-bottom: 0px; */ /* Gerekirse tüm satırların alt boşluğunu buradan da sıfırlayabilirsiniz */
}

    .dynamic-label.dragging {
        cursor: grabbing !important; /* Sürüklerken */
        border: 1px dashed black !important; /* Sürüklerken kenarlık stili siyah ve kesikli */
        background: rgba(0,0,0,0.05) !important; /* Sürüklerken çok hafif bir arka plan */
    }

    .aircraft-label { /* Uçak etiketine özel */
        cursor: grab; /* Sürükleme imleci */
    }
    /* .aircraft-label.dragging zaten .dynamic-label.dragging tarafından kapsanıyor */

    /* Etiket içindeki tüm alt elementlerin de siyah ve bold olmasını sağla */
    .aircraft-label .label-line,
    .aircraft-label .label-id,
    .aircraft-label .current-altitude,
    .aircraft-label .target-altitude,
    .aircraft-label [data-field="rateOfDescent"],
    .aircraft-label .aircraft-info-panel div,
    .aircraft-label .aircraft-info-panel span {
        color: black !important;
        font-weight: bold !important; /* Her ihtimale karşı tekrar */
    }

    /* Uçak etiketi içindeki tıklanabilir satırlar için GÜNCELLENMİŞ stil */
    .clickable-line { 
        cursor: pointer;
        text-decoration: none; /* ALT ÇİZGİ KALDIRILDI */
        color: black !important;
        padding: 0px 0; /* DİKEY PADDING AZALTILDI */
        margin: 0px 0;   /* DİKEY MARGIN SIFIRLANDI */
    }
    .clickable-line:hover {
        background-color: rgba(190, 190, 190, 0.5); 
        color: black !important; 
    }
    .target-altitude.clickable-line:hover { 
        background-color: rgba(190, 190, 190, 0.5); 
    }

    .aircraft-label.selected {
        border: 1px solid black !important; /* Seçiliyken siyah kenarlık */
        box-shadow: 0 0 6px rgba(0, 0, 0, 0.6); /* Seçiliyken siyah gölge */
    }
    .target-altitude { /* Uçak etiketi içindeki hedef irtifa */
        margin-left: 5px; /* Sol boşluk */
    }
    .current-altitude { /* Uçak etiketi içindeki mevcut irtifa */
        cursor: default; /* Tıklanamaz olduğunu belirt */
        text-decoration: none !important; /* Alt çizgiyi kaldır (zaten .clickable-line değil ama emin olmak için) */
    }
    /* Uçak etiketi içindeki ID (Çağrı Adı) için GÜNCELLENMİŞ stil */
    .label-id { 
        cursor: pointer;
        text-decoration: none; /* ALT ÇİZGİ KALDIRILDI */
        /* .label-line'dan alacağı için margin/padding burada ayrıca belirtmeye gerek yok, */
        /* ancak daha fazla kontrol istenirse eklenebilir. */
    }
    .label-id:hover {
        background-color: rgba(190, 190, 190, 0.5);
    }

    /* Ölçüm etiketi stilleri */
    .measurement-label {
        color: cyan !important; 
        cursor: grab;
    }

    .measurement-label .measurement-bearing,
    .measurement-label .measurement-relative-bearing,
    .measurement-label .measurement-dist-alt {
        display: block; 
        color: cyan !important; 
        font-weight: bold !important; 
        margin-bottom: 2px; 
    }
    /* --- ETİKET STİLLERİ SONU --- */

    /* Geçici Ölçüm Etiketi */
    #tempMeasurementLabel {
        position: absolute;
        font-family: monospace;
        font-size: 11px;
        color: cyan;
        background: rgba(0, 0, 0, 0.5);
        padding: 2px 4px;
        border: 1px dashed cyan;
        border-radius: 3px;
        white-space: nowrap;
        pointer-events: none; /* Tıklanamaz */
        z-index: 25; /* Diğer etiketlerin üstünde */
        display: none; /* Başlangıçta gizli */
    }

    .altitude-line span {
        display: inline-block; 
        vertical-align: middle; 
    }
    /* Uçak Bilgi Paneli Stilleri - GÜNCELLENMİŞ */
    .aircraft-info-panel {
        border-top: 1px solid #555; 
        margin-top: 2px;  /* AZALTILDI */
        padding-top: 2px; /* AZALTILDI */
        font-size: 0.9em; 
    }

    /* Uçak Ekleme Formu */
    #addAircraftForm { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(60, 60, 60, 0.95); border: 2px solid #0f0; padding: 20px; border-radius: 8px; z-index: 30; color: white; font-family: Arial, sans-serif; width: 320px; box-shadow: 0 5px 15px rgba(0,0,0,0.5); display: none; }
    #addAircraftForm h3 { margin-top: 0; text-align: center; color: #0f0; }
    #addAircraftForm label { display: block; margin-bottom: 5px; font-weight: bold; font-size: 14px; }
    #addAircraftForm input[type="text"],
    #addAircraftForm input[type="number"],
    #addAircraftForm select {
        width: calc(100% - 16px);
        padding: 8px;
        margin-bottom: 10px;
        border: 1px solid #aaa;
        border-radius: 4px;
        background: #eee;
        color: #333;
        font-size: 14px;
        box-sizing: border-box;
    }
    #addAircraftForm .form-buttons { display: flex; justify-content: space-between; margin-top: 15px; }
    #addAircraftForm button { padding: 10px 20px; border: none; border-radius: 5px; font-weight: bold; cursor: pointer; }
    #addAircraftForm #submitNewAircraft { background-color: #0f0; color: black; }
    #addAircraftForm #cancelNewAircraft { background-color: #dc3545; color: white; }
    #formError { color: #ffc107; font-size: 12px; min-height: 15px; text-align: center; margin-top: 10px; }
    .glow {
        box-shadow: 0 0 8px 3px #00aaff, 0 0 2px 1px #00aaff;
        border-color: #00aaff !important;
    }

    /* YENİ CSS (Bu kısımlar zaten yukarıda vardı, birleştirirken dikkat edin) */
    html, body { /* Zaten en üstte var, bu tekrarı kaldırabilirsiniz veya birleştirebilirsiniz */
        width: 100vw; height: 100vh; /* margin: 0; padding: 0; */ /* Zaten üstte var */ overflow: hidden;
        /* background-color: #333; color: white; font-family: Arial, sans-serif; */ /* Zaten üstte var */
    }
    canvas { /* Zaten en üstte var, bu tekrarı kaldırabilirsiniz veya birleştirebilirsiniz */
        position: fixed; left: 50%; top: 50%; transform: translate(-50%, -50%);
        z-index: 1; /* display: block; background: rgba(160, 160, 160, 0.5); */ /* Zaten üstte var */
        /* cursor: grab; border: none; */ /* Zaten üstte var */
    }
    /* AIRMISS Alert */
    #airmissAlert {
        position: absolute; top: 50%; left: 30px; transform: translateY(-50%);
        background: rgba(0, 0, 0, 0.8); padding: 20px; border: 2px solid red;
        border-radius: 10px; color: red; font-family: monospace; font-size: 48px;
        font-weight: bold; text-align: center; z-index: 50; display: none;
        text-shadow: 2px 2px 4px black;
    }
    #airmissAlert span { display: block; font-size: 24px; margin-top: 10px; color: white; }
    #generateScenarioBtn {
        background-color: #4CAF50; color: white; padding: 10px 20px; margin: 5px;
        border: none; border-radius: 5px; cursor: pointer; font-size: 14px;
    }
    #generateScenarioBtn:hover { background-color: #45a049; }
    #generateScenarioBtn:active { background-color: #3d8b40; }

    #headingValues div:hover {
        background-color: #0f0; color: black; box-shadow: 0 0 8px #0f0;
    }

    #submitManualHeading {
        padding: 3px 6px; font-size: 11px; background-color: #4CAF50;
        border: none; color: white; border-radius: 2px; margin-left: 5px;
    }
    #submitManualHeading:hover { background-color: #45a049; }
    #manualHeadingInput {
        width: 50px; padding: 3px; font-size: 12px; text-align: right;
        background-color: #ddd; color: #333; border: 1px solid #777; border-radius: 2px;
    }
    
    /* ... (Diğer stilleriniz) ... */

    .intercept-btn {
        display: flex;
        align-items: center;
        justify-content: space-between;
    }

    .intercept-indicator {
        display: inline-block;
        width: 16px;
        height: 16px;
        border: 1px solid #888; 
        border-radius: 3px;
        margin-left: 10px; 
        background-color: #666; 
        font-size: 12px;
        line-height: 16px; 
        text-align: center;
        color: #0f0; 
        font-weight: bold;
        transition: background-color 0.2s, border-color 0.2s;
    }

    .intercept-btn.intercepting {
        box-shadow: 0 0 5px #ffc107; 
    }

    .intercept-btn.intercepting .intercept-indicator {
        background-color: #0f0; 
        border-color: #0a0;   
        color: black;         
    }

    .intercept-btn:disabled .intercept-indicator {
        border-color: #555;
        background-color: #444;
        color: #777; 
    }
	
	/* <style> etiketlerinizin içine ekleyin */

.air-indicator-window {
    background-color: rgba(40, 40, 50, 0.85); /* Koyu mavi-gri yarı saydam */
    border: 1px solid #0f0; /* Yeşil kenarlık */
    border-radius: 6px;
    color: #e0e0e0; /* Açık gri metin */
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; /* Okunabilir bir font */
    width: 220px; /* Genişliği ayarlayabilirsiniz */
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
    z-index: 100; /* Diğer elementlerin üzerinde olması için */
    cursor: default; /* Başlangıçta varsayılan imleç */
    user-select: none; /* Metin seçilmesini engelle */
    backdrop-filter: blur(3px);
}

.air-indicator-header {
    background-color: rgba(20, 20, 30, 0.7);
    padding: 6px 10px;
    font-weight: bold;
    text-align: center;
    border-bottom: 1px solid #0a0;
    cursor: grab; /* Başlık sürükleme için */
    border-top-left-radius: 5px;
    border-top-right-radius: 5px;
}

.air-indicator-body {
    display: flex;
    padding: 10px;
    justify-content: space-between;
}

.ai-column {
    display: flex;
    flex-direction: column;
    align-items: center;
}

.ai-speed-column {
    flex-basis: 60px; /* Hız sütunu için genişlik */
    border-right: 1px solid rgba(120, 120, 120, 0.5);
    padding-right: 10px;
    margin-right: 10px;
}

.ai-main-display {
    flex-grow: 1;
    display: flex;
    flex-direction: column;
    gap: 10px; /* Yön ve ROD arası boşluk */
}

.ai-heading-section,
.ai-rod-section {
    text-align: center;
}

.ai-label {
    font-size: 0.75em;
    color: #a0a0a0; /* Etiket rengi */
    margin-bottom: 3px;
    text-transform: uppercase;
}

.ai-value {
    font-size: 1.3em; /* Değerlerin punto boyutu */
    font-weight: bold;
    color: #0f0; /* Yeşil değerler */
    padding: 4px 6px;
    border-radius: 3px;
    min-width: 50px; /* Minimum genişlik */
    text-align: center;
}

.clickable-value {
    cursor: pointer;
    transition: background-color 0.2s;
}

.clickable-value:hover {
    background-color: rgba(0, 255, 0, 0.15); /* Hover efekti */
}
	
</style>
	
	







</head>
<body>

<div id="topLeftControls">
    <button id="fullscreenButton" class="control-button">Tam Ekran</button>
    <button id="showLocalizer21L" class="loc-btn control-button">LOC 03R</button>
    <button id="showLocalizer033Right" class="loc-btn control-button">LOC 21L</button>
	<button id="generateScenarioBtn">Senaryo Üret</button>
</div>

<div id="topCenterControls">
    <button id="interceptButton033" class="control-button intercept-btn">
        Intercept LOC 033 <span class="intercept-indicator"></span>
    </button>
    <button id="interceptButton21L" class="control-button intercept-btn">
        Intercept LOC 21L <span class="intercept-indicator"></span>
    </button>
    <button id="towerButton" class="control-button" disabled>Tower</button>
    <button id="removeButton" class="control-button" disabled>Remove</button>
</div>

<div id="bottomLeftControls">
    <div id="takeoffOptionsContainer" style="display: none;">
        <div class="takeoff-runway-option" data-runway="03R">
            <button class="takeoff-option-btn runway-btn" data-runway="03R">Kalkış 03R</button>
            <select class="waypoint-select" data-runway="03R">
                <option value="">Waypoint Seç</option>
                <option value="PETAR">PETAR</option>
                <option value="SALGO">SALGO</option>
                <option value="ASTAL">ASTAL</option>
                <option value="İLHAN">İLHAN</option>
                <option value="GURBU">GURBU</option>
                <option value="KUBER">KUBER</option>
                <option value="YUCEL">YUCEL</option>
                <option value="BAKIR">BAKIR</option>
                <option value="TELVO">TELVO</option>
                <option value="HAY">HAY</option>
            </select>
        </div>
        <div class="takeoff-runway-option" data-runway="21L">
            <button class="takeoff-option-btn runway-btn" data-runway="21L">Kalkış 21L</button>
            <select class="waypoint-select" data-runway="21L">
                <option value="">Waypoint Seç</option>
                <option value="PETAR">PETAR</option>
                <option value="SALGO">SALGO</option>
                <option value="ASTAL">ASTAL</option>
                <option value="İLHAN">İLHAN</option>
                <option value="GURBU">GURBU</option>
                <option value="KUBER">KUBER</option>
                <option value="YUCEL">YUCEL</option>
                <option value="BAKIR">BAKIR</option>
                <option value="TELVO">TELVO</option>
                <option value="HAY">HAY</option>
            </select>
        </div>
    </div>
    <button id="takeoffButton" class="control-button">Uçak Kaldır</button>
    <button id="playPauseButton" class="control-button">Durdur</button>
    <div id="speedControlContainer">
        <input type="range" id="speedSlider" min="0" max="9" step="1" value="3">
        <span id="speedValue">1x</span>
    </div>
    <button id="speedButton" class="control-button">Hız: 1x</button>
    <button id="measureButton" class="control-button">Ölçüm Yap</button>
    <button id="addAircraftButton" class="control-button">Uçak Ekle</button>
</div>

<div id="vectorControls">
    <div id="vectorToggleWrapper">
        <span id="gameTimer">00:00</span>
        <button class="control-button vector-btn" id="vectorToggle">Speed Vector: KAPALI</button>
    </div>
    <button class="control-button vector-btn active" data-minutes="1">1 Dakika</button>
    <button class="control-button vector-btn" data-minutes="2">2 Dakika</button>
    <button class="control-button vector-btn" data-minutes="3">3 Dakika</button>
    <button class="control-button vector-btn" data-minutes="4">4 Dakika</button>
    <button class="control-button vector-btn" data-minutes="5">5 Dakika</button>
    <button class="control-button vector-btn" data-minutes="6">6 Dakika</button>
    <button class="control-button vector-btn" data-minutes="7">7 Dakika</button>
</div>

<div id="labelControls">
    <label for="labelSize">Etiket Boyutu:</label>
    <input type="range" id="labelSize" min="8" max="24" value="12">
</div>

<canvas id="radar"></canvas>
<div id="popup"></div>
<div id="addAircraftForm">
    <h3>Yeni Uçak Bilgileri</h3>
    <div id="formError"></div>
    <label for="acCallsign">Çağrı Adı (ID):</label>
    <input type="text" id="acCallsign" name="callsign" required maxlength="7">

    <label for="acType">Uçak Tipi:</label>
    <select id="acType" name="type"></select>

    <label for="acHeading">Başlangıç Yönü (0-359):</label>
    <input type="number" id="acHeading" name="heading" min="0" max="359" required>
    <label for="acSpeed">Hız (kts):</label>
    <input type="number" id="acSpeed" name="speed" min="100" max="600" required>
    <label for="acAltitude">İrtifa (FL):</label>
    <input type="number" id="acAltitude" name="altitude" min="10" max="450" step="5" required>

    <label for="acDepartureFL">Tırmanış FL (Kalkış ise, örn: 240):</label>
    <input type="number" id="acDepartureFL" name="departureFL" min="10" max="450" step="5">


    <div class="form-buttons">
        <button type="button" id="cancelNewAircraft">İptal</button>
        <button type="button" id="submitNewAircraft">Uçağı Ekle</button>
    </div>
</div>
<div id="tempMeasurementLabel"></div>
<div id="runwayCenterHoverText" style="display:none; position:absolute; font-size:9px; color:white; background:rgba(0,0,0,0.6); padding:1px 3px; border-radius:2px; pointer-events:none; z-index:30; white-space:nowrap;">LTAC</div>
<div id="airmissAlert">
    AIRMISS!<br>
    <span id="airmissCallsigns"></span>
</div>
<div id="runwaySelectionModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.75); z-index: 100; align-items: center; justify-content: center;">
    <div style="background-color: #3a3a3a; padding: 25px 30px; border-radius: 8px; border: 2px solid #0f0; text-align: center; box-shadow: 0 8px 20px rgba(0,0,0,0.6);">
        <h3 style="color: #0f0; margin-top: 0; margin-bottom: 25px; font-size: 18px; font-weight: bold;">Aktif Pisti Seçin</h3>
        <button id="selectRunway03RBtn" class="control-button" style="margin: 5px 12px; padding: 12px 25px; background-color: #4CAF50; border-color: #3e8e41; font-size: 16px;">03R</button>
        <button id="selectRunway21LBtn" class="control-button" style="margin: 5px 12px; padding: 12px 25px; background-color: #4CAF50; border-color: #3e8e41; font-size: 16px;">21L</button>
        <button id="cancelRunwaySelectionBtn" class="control-button" style="margin: 15px 12px 5px; padding: 10px 22px; background-color: #f44336; border-color: #d32f2f; font-size: 14px;">İptal</button>
    </div>
</div>


<div id="infoPopupOverlay" class="info-popup-overlay">
    <div class="info-popup-content">
        <h2 id="infoPopupTitle">Oyun Adı/Başlık</h2>
        <div id="infoPopupMessage">
            <p>Yükleniyor...</p>
        </div>
        <button id="infoPopupCloseButton" class="control-button">Tamam</button>
    </div>
</div>

<div id="airIndicatorWindow" class="air-indicator-window" style="display: none; position: absolute; top: 100px; left: 100px;">
    <div class="air-indicator-header">
        <span id="aiCallsign">UÇAK-ID</span>
    </div>
    <div class="air-indicator-body">
        <div class="ai-column ai-speed-column">
            <div class="ai-label">SPD</div>
            <div id="aiSpeedValue" class="ai-value clickable-value" data-field="speedKTS">---</div>
            </div>
        <div class="ai-column ai-main-display">
            <div class="ai-heading-section">
                <div class="ai-label">HDG</div>
                <div id="aiHeadingValue" class="ai-value clickable-value" data-field="heading">---°</div>
            </div>
            <div class="ai-rod-section">
                <div class="ai-label">VS</div>
                <div id="aiRodValue" class="ai-value clickable-value" data-field="rateOfDescent">-----</div>
            </div>
        </div>
    </div>
</div>



<script>
// --- Canvas ve DOM Elementleri ---
const canvas = document.getElementById('radar');
const ctx = canvas.getContext('2d');
const fullscreenButton = document.getElementById('fullscreenButton');
const vectorToggle = document.getElementById('vectorToggle');
const popup = document.getElementById('popup');
const labelSizeControl = document.getElementById('labelSize');
const btnLoc21L = document.getElementById('showLocalizer21L');
const btnLocRight = document.getElementById('showLocalizer033Right');
const addAircraftButton = document.getElementById('addAircraftButton');
const addAircraftForm = document.getElementById('addAircraftForm');
const submitNewAircraftBtn = document.getElementById('submitNewAircraft');
const cancelNewAircraftBtn = document.getElementById('cancelNewAircraft');
const formErrorDiv = document.getElementById('formError');
const inputCallsign = document.getElementById('acCallsign');
const inputType = document.getElementById('acType');
const inputHeading = document.getElementById('acHeading');
const inputSpeed = document.getElementById('acSpeed');
const inputAltitude = document.getElementById('acAltitude');
const inputDepartureFL = document.getElementById('acDepartureFL');
const measureButton = document.getElementById('measureButton');
const interceptButton033 = document.getElementById('interceptButton033');
const interceptButton21L = document.getElementById('interceptButton21L');
const speedButton = document.getElementById('speedButton');
const speedControlContainer = document.getElementById('speedControlContainer');
const speedSlider = document.getElementById('speedSlider');
const speedValueSpan = document.getElementById('speedValue');
const towerButton = document.getElementById('towerButton');
const removeButton = document.getElementById('removeButton');
const playPauseButton = document.getElementById('playPauseButton');
const takeoffButton = document.getElementById('takeoffButton');
const takeoffOptionsContainer = document.getElementById('takeoffOptionsContainer');
const tempMeasurementLabel = document.getElementById('tempMeasurementLabel');
const runwayCenterHoverText = document.getElementById('runwayCenterHoverText');
const runwaySelectionModal = document.getElementById('runwaySelectionModal');
const selectRunway03RBtn = document.getElementById('selectRunway03RBtn');
const selectRunway21LBtn = document.getElementById('selectRunway21LBtn');
const cancelRunwaySelectionBtn = document.getElementById('cancelRunwaySelectionBtn');

const WORLD_ORIGIN_X = 0; // Radarın dünya X koordinatı (örneğin 0)
const WORLD_ORIGIN_Y = 0; // Radarın dünya Y koordinatı (örneğin 0)
// grid hattına loc hattına ne kadar yaklaşırsa establish olur?
const START_ALIGN_ON_LOC_THRESHOLD_NM = 0.1; // Uçağın LOC hattına hizalanmaya başlaması için merkeze olan NM cinsinden eşik mesafe (örneğin 0.3 NM)
const ARRIVAL_AT_WAYPOINT_THRESHOLD_NM = 3;  // Varış uçağının başlangıç waypoint'ine ulaştı sayılma eşiği (NM)



let airIndicatorWindow = null;
let aiCallsign = null;
let aiSpeedValue = null;
let aiRodValue = null;
let aiHeadingValue = null;

let isDraggingAirIndicator = false;
let airIndicatorDragOffsetX = 0;
let airIndicatorDragOffsetY = 0;

speedSlider.addEventListener('input', () => {
    const sliderValue = parseInt(speedSlider.value); // Integer from 0 to 9
    speedFactor = speedMultipliers[sliderValue]; // Map to [0.25, 0.5, 0.75, 1, 1.25, 1.5, 2, 3, 5, 10]
    gameSpeedMultiplier = speedFactor; // Synchronize game speed
    speedValue.textContent = `${speedFactor}x`;
    speedButton.textContent = `Hız: ${speedFactor}x`;
    console.log(`Speed changed to ${speedFactor}x, sliderValue: ${sliderValue}`); // Debug
    // Clear and restart timer
    if (timerInterval) {
        clearInterval(timerInterval);
        timerInterval = null;
    }
    startGameTimer();
});

const callsignPrefixes = ['THY', 'PGT', 'SXS', 'ONR', 'AFR', 'BAW', 'DLH', 'KLM', 'UAE', 'QTR', 'BER', 'AUA'];
let scenarioAircraftIdCounter = 0;
let pendingSpawns = [];
let usedCallsignsInScenario = new Set(); // Bu senaryo için kullanılan çağrı adlarını tutacak
const SCENARIO_START_ELAPSED_TIME = 36000;

// --- Uçak Tipleri Veritabanı ---
const aircraftTypes = ['C130', 'A342', 'B737', 'B747', 'A321', 'A320', 'A319', 'MD83', 'AN12', 'F16'];
const defaultAircraftSpeeds = { // Knot cinsinden ortalama seyir hızları
    'C130': 230, 'A342': 280, 'B737': 300, 'B747': 270, 'A321': 290,
    'A320': 300, 'A319': 275, 'MD83': 260, 'AN12': 210, 'F16': 240
};
const aircraftPerformanceROC = { // Feet/dakika cinsinden tipik tırmanma oranları
    'C130': 1800, 'A342': 2200, 'B737': 2500, 'B747': 1500, 'A321': 2400,
    'A320': 2500, 'A319': 2400, 'MD83': 2300, 'AN12': 2000, 'F16': 2500
};

// --- Arka Plan Resmi ---
const backgroundImage = new Image();
backgroundImage.src = 'arkaplanim4.jpeg';
backgroundImage.onload = () => { console.log("Arka plan resmi yüklendi."); };
backgroundImage.onerror = () => {
    console.error("Arka plan resmi yüklenemedi! Placeholder kullanılıyor.");
};
const imageInnerCircleDiameterFraction = 0.197;
let backgroundOffsetX = -50; let backgroundOffsetY = 66;

// --- Canvas Boyutları ve Merkez ---
let canvasWidth, canvasHeight, centerX, centerY;

// --- Durum Değişkenleri ---
let zoom = 1.0; let panX = 0; let panY = 0;
let isPanning = false; let isDraggingLabel = false;
let draggedLabelItem = null; let draggedLabelType = null;
let dragOffsetX = 0; let dragOffsetY = 0;
let lastMouseX = 0; let lastMouseY = 0;
const baseNmToPixels = 20; const innerCircleRadiusNM = 10;
let labelFontSize = 12; let lastTime = performance.now();
let showVectors = false; let vectorMinutes = 1;
let selectedAircraft = null; let isPlacingAircraft = false;
let pendingAircraftLocation = null; let showLocalizerLeft = false; let showLocalizerRight = false;
const runwayCourse = 33;
const localizerCourse033Right = 33;
const localizerCourse21L = 213;
const INTERCEPT_TARGET_COURSE_033 = localizerCourse033Right;
const INTERCEPT_TARGET_COURSE_21L = localizerCourse21L;
const localizerLengthNM = 25;
const runwayLengthNM = 2; const runwayWidthNM = 0.2;
const DEFAULT_ROD = 1500; const DEFAULT_CLIMB_RATE = 2500;
const INTERCEPT_ANGLE_MIN_033 = 30; const INTERCEPT_ANGLE_MAX_033 = 60;
const INTERCEPT_ANGLE_MIN_21L = 170; const INTERCEPT_ANGLE_MAX_21L = 255;
const INTERCEPT_MAX_DIST_NM = 25; const ON_LOCALIZER_THRESHOLD_PX = 0.5;
const ON_LOCALIZER_THRESHOLD_NM = 0.07;
const RUNWAY_THRESHOLD_DIST_PX = 5; let gameSpeedMultiplier = 1.0;
const speedMultipliers = [0.25, 0.5, 0.75, 1, 1.25, 1.5, 2, 3, 5, 10];
let isPaused = false;
let departureCounter = 0;
let gameStartTime = null;
let elapsedTime = 36000;
let timerInterval = null;
let speedFactor = 1;

// --- Ölçüm Durumu ---
let isMeasuring = false; let measurementStartPoint = null; let hoveredAircraftForMeasure = null;
let measurements = [];
let hoveredRunwayCenterForMeasure = false;

// --- Uçak Verileri ---
const aircrafts = [
    { id: 'THY123', x: 0, y: 0, heading: 210, targetHeading: 210, speedKTS: defaultAircraftSpeeds['A321'] || 220, altitude: 5000, targetAltitude: 5000, rateOfDescent: 0, rateOfClimb: 0, isTakingOff: false, takeoffRunway: null, isIntercepting: false, isHandedOffToTower: false, showVector: false, labelElement: null, labelX: 0, labelY: 0, labelDragged: false, bankAngle: 0, maxBankAngle: 25, commandedTurnDirection: 0, turning: false, type: 'A321', departureTargetFL: 280, showInfoPanel: false, showTrajectory: false, draggedLabelDeltaX: 0, draggedLabelDeltaY: 0, lastHeadingUpdateTime: 0, initialPosSet: false },
    { id: 'PGS456', x: 0, y: 0, heading: 30, targetHeading: 30, speedKTS: defaultAircraftSpeeds['B737'] || 250, altitude: 4000, targetAltitude: 4000, rateOfDescent: 0, rateOfClimb: 0, isTakingOff: false, takeoffRunway: null, isIntercepting: false, isHandedOffToTower: false, showVector: false, labelElement: null, labelX: 0, labelY: 0, labelDragged: false, bankAngle: 0, maxBankAngle: 25, commandedTurnDirection: 0, turning: false, type: 'B737', departureTargetFL: null, showInfoPanel: false, showTrajectory: false, draggedLabelDeltaX: 0, draggedLabelDeltaY: 0, lastHeadingUpdateTime: 0, initialPosSet: false },
];

// --- WAYPOINT ADDITION START ---
const waypoints = [
    { name: 'PETAR', angle: 270, distanceNM: 43, arrivalTrack: 097 }, 
	{ name: 'SALGO', angle: 296, distanceNM: 43.3, arrivalTrack: 110 },
    { name: 'ASTAL', angle: 6,   distanceNM: 38.8, arrivalTrack: 196 }, 
	{ name: 'İLHAN', angle: 57,  distanceNM: 39, arrivalTrack: 243 },
    { name: 'GURBU', angle: 83,  distanceNM: 40, arrivalTrack: 274 },   
	{ name: 'KUBER', angle: 118, distanceNM: 33.5, arrivalTrack: 284 },
    { name: 'YUCEL', angle: 136, distanceNM: 42.3, arrivalTrack: 305 }, 
	{ name: 'BAKIR', angle: 155, distanceNM: 42.9, arrivalTrack: 327 },
    { name: 'TELVO', angle: 181, distanceNM: 44, arrivalTrack: 349 },   
	{ name: 'HAY',   angle: 206, distanceNM: 46, arrivalTrack: 066 }
];
// --- WAYPOINT ADDITION END ---

// --- Yardımcı Fonksiyonlar ---
function toRadians(degrees) { return degrees * Math.PI / 180; }
function toDegrees(radians) { return (radians * 180 / Math.PI + 360) % 360; }
function nmToWorldPixels(nm) { return nm * baseNmToPixels; }
function worldPixelsToNm(pixels) { return pixels / baseNmToPixels; }
function angleDiff(a1, a2) { let diff = a1 - a2; while (diff <= -180) diff += 360; while (diff > 180) diff -= 360; return diff; }
function pointLineDistance(px, py, ax, ay, bx, by) { const n = Math.sqrt((bx - ax) ** 2 + (by - ay) ** 2); if (n === 0) return Math.sqrt((px - ax) ** 2 + (py - ay) ** 2); return Math.abs((px - ax) * (by - ay) - (py - ay) * (bx - ax)) / n; }
function calculateBearing(x1, y1, x2, y2) { const dx = x2 - x1; const dy = y2 - y1; const aR = Math.atan2(dx, -dy); return toDegrees(aR); }
function formatBearing(b) { return (b === null || b === undefined) ? "---" : Math.round(b).toString().padStart(3, '0'); }
function formatRelativeBearing(rb) { if (rb === null || rb === undefined) return ""; const r = Math.round(Math.abs(rb)); const d = rb >= 0 ? 'R' : 'L'; return `${d}${r.toString().padStart(2, '0')}`; }
function formatFlightLevel(alt) { return (alt === null || alt === undefined) ? "---" : `F${Math.round(alt / 100).toString().padStart(3, '0')}`; }

function isHeadingInRange(heading, rangeStart, rangeEnd) {
    heading = (parseFloat(heading) + 360) % 360; // Normalize heading to 0-359.99
    rangeStart = (parseFloat(rangeStart) + 360) % 360;
    rangeEnd = (parseFloat(rangeEnd) + 360) % 360;

    if (rangeStart <= rangeEnd) {
        // Normal aralık, örn: 100-180
        return heading >= rangeStart && heading <= rangeEnd;
    } else {
        // 0/360 derecesini geçen aralık, örn: 350-010
        return (heading >= rangeStart && heading <= 359.99) || (heading >= 0 && heading <= rangeEnd);
    }
}


function generateUniqueCallsign(basePrefix, baseNumber, existingCallsignsSet) {
    let potentialCallsign = `${basePrefix}${baseNumber}`;
    let attempt = 0;
    // Hem bu senaryoda daha önce üretilenlerle hem de oyundaki mevcut tüm uçaklarla çakışma kontrolü
    while (existingCallsignsSet.has(potentialCallsign) || aircrafts.some(ac => ac.id === potentialCallsign)) {
        attempt++;
        potentialCallsign = `${basePrefix}${baseNumber + attempt}`; // Basit bir artırma stratejisi
        // Daha karmaşık bir strateji de uygulanabilir, örn: tamamen yeni bir rastgele numara denemek
        if (attempt > 100) { // Sonsuz döngüyü engellemek için bir sınır (çok olası değil ama tedbir)
            console.warn(`generateUniqueCallsign: ${basePrefix}${baseNumber} için 100 denemeden sonra benzersiz çağrı adı bulunamadı. Çok nadir bir durum.`);
            potentialCallsign = `${basePrefix}${baseNumber}_${Date.now().toString().slice(-4)}`; // Son çare
            break;
        }
    }
    existingCallsignsSet.add(potentialCallsign); // Üretilen benzersiz çağrı adını sete ekle
    return potentialCallsign;
}
function calculateDynamicInterceptAngle(aircraft, locCourse) {
    const interceptCutAngle = 30; // İstenen kesme açısı (derece)

    // Pist merkezi (veya LOC hattının geçtiği referans nokta) dünya orijini olmalı
    const refX = WORLD_ORIGIN_X;
    const refY = WORLD_ORIGIN_Y;

    // Uçaktan referans noktasına olan vektör
    const vectorAircraftToRefX = refX - aircraft.x;
    const vectorAircraftToRefY = refY - aircraft.y;

    // Uçaktan referans noktasına olan açı (Kuzey 0, saat yönünde artan)
    const angleAircraftToRef = toDegrees(Math.atan2(vectorAircraftToRefX, -vectorAircraftToRefY));

    // Uçağın LOC'a göre hangi tarafta olduğunu ve nasıl bir kesme yapması gerektiğini belirle
    let diff = angleDiff(locCourse, angleAircraftToRef);
    let targetHeading;

    if (Math.abs(diff) < 5) { // Uçak zaten neredeyse LOC hattı üzerinde (referans noktasına göre)
        targetHeading = locCourse; // Doğrudan LOC'a dön
    } else if (diff > 0) {
        // LOC, uçağın referans noktasına baktığı açının "sağında".
        // Sola dönerek kesmeli (LOC + kesme açısı)
        targetHeading = (locCourse + interceptCutAngle + 360) % 360;
    } else {
        // LOC, uçağın referans noktasına baktığı açının "solunda".
        // Sağa dönerek kesmeli (LOC - kesme açısı)
        targetHeading = (locCourse - interceptCutAngle + 360) % 360;
    }
    return Math.round(targetHeading);
}


// Süreyi HH:MM:SS formatına çeviren fonksiyon
function formatTime(totalSeconds) {
    const hours = Math.floor(totalSeconds / 3600);
    const minutes = Math.floor((totalSeconds % 3600) / 60);
    const secs = Math.floor(totalSeconds % 60); // Kalan saniyeler

    // Her zaman iki basamaklı göstermek için padStart kullan
    const formattedHours = hours.toString().padStart(2, '0');
    const formattedMinutes = minutes.toString().padStart(2, '0');
    const formattedSeconds = secs.toString().padStart(2, '0');

    return `${formattedHours}:${formattedMinutes}:${formattedSeconds}`;
}

// Zamanlayıcıyı başlatma ve güncelleme fonksiyonu
function startGameTimer() {
    const gameTimer = document.getElementById('gameTimer');

    // Başlangıçta veya yeniden başlatıldığında zamanı hemen ayarla
    if (gameTimer) {
        gameTimer.textContent = formatTime(Math.floor(elapsedTime)); // Math.floor() ile tam saniye gösterimi
    }

    // Clear any existing interval
    if (timerInterval) {
        clearInterval(timerInterval);
        timerInterval = null;
    }

    if (!isPaused) {
        timerInterval = setInterval(() => {
            if (!isPaused) {
                // speedFactor, her bir "gerçek" saniyede oyun zamanına eklenecek saniye sayısıdır.
                // Örneğin, speedFactor = 1 ise, her saniye 1 oyun saniyesi eklenir.
                // speedFactor = 2 ise, her saniye 2 oyun saniyesi eklenir (oyun 2x hızında).
                elapsedTime += speedFactor; 
                if (gameTimer) {
                    gameTimer.textContent = formatTime(Math.floor(elapsedTime)); // Gösterimi güncelle
                }
            }
        }, 1000); // Her 1000 milisaniyede (1 gerçek saniyede) bir çalışır
    }
}

function toggleTimer(pause) {
    if (pause) {
        if (timerInterval) {
            clearInterval(timerInterval);
            timerInterval = null;
        }
    } else {
        if (timerInterval) { // Clear any existing before restarting
            clearInterval(timerInterval);
            timerInterval = null;
        }
        startGameTimer();
    }
}

// --- Koordinat Dönüşüm Fonksiyonları ---
function worldToScreen(worldX, worldY) { return { x: (worldX * zoom) + panX, y: (worldY * zoom) + panY }; }
function screenToWorld(screenX, screenY) { const r = canvas.getBoundingClientRect(); return { x: (screenX - r.left - panX) / zoom, y: (screenY - r.top - panY) / zoom }; }

// --- Canvas ve Arka Plan Boyutlandırma ---
function resizeCanvas() {
    // const prevCanvasWidth = canvasWidth; // YORUM SATIRI VEYA SİL
    // const prevCanvasHeight = canvasHeight; // YORUM SATIRI VEYA SİL
    // const oldPanX = panX; // YORUM SATIRI VEYA SİL
    // const oldPanY = panY; // YORUM SATIRI VEYA SİL
    // const currentZoom = zoom; // YORUM SATIRI VEYA SİL

    const bodyWidth = document.body.clientWidth;
    const bodyHeight = document.body.clientHeight;
    const newSize = Math.min(bodyWidth, bodyHeight);

    canvasWidth = newSize;
    canvasHeight = newSize;

    const dpr = window.devicePixelRatio || 1;
    canvas.width = canvasWidth * dpr;
    canvas.height = canvasHeight * dpr;

    canvas.style.width = `${canvasWidth}px`;
    canvas.style.height = `${canvasHeight}px`;

    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.scale(dpr, dpr);

    // centerX ve centerY hala canvas'ın PİKSEL cinsinden ortasını temsil eder.
    // UI elemanları veya fare pozisyonu hesaplamaları için kullanılabilir.
    // Ancak dünya objelerinin merkezi için WORLD_ORIGIN_X/Y kullanılacak.
    centerX = canvasWidth / 2;
    centerY = canvasHeight / 2;

    // --- BU BLOK KALDIRILACAK VEYA YORUM SATIRI YAPILACAK ---
    /*
    if (typeof prevCanvasWidth === 'number' && typeof prevCanvasHeight === 'number' &&
        prevCanvasWidth > 0 && prevCanvasHeight > 0 && currentZoom !== 0) {
        const worldPointX_atOldScreenCenter = (prevCanvasWidth / 2 - oldPanX) / currentZoom;
        const worldPointY_atOldScreenCenter = (prevCanvasHeight / 2 - oldPanY) / currentZoom;
        panX = newScreenCenterX - worldPointX_atOldScreenCenter * currentZoom; // newScreenCenterX aslında yeni centerX
        panY = newScreenCenterY - worldPointY_atOldScreenCenter * currentZoom; // newScreenCenterY aslında yeni centerY
    }
    */

    aircrafts.forEach(ac => {
        if (!ac.initialPosSet) {
            // Uçakların ilk pozisyonları WORLD_ORIGIN'e göre ayarlanmalı
            if (ac.id === 'THY123') {
                ac.x = WORLD_ORIGIN_X + nmToWorldPixels(10);
                ac.y = WORLD_ORIGIN_Y - nmToWorldPixels(7.5);
            } else if (ac.id === 'PGS456') {
                ac.x = WORLD_ORIGIN_X - nmToWorldPixels(5);
                ac.y = WORLD_ORIGIN_Y + nmToWorldPixels(12.5);
            } else { // Diğer rasgele yerleştirilen uçaklar için
                ac.x = WORLD_ORIGIN_X + (Math.random() - 0.5) * nmToWorldPixels(innerCircleRadiusNM * 2);
                ac.y = WORLD_ORIGIN_Y + (Math.random() - 0.5) * nmToWorldPixels(innerCircleRadiusNM * 2);
            }
            ac.initialPosSet = true;
        }
    });
    // startGameTimer(); // Bu burada kalabilir, zamanlayıcıyı etkilemez.
}





function updateTemporaryMeasurementLabel() {
    if (!isMeasuring || !measurementStartPoint || !tempMeasurementLabel) {
        if (tempMeasurementLabel) tempMeasurementLabel.style.display = 'none';
        return;
    }
    try {
        const worldMousePos = screenToWorld(lastMouseX, lastMouseY);
        let startX = measurementStartPoint.x; let startY = measurementStartPoint.y;
        if (measurementStartPoint.type === 'aircraft') {
            const ac = aircrafts.find(a => a.id === measurementStartPoint.id);
            if (ac) { startX = ac.x; startY = ac.y; }
            else { tempMeasurementLabel.style.display = 'none'; return; }
        }
        const dx = worldMousePos.x - startX; const dy = worldMousePos.y - startY;
        const distanceNM = worldPixelsToNm(Math.sqrt(dx * dx + dy * dy));
        const bearing = calculateBearing(startX, startY, worldMousePos.x, worldMousePos.y);
        tempMeasurementLabel.style.display = 'block';
        const labelWidth = tempMeasurementLabel.offsetWidth || 80;
        const labelHeight = tempMeasurementLabel.offsetHeight || 20;
        let labelX = lastMouseX + 15; let labelY = lastMouseY - 10;
        labelX = Math.max(0, Math.min(labelX, window.innerWidth - labelWidth - 5));
        labelY = Math.max(0, Math.min(labelY, window.innerHeight - labelHeight - 5));
        tempMeasurementLabel.style.left = `${labelX}px`;
        tempMeasurementLabel.style.top = `${labelY}px`;
        tempMeasurementLabel.textContent = `${formatBearing(bearing)}° / ${distanceNM.toFixed(1)} NM`;
    } catch (error) {
        console.error("Error updating temporary measurement label:", error);
        if (tempMeasurementLabel) tempMeasurementLabel.style.display = 'none';
    }
}



function drawRadarCircles() {
    ctx.strokeStyle = 'rgba(128, 0, 32, 0.6)';
    ctx.lineWidth = 1 / zoom;
    for (let i = 1; i <= 4; i++) {
        const rNM = innerCircleRadiusNM * i; const rPx = nmToWorldPixels(rNM);
        ctx.beginPath();
        ctx.arc(WORLD_ORIGIN_X, WORLD_ORIGIN_Y, rPx, 0, 2 * Math.PI); // Değişiklik
        ctx.stroke();
    }
}
function drawDirectionLines() {   
}

function drawWaypoints() {
    const waypointColor = 'saddlebrown';        // Waypoint üçgen rengi
    const waypointTextColor = 'saddlebrown';    // Waypoint yazı rengi
    const triangleSize = 6 / zoom;            // Waypoint üçgen boyutu (zoom'a göre ölçeklenir)
    // const textOffsetY = (triangleSize * 0.5) + (10 / zoom); // Orijinal koddaki bu satır aşağıdaki ctx.fillText içinde doğrudan kullanılıyor gibi

    ctx.fillStyle = waypointColor;
    ctx.strokeStyle = 'rgba(50,20,0,0.8)'; // Üçgen kenarlık rengi
    ctx.lineWidth = 0.5 / zoom;           // Üçgen kenarlık kalınlığı

    waypoints.forEach(wp => {
        const angleRad = toRadians(wp.angle);
        const distancePixels = nmToWorldPixels(wp.distanceNM); // nmToWorldPixels fonksiyonunuzu kullanıyoruz

        // DEĞİŞİKLİK BURADA: centerX ve centerY yerine WORLD_ORIGIN_X ve WORLD_ORIGIN_Y kullanılıyor
        const wpX = WORLD_ORIGIN_X + Math.sin(angleRad) * distancePixels;
        const wpY = WORLD_ORIGIN_Y - Math.cos(angleRad) * distancePixels; // Y ekseni ters olduğu için çıkarıyoruz

        // Waypoint sembolünü (üçgen) çiz
        ctx.beginPath();
        // Üçgenin tepe noktası (wpY'den yukarı doğru)
        ctx.moveTo(wpX, wpY - triangleSize * 0.66);
        // Sol alt köşe
        ctx.lineTo(wpX - triangleSize * 0.5, wpY + triangleSize * 0.33);
        // Sağ alt köşe
        ctx.lineTo(wpX + triangleSize * 0.5, wpY + triangleSize * 0.33);
        ctx.closePath(); // Yolu kapat
        ctx.fill();      // İçini boya
        ctx.stroke();    // Kenarlığını çiz

        // Waypoint adını yaz
        ctx.fillStyle = waypointTextColor;
        ctx.font = `${10 / zoom}px Arial`; // Yazı boyutu (zoom'a göre ölçeklenir)
        ctx.textAlign = 'center';
        ctx.textBaseline = 'top';         // Yazıyı üçgenin hemen altına yerleştirmek için
        // Yazının dikey konumu: üçgenin alt tabanının biraz altı
        ctx.fillText(wp.name, wpX, wpY + triangleSize * 0.33 + (2 / zoom));
    });
}

function drawRunwayAndLocalizers() {
    ctx.save();
    ctx.translate(WORLD_ORIGIN_X, WORLD_ORIGIN_Y); // Değişiklik
    ctx.rotate(toRadians(runwayCourse));
    const rLenPx = nmToWorldPixels(runwayLengthNM); const rWidPx = nmToWorldPixels(runwayWidthNM);
    ctx.fillStyle = 'rgba(255, 255, 255, 0.6)'; ctx.fillRect(-rWidPx / 2, -rLenPx / 2, rWidPx, rLenPx);
    ctx.restore();
    // drawLocalizerBeam fonksiyonu da WORLD_ORIGIN_X/Y kullanacak şekilde güncellenmeli
    if (showLocalizerLeft) { drawLocalizerBeam(1); }
    if (showLocalizerRight) { drawLocalizerBeam(-1); }
}


function drawLocalizerBeam(side) {
    // 'side' parametresine göre hangi localizer'ın çizileceğini belirle
    // Kodunuzda side === 1 için showLocalizerLeft (21L) ve side === -1 için showLocalizerRight (033R) kullanılıyor.
    // Bu mantığa göre doğru kursu seçiyoruz.
    let angleDeg;
    if (side === 1) { // Genellikle sol localizer (örneğin 21L için)
        angleDeg = localizerCourse21L; // Kodunuzdaki showLocalizerLeft (btnLoc21L) ile ilişkili kurs
    } else { // Genellikle sağ localizer (örneğin 03R/033 için)
        angleDeg = localizerCourse033Right; // Kodunuzdaki showLocalizerRight (btnLocRight) ile ilişkili kurs
    }

    const localizerRadialRad = toRadians(angleDeg); // Localizer'ın manyetik yönünü radyana çevir

    const defaultDotColor = 'rgba(128, 0, 32, 0.8)'; // Noktaların varsayılan rengi
    const highlightDotColor = '#ffffff';             // 12 NM noktasının vurgu rengi
    const dotRadius = 2 / zoom;                      // Noktaların yarıçapı (zoom'a göre ölçeklenir)
    const lineStrokeStyle = 'rgba(128, 0, 32, 0.4)'; // Noktaları birleştiren çizginin rengi
    const lineWidth = 1 / zoom;                      // Çizgi kalınlığı

    const points = []; // Çizilecek noktaların koordinatlarını saklamak için dizi

    // Localizer boyunca her 1 NM'de bir nokta çiz
    for (let i = 1; i <= localizerLengthNM; i++) {
        // DEĞİŞİKLİK BURADA: Noktanın X ve Y koordinatları WORLD_ORIGIN referans alınarak hesaplanıyor
        const pointWorldX = WORLD_ORIGIN_X + Math.sin(localizerRadialRad) * nmToWorldPixels(i);
        const pointWorldY = WORLD_ORIGIN_Y - Math.cos(localizerRadialRad) * nmToWorldPixels(i); // Y ekseni ters olduğu için çıkarıyoruz

        points.push({ x: pointWorldX, y: pointWorldY }); // Noktayı diziye ekle

        // Noktayı çiz
        ctx.beginPath();
        ctx.arc(pointWorldX, pointWorldY, dotRadius, 0, 2 * Math.PI);
        // 12 NM noktasını farklı renkte vurgula
        ctx.fillStyle = (i === 12) ? highlightDotColor : defaultDotColor;
        ctx.fill();
    }

    // Noktaları birleştiren ince bir çizgi çiz (isteğe bağlı, görselleştirme için)
    if (points.length > 1) {
        ctx.save(); // Mevcut çizim durumunu kaydet
        ctx.strokeStyle = lineStrokeStyle;
        ctx.lineWidth = lineWidth;
        ctx.beginPath();
        ctx.moveTo(points[0].x, points[0].y); // İlk noktadan başla
        for (let i = 1; i < points.length; i++) {
            ctx.lineTo(points[i].x, points[i].y); // Sonraki noktalara çizgi çek
        }
        ctx.stroke(); // Çizgiyi çiz
        ctx.restore(); // Önceki çizim durumuna geri dön
    }
}
function drawAircraft(ac) {
    ctx.save();
    ctx.translate(ac.x, ac.y);
    const s = 4 / zoom;
    if (ac.highlighted) {
        ctx.beginPath(); ctx.arc(0, 0, s + 5, 0, 2 * Math.PI);
        ctx.strokeStyle = '#00aaff'; ctx.lineWidth = 3 / zoom;
        ctx.shadowColor = '#00aaff'; ctx.shadowBlur = 10 / zoom;
        ctx.stroke(); ctx.shadowBlur = 0;
    }
    ctx.fillStyle = ac === selectedAircraft ? '#0f0' : '#fff'; // Yeşil seçiliyse, değilse beyaz
    if (isMeasuring && hoveredAircraftForMeasure && ac.id === hoveredAircraftForMeasure.id) {
        ctx.fillStyle = '#00aaff'; // Ölçüm için hover rengi
    }
    ctx.beginPath(); ctx.arc(0, 0, s, 0, 2 * Math.PI); ctx.fill();
    ctx.strokeStyle = 'rgba(0, 0, 0, 0.7)'; ctx.lineWidth = 1 / zoom; // Uçak sembolü kenarlığı
    ctx.beginPath(); ctx.arc(0, 0, s, 0, 2 * Math.PI); ctx.stroke();
    ctx.restore();
}

function drawSpeedVector(ac) {
    const spNMm = ac.speedKTS / 60; // NM per minute
    const totalMinutes = vectorMinutes;
    const segmentLengthNM = spNMm; // Each segment represents 1 minute of travel

    const rad = toRadians(ac.heading); // Uçağın global yönü (0 derece = -Y ekseni)
    const startX = ac.x;
    const startY = ac.y;

    const baseLineWidth = 1 / zoom;
    ctx.lineWidth = baseLineWidth * 1.3;

    const arrowSize = 8 / zoom;
    const arrowAngleRad = Math.PI / 8; // Okun yarım açısı

    for (let i = 0; i < totalMinutes; i++) {
        const segmentStartDistPx = nmToWorldPixels(i * segmentLengthNM);
        const segmentEndDistPx = nmToWorldPixels((i + 1) * segmentLengthNM);

        const segStartX = startX + Math.sin(rad) * segmentStartDistPx;
        const segStartY = startY - Math.cos(rad) * segmentStartDistPx;
        const segEndX = startX + Math.sin(rad) * segmentEndDistPx;
        const segEndY = startY - Math.cos(rad) * segmentEndDistPx;

        ctx.strokeStyle = i % 2 === 0 ? 'rgba(0, 0, 0, 0.9)' : 'rgba(255, 255, 255, 0.9)';

        ctx.beginPath();
        ctx.moveTo(segStartX, segStartY);
        ctx.lineTo(segEndX, segEndY);
        ctx.stroke();

        // Ok başını çiz
        ctx.save();
        ctx.fillStyle = 'rgba(0, 0, 0, 0.95)'; // Ok başı her zaman siyah

        // Okun sivri ucu (segEndX, segEndY)
        // İki taban noktasını hesaplayalım.
        // Ok, (segEndX, segEndY)'den geriye doğru, uçağın gittiği yöne zıt bir açıyla açılmalı.
        // Uçağın gidiş yönünün tersi olan açı: rad + Math.PI
        const tailAngle1 = rad + Math.PI - arrowAngleRad;
        const tailAngle2 = rad + Math.PI + arrowAngleRad;

        const tailX1 = segEndX + arrowSize * Math.sin(tailAngle1);
        const tailY1 = segEndY - arrowSize * Math.cos(tailAngle1);

        const tailX2 = segEndX + arrowSize * Math.sin(tailAngle2);
        const tailY2 = segEndY - arrowSize * Math.cos(tailAngle2);

        ctx.beginPath();
        ctx.moveTo(segEndX, segEndY); // Sivri uç
        ctx.lineTo(tailX1, tailY1);   // Bir taban noktası
        ctx.lineTo(tailX2, tailY2);   // Diğer taban noktası
        ctx.closePath();
        ctx.fill();
        ctx.restore();
    }
}

function drawConnectionLine(item, type) {
    if (!item.labelElement || !item.labelDragged) return;
    let sSX, sSY;
    let strC; // Rengi burada belirleyeceğiz
    let lineWidth = 1.5; // Varsayılan çizgi kalınlığı

    if (type === 'aircraft') {
        strC = 'rgba(0, 0, 0, 0.7)'; // Uçak bağlantı çizgisi siyah
        // lineWidth = 1.5; // Zaten varsayılan
        const sP = worldToScreen(item.x, item.y); sSX = sP.x; sSY = sP.y;
    } else if (type === 'measurement') {
        strC = 'rgba(0, 255, 255, 0.75)'; // YENİ: Ölçüm bağlantı çizgisi cyan (biraz daha opak)
        // lineWidth = 1.5; // Zaten varsayılan
        const mXW = (item.start.x + item.end.x) / 2; const mYW = (item.start.y + item.end.y) / 2;
        const sP = worldToScreen(mXW, mYW); sSX = sP.x; sSY = sP.y;
    } else { return; }

    const lR = item.labelElement.getBoundingClientRect();
    const cR = canvas.getBoundingClientRect();
    // Etiketin merkezine bağla
    const lCX = lR.left - cR.left + lR.width / 2;
    const lCY = lR.top - cR.top + lR.height / 2;

    ctx.save();
    const dpr = window.devicePixelRatio || 1;
    // drawRadar sonundaki ctx.restore() sonrası bu fonksiyon çağrıldığı için
    // pan/zoom'suz mutlak canvas koordinatlarına geçiş yapmalıyız.
    // sSX, sSY (worldToScreen'den gelen) ve lCX, lCY (DOM'dan gelen) canvas'ın görünen CSS pikselleridir.
    // Canvas context'i zaten DPR'ye göre ölçeklenmiş durumda (resizeCanvas içinde ctx.scale(dpr,dpr)).
    // Bu yüzden doğrudan bu koordinatları kullanabiliriz.
    // Ancak, setLineDash gibi özellikler DPR'den etkilenebilir.
    // En temizi, bu fonksiyonun başında ctx.setTransform(dpr, 0, 0, dpr, 0, 0) yapmak ve
    // sonra koordinatları buna göre ayarlamak ya da lineDash gibi değerleri dpr ile çarpmak.
    // Mevcut yapıda, drawRadar'ın sonundaki ctx.restore() pan/zoom'u sıfırlar ama DPR ölçeklemesini korur.
    // Bu yüzden doğrudan sSX, lCX kullanabiliriz.

    ctx.beginPath();
    ctx.moveTo(sSX, sSY);
    ctx.lineTo(lCX, lCY);

    ctx.strokeStyle = strC;
    ctx.lineWidth = lineWidth; // Kalınlık önceki güncellemeden
    // Noktalı çizgi stilini DPR'ye göre ayarlamak iyi bir pratiktir.
    ctx.setLineDash([2 * dpr, 2 * dpr]);
    ctx.stroke();
    ctx.setLineDash([]); // Çizgi stilini sıfırla
    ctx.restore(); // Eğer bu fonksiyon kendi save/restore'unu yönetiyorsa
}

function drawPlacementMarker(loc) {
    if (!loc) return; ctx.save(); const mS = 8 / zoom; ctx.strokeStyle = 'red'; ctx.lineWidth = 2 / zoom;
    ctx.beginPath(); ctx.moveTo(loc.x - mS, loc.y); ctx.lineTo(loc.x + mS, loc.y);
    ctx.moveTo(loc.x, loc.y - mS); ctx.lineTo(loc.x, loc.y + mS); ctx.stroke(); ctx.restore();
}
function drawMeasurementHighlight(ac) {
    if (!ac) return; ctx.save(); ctx.strokeStyle = 'cyan'; ctx.lineWidth = 2 / zoom;
    const size = 8 / zoom; ctx.strokeRect(ac.x - size / 2, ac.y - size / 2, size, size); ctx.restore();
}

function drawTemporaryMeasurementLine() {
    if (!measurementStartPoint) return;
    const worldMousePos = screenToWorld(lastMouseX, lastMouseY);
    let startX = measurementStartPoint.x; let startY = measurementStartPoint.y;
    if (measurementStartPoint.type === 'aircraft') {
        const ac = aircrafts.find(a => a.id === measurementStartPoint.id);
        if (ac) { startX = ac.x; startY = ac.y; } else { return; }
    }
    ctx.save(); ctx.beginPath(); ctx.moveTo(startX, startY); ctx.lineTo(worldMousePos.x, worldMousePos.y);
    ctx.strokeStyle = 'cyan';
    ctx.lineWidth = (1.5 * 1.5) / zoom; // Kalınlığı 1.5x artırıldı (2.25)
    ctx.setLineDash([4 / zoom, 4 / zoom]); ctx.stroke(); ctx.setLineDash([]); ctx.restore();

    const pointRadius = (3 / zoom) * 1.5; // Nokta yarıçapını da artır
    ctx.save(); ctx.fillStyle = 'cyan'; ctx.beginPath();
    ctx.arc(startX, startY, pointRadius, 0, 2 * Math.PI); ctx.fill(); ctx.restore();
}

function drawMeasurementLine(measurement) {
    ctx.save(); ctx.beginPath();
    ctx.moveTo(measurement.start.x, measurement.start.y);
    ctx.lineTo(measurement.end.x, measurement.end.y);
    ctx.strokeStyle = 'cyan';
    ctx.lineWidth = (1.5 * 1.5) / zoom; // Kalınlığı 1.5x artırıldı (2.25)
    ctx.stroke(); ctx.restore();

    const pointRadius = (2 / zoom) * 1.5; // Nokta yarıçapını da artır
    ctx.save(); ctx.fillStyle = 'cyan';
    ctx.beginPath(); ctx.arc(measurement.start.x, measurement.start.y, pointRadius, 0, 2 * Math.PI); ctx.fill();
    ctx.beginPath(); ctx.arc(measurement.end.x, measurement.end.y, pointRadius, 0, 2 * Math.PI); ctx.fill();
    ctx.restore();
}



function updateAircrafts(deltaTime) {
    const effectiveDeltaTime = deltaTime * gameSpeedMultiplier;
    const aircraftsToRemove = [];
    const airmissPairs = [];

    // YENİ: Bekleyen Spawn'ları Kontrol Et ve Oluştur
    // pendingSpawns dizisinin spawnAtGameTime'a göre sıralı olduğunu varsayıyoruz.
    while (pendingSpawns.length > 0 && elapsedTime >= pendingSpawns[0].spawnAtGameTime) {
        const spawnJob = pendingSpawns.shift(); // En erken spawn olacak görevi al ve listeden çıkar
        scenarioAircraftIdCounter++; // Her yeni uçak için global ID sayacını artır

        const callsign = generateUniqueCallsign(
            spawnJob.data.baseCallsignPrefix,
            spawnJob.data.baseCallsignNumberSeed, // Bu numara her görev için farklı bir temel sağlar
            usedCallsignsInScenario
        );

        let newAircraftBaseData = {};
        let commonData = { // Her iki tip için de ortak olabilecek veya varsayılan değerler
            id: callsign,
            isIntercepting: false, isHandedOffToTower: false, showVector: false,
            labelElement: null, labelX: 0, labelY: 0, labelDragged: false,
            bankAngle: 0, maxBankAngle: 25, commandedTurnDirection: 0, turning: false,
            showInfoPanel: false, draggedLabelDeltaX: 0, draggedLabelDeltaY: 0,
            showTrajectory: false, lastHeadingUpdateTime: 0, initialPosSet: true,
            hasReachedInitialWaypoint: false // Varış uçakları için önemli, kalkışlar için false kalabilir
        };

        if (spawnJob.aircraftType === 'arrival') {
            const d = spawnJob.data;
            newAircraftBaseData = {
                x: d.spawnX, y: d.spawnY,
                heading: Math.round(d.initialHeading),
                targetHeading: Math.round(d.initialHeading),
                speedKTS: defaultAircraftSpeeds[d.type] || 250,
                altitude: d.altitude,
                targetAltitude: d.targetAltitude, // Genellikle başlangıçta mevcut irtifayla aynı
                rateOfDescent: 0, rateOfClimb: 0,
                isTakingOff: false, takeoffRunway: null,
                type: d.type,
                departureTargetFL: null, // Varış için geçerli değil
                flyingToInitialWaypointName: d.flyingToInitialWaypointName,
                finalArrivalTargetX: d.finalArrivalTargetX,
                finalArrivalTargetY: d.finalArrivalTargetY,
                targetWaypoint: null // Varışlarda bu genellikle SID/STAR rotasından sonra gelir, ilk hedef flyingToInitialWaypointName ile yönetiliyor
            };
        } else if (spawnJob.aircraftType === 'departure') {
            const d = spawnJob.data;
            newAircraftBaseData = {
                x: WORLD_ORIGIN_X, y: WORLD_ORIGIN_Y, // Kalkışlar genellikle pist merkezinden (veya başlangıç noktasından)
                heading: d.initialHeading,
                targetHeading: d.initialHeading,
                speedKTS: 160, // Kalkış için tipik başlangıç hızı
                altitude: 0, // Yerden başlar
                targetAltitude: d.targetAltitude,
                rateOfDescent: 0,
                rateOfClimb: d.rateOfClimb,
                isTakingOff: true,
                takeoffRunway: d.takeoffRunway,
                type: d.type,
                departureTargetFL: d.departureTargetFL,
                targetWaypoint: d.targetWaypoint, // Kalkış sonrası ilk waypoint
                flyingToInitialWaypointName: null, // Kalkış için geçerli değil
                finalArrivalTargetX: null, // Kalkış için geçerli değil
                finalArrivalTargetY: null  // Kalkış için geçerli değil
            };
        }

        const finalNewAircraft = { ...commonData, ...newAircraftBaseData };
        aircrafts.push(finalNewAircraft);
        console.log(`${spawnJob.logMarker} -> SPAWNED as ${finalNewAircraft.id}. Oyun Zamanı: ${formatTime(elapsedTime)} (Plan: ${formatTime(spawnJob.spawnAtGameTime)})`);
    }

    // 1. Airmiss Kontrolü
    for (let i = 0; i < aircrafts.length; i++) {
        for (let j = i + 1; j < aircrafts.length; j++) {
            const ac1 = aircrafts[i];
            const ac2 = aircrafts[j];
            const dx = ac2.x - ac1.x;
            const dy = ac2.y - ac1.y;
            const distanceWorldPixels = Math.sqrt(dx * dx + dy * dy);
            const distanceNM = worldPixelsToNm(distanceWorldPixels);
            const verticalSeparation = Math.abs(ac2.altitude - ac1.altitude);
            if (distanceNM < 3 && verticalSeparation < 500) { // Standart ayrım minimumları
                if (!airmissPairs.some(pair => (pair[0] === ac1 && pair[1] === ac2) || (pair[0] === ac2 && pair[1] === ac1))) {
                    airmissPairs.push([ac1, ac2]);
                }
            }
        }
    }
    if (typeof updateAirmissAlert === "function") {
        updateAirmissAlert(airmissPairs);
    }

    // 2. Her Bir Uçağı Güncelle
    aircrafts.forEach((ac, index) => {
        // a. Kuleye devredilmiş ve piste ulaşmış uçakları temizle
        if (ac.isHandedOffToTower) {
            const distToRunwayCenterWorldPixels = Math.sqrt(
                Math.pow(ac.x - WORLD_ORIGIN_X, 2) + Math.pow(ac.y - WORLD_ORIGIN_Y, 2)
            );
            if (worldPixelsToNm(distToRunwayCenterWorldPixels) < 0.3) { // Piste çok yakınsa
                if (!aircraftsToRemove.includes(index)) aircraftsToRemove.push(index);
                return; // Bu uçağın daha fazla güncellenmesine gerek yok
            }
        }

        // b. Operasyonel alan dışına çıkan uçakları temizle
        const distFromWorldOriginNM = worldPixelsToNm(
            Math.sqrt(Math.pow(ac.x - WORLD_ORIGIN_X, 2) + Math.pow(ac.y - WORLD_ORIGIN_Y, 2))
        );
        const operationRadiusNM = 60; // Bu değeri ihtiyacınıza göre ayarlayın
        if (distFromWorldOriginNM > operationRadiusNM) {
            if (!aircraftsToRemove.includes(index)) aircraftsToRemove.push(index);
            console.log(`${ac.id} operasyon alanı (${operationRadiusNM}NM) dışına çıktı, kaldırılıyor.`);
            return; // Bu uçağın daha fazla güncellenmesine gerek yok
        }

        // c. İrtifa Değişikliği
        if (ac.altitude !== ac.targetAltitude) {
            const altDiff = ac.targetAltitude - ac.altitude;
            const direction = Math.sign(altDiff);
            let rate = 0;
            if (direction > 0) { // Tırmanış
                rate = ac.rateOfClimb > 0 ? ac.rateOfClimb : (aircraftPerformanceROC[ac.type] || DEFAULT_CLIMB_RATE);
                if(ac.rateOfClimb === 0 && rate > 0) ac.rateOfClimb = rate; // Eğer rateOfClimb atanmamışsa ata
                ac.rateOfDescent = 0; // Alçalmayı durdur
            } else if (direction < 0) { // Alçalış
                rate = ac.rateOfDescent > 0 ? ac.rateOfDescent : DEFAULT_ROD;
                if(ac.rateOfDescent === 0 && rate > 0) ac.rateOfDescent = rate; // Eğer rateOfDescent atanmamışsa ata
                ac.rateOfClimb = 0; // Tırmanışı durdur
            }

            if (rate !== 0) {
                const changeAmountFeet = direction * rate * (effectiveDeltaTime / 60); // Dakikayı saniyeye çevir
                if (Math.abs(changeAmountFeet) >= Math.abs(altDiff)) {
                    ac.altitude = ac.targetAltitude;
                    ac.rateOfClimb = 0;
                    ac.rateOfDescent = 0;
                } else {
                    ac.altitude += changeAmountFeet;
                }
            }
        } else { // Hedef irtifaya ulaşıldı
            ac.rateOfClimb = 0;
            ac.rateOfDescent = 0;
        }

        // d. Kalkış Mantığı
        if (ac.isTakingOff) {
            const distFromTakeoffPointNM = worldPixelsToNm(Math.sqrt( (ac.x - WORLD_ORIGIN_X) ** 2 + (ac.y - WORLD_ORIGIN_Y) ** 2 ));
            const straightFlightDistanceNM = 12.0; // SID'e veya ilk dönüşe kadar düz uçuş mesafesi
            const targetClimbSpeed = (defaultAircraftSpeeds[ac.type] || 250) - 20; // Tırmanış için tipik hız
            const accelerationRateKTSperSec = 2.5;

            if (ac.speedKTS < targetClimbSpeed) {
                ac.speedKTS += accelerationRateKTSperSec * effectiveDeltaTime;
                if (ac.speedKTS > targetClimbSpeed) ac.speedKTS = targetClimbSpeed;
            }

            // Kalkış sonrası düz uçuş tamamlandıysa veya hedef FL'e çok yaklaşıldıysa SID'e/waypoint'e dön
            if (distFromTakeoffPointNM >= straightFlightDistanceNM || ac.altitude >= (ac.departureTargetFL * 100 - 200) ) {
                ac.isTakingOff = false; // Düz kalkış fazı bitti
                if (ac.targetWaypoint) { // Eğer bir hedef waypoint varsa
                    const wp = waypoints.find(w => w.name === ac.targetWaypoint);
                    if (wp) {
                        const wpAngleRad = toRadians(wp.angle);
                        const wpDistPx = nmToWorldPixels(wp.distanceNM);
                        const waypointWorldX = WORLD_ORIGIN_X + Math.sin(wpAngleRad) * wpDistPx;
                        const waypointWorldY = WORLD_ORIGIN_Y - Math.cos(wpAngleRad) * wpDistPx;
                        ac.targetHeading = Math.round(calculateBearing(ac.x, ac.y, waypointWorldX, waypointWorldY));
                        ac.turning = true;
                        ac.commandedTurnDirection = 0; // Otomatik en kısa yolu bulsun
                        ac.lastHeadingUpdateTime = 0; // Dönüşü hemen başlat
                    } else { ac.turning = false; /* Waypoint bulunamadı, düz devam et */ }
                } else { ac.turning = false; /* Hedef waypoint yok, düz devam et (veya başka bir mantık) */ }
            }
        }

        // e. BAŞLANGIÇ WAYPOINT'İNE VARIŞ VE SONRASI HEDEF BELİRLEME (ARRIVAL İÇİN)
        if (ac.flyingToInitialWaypointName && !ac.hasReachedInitialWaypoint) {
            const targetWaypointData = waypoints.find(wp => wp.name === ac.flyingToInitialWaypointName);
            if (targetWaypointData) {
                const wpAngleRad = toRadians(targetWaypointData.angle);
                const wpDistPx = nmToWorldPixels(targetWaypointData.distanceNM);
                const waypointX = WORLD_ORIGIN_X + Math.sin(wpAngleRad) * wpDistPx;
                const waypointY = WORLD_ORIGIN_Y - Math.cos(wpAngleRad) * wpDistPx;

                const dxToWp = waypointX - ac.x;
                const dyToWp = waypointY - ac.y;
                const distToWaypointNM = worldPixelsToNm(Math.sqrt(dxToWp * dxToWp + dyToWp * dyToWp));

                if (distToWaypointNM < ARRIVAL_AT_WAYPOINT_THRESHOLD_NM) {
                    console.log(`[Arrival] ${ac.id} başlangıç waypoint'i ${ac.flyingToInitialWaypointName}'e ulaştı.`);
                    ac.hasReachedInitialWaypoint = true;
                    ac.flyingToInitialWaypointName = null; // Artık bu waypoint'e gitmiyor

                    if (ac.finalArrivalTargetX !== undefined && ac.finalArrivalTargetY !== undefined) {
                        const headingToFinalTarget = calculateBearing(ac.x, ac.y, ac.finalArrivalTargetX, ac.finalArrivalTargetY);
                        ac.targetHeading = Math.round(headingToFinalTarget);
                        ac.turning = true;
                        ac.commandedTurnDirection = 0;
                        ac.lastHeadingUpdateTime = 0;
                        console.log(`[Arrival] ${ac.id} şimdi son yaklaşma noktasına (${ac.finalArrivalTargetX.toFixed(1)},${ac.finalArrivalTargetY.toFixed(1)}) ${ac.targetHeading}° ile dönüyor.`);
                    } else {
                        // Hedef yoksa radara doğru dönsün veya başka bir mantık
                         ac.targetHeading = Math.round(calculateBearing(ac.x, ac.y, WORLD_ORIGIN_X, WORLD_ORIGIN_Y));
                         ac.turning = true; ac.commandedTurnDirection = 0; ac.lastHeadingUpdateTime = 0;
                    }
                } else {
                    // Hala başlangıç waypoint'ine doğru uçuyor, başını koru (veya sürekli güncelle)
                    // Eğer spawn olurken başı zaten waypoint'e yönelikse, burada tekrar ayarlamaya gerek yok.
                    // Ancak rüzgar vs. gibi faktörler olsaydı sürekli düzeltme gerekebilirdi.
                    // Mevcut durumda, intercept veya kullanıcı müdahalesi yoksa başını koruyacaktır.
                }
            } else {
                console.warn(`[Arrival] ${ac.id} için başlangıç waypoint'i (${ac.flyingToInitialWaypointName}) waypoints dizisinde bulunamadı! Bu faz atlanıyor.`);
                ac.hasReachedInitialWaypoint = true; // Hata durumunda bu fazı atla
                ac.flyingToInitialWaypointName = null;
            }
        }
        
        // f. Intercept Mantığı (LOC'a Yönelme)
        // Bu blok, SADECE uçak başlangıç waypoint görevini tamamlamışsa VEYA (başlangıç waypoint'i yoksa) VE zaten intercept modundaysa çalışır.
        if ((ac.hasReachedInitialWaypoint || (!ac.flyingToInitialWaypointName && !ac.isTakingOff)) && ac.isIntercepting) {
            let intendedCourse = ac.interceptCourse;
            if (intendedCourse !== undefined && intendedCourse !== null) {
                const locRad = toRadians(intendedCourse);
                const lineStartX = WORLD_ORIGIN_X; const lineStartY = WORLD_ORIGIN_Y;
                const lineEndX = WORLD_ORIGIN_X + Math.sin(locRad) * nmToWorldPixels(localizerLengthNM);
                const lineEndY = WORLD_ORIGIN_Y - Math.cos(locRad) * nmToWorldPixels(localizerLengthNM);
                const distToLocCenterlineNM = worldPixelsToNm(pointLineDistance(ac.x, ac.y, lineStartX, lineStartY, lineEndX, lineEndY));
                const ESTABLISH_ANGLE_TOLERANCE_DEG = 2.5; // Establish için açı toleransı
                const currentHeadingDiffToLocCourse = angleDiff(ac.heading, intendedCourse);

                if (distToLocCenterlineNM < ON_LOCALIZER_THRESHOLD_NM && Math.abs(currentHeadingDiffToLocCourse) < ESTABLISH_ANGLE_TOLERANCE_DEG) {
                    console.log(`%c[Intercept] ${ac.id} ESTABLISHED on LOC ${intendedCourse}! Dist: ${distToLocCenterlineNM.toFixed(3)}, HdgDiff: ${currentHeadingDiffToLocCourse.toFixed(1)}`, "color: lightgreen; font-weight: bold;");
                    ac.heading = intendedCourse; ac.targetHeading = intendedCourse; ac.turning = false;
                    ac.isIntercepting = false; ac.commandedTurnDirection = 0; ac.bankAngle = 0; ac.interceptCourse = null;
                    if(typeof updateTopCenterButtonStates === "function") updateTopCenterButtonStates();
                }
                else if (distToLocCenterlineNM < START_ALIGN_ON_LOC_THRESHOLD_NM) { // "Gride değme" mesafesi
                    if (Math.round(ac.heading) !== intendedCourse) {
                        ac.heading = intendedCourse; ac.targetHeading = intendedCourse;
                        ac.turning = false; ac.bankAngle = 0; ac.commandedTurnDirection = 0; ac.lastHeadingUpdateTime = 0;
                    }
                }
                // Eğer LOC'a uzaksa, mevcut intercept başıyla (kullanıcı ayarladıysa) veya düz uçuşla devam eder.
                // Intercept butonuna basıldığında zaten turning=false yapılıyor.
            } else {
                ac.isIntercepting = false; ac.interceptCourse = null; // Hatalı durumu düzelt
            }
        }


        // g. Kademeli Dönüş Mantığı ve Bank Açısı (Eski Kod Mantığına Uyarlanmış - Kesikli Dönüş)
        if (ac.turning) {
            const TURN_DEGREES_PER_STEP = 3.0; // Her adımda kaç derece dönüleceği
            
            // Adım aralığı, oyun hızına göre ayarlanır.
            // gameSpeedMultiplier = 1x ise, updateIntervalMs = 1000ms (1 saniye) olur.
            // gameSpeedMultiplier = 2x ise, updateIntervalMs = 500ms (0.5 saniye) olur.
            // Bu, oyun zamanına göre yaklaşık saniyede bir adım atılmasını hedefler,
            // ancak adımlar GERÇEK zaman aralıklarıyla tetiklenir.
            const updateIntervalMs = 1000 / gameSpeedMultiplier;

            if (ac.lastHeadingUpdateTime === undefined) { // İlk kez çalışıyorsa veya sıfırlanmışsa
                ac.lastHeadingUpdateTime = 0; // performance.now() ile karşılaştırılacağı için 0 mantıklı bir başlangıç.
            }
            const currentTimeMs = performance.now();

            if (currentTimeMs - ac.lastHeadingUpdateTime >= updateIntervalMs) {
                const diffToTarget = angleDiff(ac.targetHeading, ac.heading);

                if (Math.abs(diffToTarget) < 0.1) { // Hedefe çok çok yakınsa, dönüşü bitir
                    ac.heading = ac.targetHeading;
                    ac.turning = false;
                    ac.commandedTurnDirection = 0;
                } else {
                    let turnDirection = ac.commandedTurnDirection;
                    if (turnDirection === 0) { // Komutlu dönüş yönü yoksa en kısa yolu bul
                        turnDirection = Math.sign(diffToTarget);
                    }

                    let turnAmountThisStep = turnDirection * TURN_DEGREES_PER_STEP;

                    // Hedefi geçmemesini sağla
                    if (Math.abs(turnAmountThisStep) >= Math.abs(diffToTarget)) {
                        ac.heading = ac.targetHeading;
                        ac.turning = false;
                        ac.commandedTurnDirection = 0;
                    } else {
                        ac.heading = (ac.heading + turnAmountThisStep + 360) % 360;
                    }
                }
                ac.lastHeadingUpdateTime = currentTimeMs; // Son "adımlı" güncelleme zamanını kaydet
            }

            // Bank açısı hesaplaması (bu kısım akıcı kalabilir veya isteğe göre bu da adımlı yapılabilir)
            let turnDirectionForBank = ac.commandedTurnDirection;
            if (turnDirectionForBank === 0 && ac.turning) { // Sadece hala bir hedefe doğru aktif olarak dönüyorsa
                 const diffForBank = angleDiff(ac.targetHeading, ac.heading);
                 turnDirectionForBank = (Math.abs(diffForBank) > 0.1) ? Math.sign(diffForBank) : 0;
            } else if (!ac.turning) { // Dönüş bittiyse bank için yön 0 olmalı (düzeltmek için)
                turnDirectionForBank = 0;
            }

            let requiredBank = Math.min(ac.maxBankAngle, (ac.speedKTS / 10) + 7);
            const targetBankAngle = turnDirectionForBank * requiredBank;

            // Bank açısının yumuşak geçişi (effectiveDeltaTime, oyun hızını içerir)
            ac.bankAngle += (targetBankAngle - ac.bankAngle) * (effectiveDeltaTime * 5); // 5, geçiş hızını ayarlayan bir faktör
            if (Math.abs(ac.bankAngle - targetBankAngle) < 0.5) {
                ac.bankAngle = targetBankAngle;
            }
            if (!ac.turning && Math.abs(ac.bankAngle) < 0.1) { // Dönüş bittiğinde ve bank çok küçükse sıfırla
                ac.bankAngle = 0;
            }

        } else { // ac.turning === false (Uçak dönmüyorsa)
            ac.lastHeadingUpdateTime = 0; // Dönüş bitince bir sonraki dönüş için hazırla (veya undefined/null)

            // Kanatları düzeltme (effectiveDeltaTime ile yumuşak geçiş)
            ac.bankAngle += (0 - ac.bankAngle) * (effectiveDeltaTime * 5);
            if (Math.abs(ac.bankAngle) < 0.1) {
                ac.bankAngle = 0;
            }
        }

        // h. Pozisyon Güncelleme (Bu kısım aynı kalır, uçağın hareketi oyun hızına göre akıcı olmalı)
        const speedNMPerSecond = ac.speedKTS / 3600;
        const distanceNM = speedNMPerSecond * effectiveDeltaTime; // Pozisyon güncellemesi oyun hızına bağlı olmalı
        const worldDistancePixels = nmToWorldPixels(distanceNM);
        const rad = toRadians(ac.heading); // Güncellenmiş (veya güncellenmemiş) heading kullanılır
        ac.x += Math.sin(rad) * worldDistancePixels;
        ac.y -= Math.cos(rad) * worldDistancePixels;
    }); // aircrafts.forEach sonu


    // 3. Kaldırılacak Uçakları Temizle
    if (aircraftsToRemove.length > 0) {
        for (let i = aircraftsToRemove.length - 1; i >= 0; i--) {
            const indexToRemove = aircraftsToRemove[i];
            const removedAircraft = aircrafts[indexToRemove];
            if (removedAircraft) {
                if (removedAircraft.labelElement) removedAircraft.labelElement.remove();
                // Eğer `usedCallsignsInScenario` setini aktif tutuyorsanız, buradan da silinebilir.
                // usedCallsignsInScenario.delete(removedAircraft.id);
                if (typeof selectedAircraft !== 'undefined' && selectedAircraft && selectedAircraft.id === removedAircraft.id) {
                    selectedAircraft = null;
                    if (typeof popup !== 'undefined' && popup) popup.style.display = 'none';
                }
                aircrafts.splice(indexToRemove, 1);
            }
        }
        if (typeof updateTopCenterButtonStates === "function") updateTopCenterButtonStates();
    }
}



function updateAirmissAlert(airmissPairs) {
    const airmissAlert = document.getElementById('airmissAlert');
    const airmissCallsigns = document.getElementById('airmissCallsigns');
    if (airmissPairs.length > 0) {
        const [ac1, ac2] = airmissPairs[0];
        airmissCallsigns.textContent = `${ac1.id} - ${ac2.id}`;
        airmissAlert.style.display = 'block';
    } else {
        airmissAlert.style.display = 'none';
        airmissCallsigns.textContent = '';
    }
}

function showRunwaySelection() {
    if (runwaySelectionModal) runwaySelectionModal.style.display = 'flex';
}
function hideRunwaySelection() {
    if (runwaySelectionModal) runwaySelectionModal.style.display = 'none';
}







// --- Global veya Erişilebilir Kapsamda Olması Gerekenler ---
// const WORLD_ORIGIN_X = 0;
// const WORLD_ORIGIN_Y = 0;
// let aircrafts = []; // Uçakları tutan dizi
// const waypoints = [ /* ... waypoint tanımlamalarınız ... */ ];
// const INTERCEPT_TARGET_COURSE_033 = 33; // Örnek değer
// const INTERCEPT_TARGET_COURSE_21L = 213; // Örnek değer
// let scenarioAircraftIdCounter = 0;
// const callsignPrefixes = ['THY', 'PGT', 'SXS', /* ... */];
// const aircraftTypes = ['A320', 'B737', /* ... */];
// const defaultAircraftSpeeds = { 'A320': 280, 'B737': 300, /* ... */ };
// const aircraftPerformanceROC = { 'A320': 2500, 'B737': 2500, /* ... */ };
// const DEFAULT_CLIMB_RATE = 2000; // Varsayılan tırmanma oranı
// let elapsedTime;       // Saniye cinsinden geçen oyun zamanı
// let timerInterval = null; // Oyun zamanlayıcısı için interval ID
// let activeScenarioTimeouts = []; // Senaryo uçak spawn zamanlayıcılarını tutar
// let gameSpeedMultiplier = 1.0; // Oyun hızı çarpanı
// let speedFactor = 1.0; // gameSpeedMultiplier ile senkronize olmalı
// let isPaused = false;
// let lastTime;          // performance.now() için
// let animationFrameId = null;
// let selectedAircraft = null; // Seçili uçak
// const popup = document.getElementById('popup'); // Popup DOM elemanı

// Slider ve butonlar (DOM'dan alınmış olmalı)
// const speedSlider = document.getElementById('speedSlider');
// const speedMultipliers = [0.25, 0.5, 0.75, 1, 1.25, 1.5, 2, 3, 5, 10];
// const playPauseButton = document.getElementById('playPauseButton');

// Yardımcı fonksiyonlar (tanımlı olmalı)
// function nmToWorldPixels(nm) { /* ... */ }
// function toRadians(degrees) { /* ... */ }
// function calculateBearing(x1, y1, x2, y2) { /* ... */ }
// function formatTime(totalSeconds) { /* ... */ }
// function formatFlightLevel(altitude) { /* ... */ }
// function hideRunwaySelection() { /* ... */ }
// function startGameTimer() { /* ... */ }
// function updateTopCenterButtonStates() { /* ... */ }
// function gameLoop(currentTime) { /* ... */ }


function initializeScenarioGeneration(activeRunway) {
    // 1. Oyun Hızını Ayarla (Bu kısım aynı kalabilir, ancak artık setTimeout için doğrudan kullanılmayacak)
    if (typeof speedSlider !== 'undefined' && speedSlider && typeof speedMultipliers !== 'undefined' && speedMultipliers.length > 0) {
        gameSpeedMultiplier = speedMultipliers[parseInt(speedSlider.value)];
        speedFactor = gameSpeedMultiplier;
    } else {
        gameSpeedMultiplier = 1.0;
        speedFactor = 1.0;
        console.warn("Hız ayar elemanları (speedSlider veya speedMultipliers) bulunamadı. Varsayılan hız (1x) kullanılıyor.");
    }

    // 2. Gerekirse Pist Seçim Modalını Gizle
    if (typeof hideRunwaySelection === "function") {
        hideRunwaySelection();
    }

    // 3. Oyun Zamanlayıcısını Sıfırla ve Başlat
    elapsedTime = SCENARIO_START_ELAPSED_TIME; // Sabit başlangıç zamanını kullan
    if (timerInterval) {
        clearInterval(timerInterval);
        timerInterval = null;
    }
    if (isPaused) {
        isPaused = false;
        if (playPauseButton) {
            playPauseButton.textContent = 'Durdur';
            playPauseButton.classList.remove('paused');
        }
    }
    if (typeof startGameTimer === "function") {
        startGameTimer();
    }

    // 4. Önceki Senaryo Zamanlayıcılarını ve Bekleyen Spawn'ları Temizle
    // activeScenarioTimeouts.forEach(timeoutId => clearTimeout(timeoutId)); // ARTIK GEREKLİ DEĞİL
    // activeScenarioTimeouts = []; // ARTIK GEREKLİ DEĞİL
    pendingSpawns = []; // Bekleyen spawn listesini temizle

    console.log(`YENİ SENARYO BAŞLADI - Aktif Pist: ${activeRunway}, Zaman: ${formatTime(elapsedTime)}, Oyun Hızı: ${gameSpeedMultiplier}x`);

    // 5. Mevcut Uçakları ve Etiketlerini Temizle
    aircrafts.forEach(ac => {
        if (ac.labelElement) ac.labelElement.remove();
    });
    aircrafts.length = 0;
    selectedAircraft = null;
    if (typeof updateTopCenterButtonStates === "function") {
        updateTopCenterButtonStates();
    }
    if (popup) popup.style.display = 'none';
    scenarioAircraftIdCounter = 0;
    usedCallsignsInScenario.clear();


    // 6. Oyun Döngüsünü Gerekirse Yeniden Başlat (Bu kısım aynı kalabilir)
    if (!isPaused) {
        lastTime = performance.now();
        if (animationFrameId) {
            cancelAnimationFrame(animationFrameId);
        }
        if (typeof gameLoop === "function") {
            animationFrameId = requestAnimationFrame(gameLoop);
        }
    }

    // 7. İniş Uçakları İçin SON HEDEF NOKTA (Bu kısım aynı kalabilir)
    const localizerCourseForFinalArrival = activeRunway === '03R' ? INTERCEPT_TARGET_COURSE_033 : INTERCEPT_TARGET_COURSE_21L;
    let finalTargetPointAngleDeg = (localizerCourseForFinalArrival + 180) % 360;
    const finalTargetPointAngleRad = toRadians(finalTargetPointAngleDeg);
    const finalTargetPointDistanceNM = 13;
    const globalFinalArrivalTargetX = WORLD_ORIGIN_X + Math.sin(finalTargetPointAngleRad) * nmToWorldPixels(finalTargetPointDistanceNM);
    const globalFinalArrivalTargetY = WORLD_ORIGIN_Y - Math.cos(finalTargetPointAngleRad) * nmToWorldPixels(finalTargetPointDistanceNM);

    // 8. İniş Uçaklarını Üret (setTimeout yerine pendingSpawns'a ekleme)
    const waypointMEAs = { /* ... (MEA değerleri aynı) ... */ };
    const SPAWN_DISTANCE_FROM_WAYPOINT_NM = 5;
    const numArrivals = 5;
    const arrivalSpawnWindowSeconds = 60 * 5;

    let availableWaypointsForScenario = [...waypoints].sort(() => 0.5 - Math.random());
    let arrivalWaypointsSelection = [];
    if (availableWaypointsForScenario.length > 0) {
        for (let k = 0; k < numArrivals; k++) {
            arrivalWaypointsSelection.push(availableWaypointsForScenario[k % availableWaypointsForScenario.length]);
        }
        arrivalWaypointsSelection.sort(() => 0.5 - Math.random());
    } else {
        console.warn("Senaryo için uygun waypoint bulunamadı. İniş trafiği üretilemiyor.");
    }

    let firstFLForWaypoint = {};

    for (let i = 0; i < arrivalWaypointsSelection.length; i++) {
        const spawnTimeGameSecondsOffset = (Math.random() * arrivalSpawnWindowSeconds); // Senaryo başlangıcına göre ofset
        const waypoint = arrivalWaypointsSelection[i];

        // Uçak verilerini hesapla (spawnX, spawnY, aircraftInitialHeading, altitudeFeetArr, acTypeArr vb.)
        // Bu kısımlar önceki kodunuzla aynı kalabilir.
        const waypointActualX = WORLD_ORIGIN_X + Math.sin(toRadians(waypoint.angle)) * nmToWorldPixels(waypoint.distanceNM);
        const waypointActualY = WORLD_ORIGIN_Y - Math.cos(toRadians(waypoint.angle)) * nmToWorldPixels(waypoint.distanceNM);
        let aircraftInitialHeading = waypoint.arrivalTrack !== undefined ? waypoint.arrivalTrack : (waypoint.angle + 180) % 360;
        const spawnAngleFromWaypointRad = toRadians((aircraftInitialHeading + 180) % 360);
        const spawnOffsetX = Math.sin(spawnAngleFromWaypointRad) * nmToWorldPixels(SPAWN_DISTANCE_FROM_WAYPOINT_NM);
        const spawnOffsetY = -Math.cos(spawnAngleFromWaypointRad) * nmToWorldPixels(SPAWN_DISTANCE_FROM_WAYPOINT_NM);
        const spawnX = waypointActualX + spawnOffsetX;
        const spawnY = waypointActualY + spawnOffsetY;
        const acTypeArr = aircraftTypes[Math.floor(Math.random() * aircraftTypes.length)];
        // İrtifa hesaplaması... (önceki gibi)
        const minRandomFL = 130, maxRandomFL = 240, flStep = 10;
        const numberOfSteps = Math.floor((maxRandomFL - minRandomFL) / flStep) + 1;
        let randomFLIndex = Math.floor(Math.random() * numberOfSteps);
        let altitudeFLArr = minRandomFL + (randomFLIndex * flStep);
        let altitudeFeetArr = altitudeFLArr * 100;
        const meaForWaypoint = waypointMEAs[waypoint.name];
        if (meaForWaypoint && altitudeFeetArr < meaForWaypoint) {
            altitudeFeetArr = meaForWaypoint; altitudeFLArr = meaForWaypoint / 100;
        }
        // ... (firstFLForWaypoint mantığı) ...


        // Uçak spawn görevini pendingSpawns'a ekle
        const aircraftSpawnData = {
            // Çağrı adı burada üretilip eklenebilir veya spawn anında da üretilebilir.
            // Şimdilik temel bilgileri saklayalım, spawn anında üretiriz.
            baseCallsignPrefix: callsignPrefixes[Math.floor(Math.random() * callsignPrefixes.length)],
            baseCallsignNumberSeed: 100 + (scenarioAircraftIdCounter + 1) * 10 + i, // Benzersizlik için bir tohum
            spawnX: spawnX, spawnY: spawnY,
            initialHeading: aircraftInitialHeading,
            type: acTypeArr,
            altitude: altitudeFeetArr,
            targetAltitude: altitudeFeetArr, // Başlangıçta aynı
            flyingToInitialWaypointName: waypoint.name,
            finalArrivalTargetX: globalFinalArrivalTargetX,
            finalArrivalTargetY: globalFinalArrivalTargetY
            // Diğer gerekli olabilecek veriler (hız, tırmanma/alçalma oranı vb. varsayılan olabilir veya burada belirlenebilir)
        };

        pendingSpawns.push({
            spawnAtGameTime: SCENARIO_START_ELAPSED_TIME + spawnTimeGameSecondsOffset,
            aircraftType: 'arrival',
            data: aircraftSpawnData,
            logMarker: `ARRIVAL for ${waypoint.name} @FL${altitudeFLArr}` // Konsol logu için
        });
    }

    // 9. Kalkış Uçaklarını Üret (setTimeout yerine pendingSpawns'a ekleme)
    const departureSpawnTimesGameSecondsOffsets = [Math.random() * 30, 100 + (Math.random() * 50)];
    const departureRunwayCourse = activeRunway === '03R' ? INTERCEPT_TARGET_COURSE_033 : INTERCEPT_TARGET_COURSE_21L;
    const westernBoundWaypoints = ['HAY', 'PETAR', 'SALGO', 'ASTAL'];
    let waypointsForDeparture = [...waypoints].sort(() => 0.5 - Math.random());

    for (let i = 0; i < departureSpawnTimesGameSecondsOffsets.length; i++) {
        const takeoffTimeGameSecondsOffset = departureSpawnTimesGameSecondsOffsets[i];
        const acTypeDep = aircraftTypes[Math.floor(Math.random() * aircraftTypes.length)];
        let takeoffTargetWaypointName = waypointsForDeparture.length > 0 ? waypointsForDeparture[i % waypointsForDeparture.length].name : null;
        
        let departureTargetFL;
        // ... (departureTargetFL hesaplama mantığı önceki gibi) ...
        const departureMinFL = 180; const departureMaxFL = 280;
        const isWesternBound = takeoffTargetWaypointName && westernBoundWaypoints.includes(takeoffTargetWaypointName);
        let possibleFLs = [];
        for (let fl = departureMinFL; fl <= departureMaxFL; fl += 10) {
            if (isWesternBound && fl % 20 === 0) possibleFLs.push(fl);
            else if (!isWesternBound && fl % 20 !== 0) possibleFLs.push(fl);
        }
        departureTargetFL = possibleFLs.length > 0 ? possibleFLs[Math.floor(Math.random() * possibleFLs.length)] : Math.floor(Math.random() * ((departureMaxFL / 10) - (departureMinFL / 10) + 1)) * 10 + departureMinFL;
        
        const climbRate = aircraftPerformanceROC[acTypeDep] || DEFAULT_CLIMB_RATE;

        const departureSpawnData = {
            baseCallsignPrefix: callsignPrefixes[Math.floor(Math.random() * callsignPrefixes.length)],
            baseCallsignNumberSeed: 500 + (scenarioAircraftIdCounter + 1) * 10 + i,
            type: acTypeDep,
            initialHeading: departureRunwayCourse,
            targetAltitude: departureTargetFL * 100,
            rateOfClimb: climbRate,
            takeoffRunway: activeRunway,
            departureTargetFL: departureTargetFL,
            targetWaypoint: takeoffTargetWaypointName
        };

        pendingSpawns.push({
            spawnAtGameTime: SCENARIO_START_ELAPSED_TIME + takeoffTimeGameSecondsOffset,
            aircraftType: 'departure',
            data: departureSpawnData,
            logMarker: `DEPARTURE from ${activeRunway} to ${takeoffTargetWaypointName || 'SID'} @FL${departureTargetFL}`
        });
    }
    // Spawn görevlerini zamana göre sıralamak, performansı biraz artırabilir (her döngüde tüm listeyi taramak yerine baştan kontrol etmek için)
    pendingSpawns.sort((a, b) => a.spawnAtGameTime - b.spawnAtGameTime);

    console.log("Senaryo üretimi tamamlandı, " + pendingSpawns.length + " uçak spawn için bekliyor.");
}














function updateMeasurementData() {
    measurements.forEach(m => {
        let needsCoordUpdate = false; let needsAltUpdate = false;
        if (m.start.type === 'aircraft') {
            const ac = aircrafts.find(a => a.id === m.start.id);
            if (ac && (m.start.x !== ac.x || m.start.y !== ac.y)) { m.start.x = ac.x; m.start.y = ac.y; needsCoordUpdate = true; }
            else if (!ac) { if(m.labelElement) m.labelElement.remove(); measurements = measurements.filter(meas => meas.id !== m.id); return; }
        }
        if (m.end.type === 'aircraft') {
            const ac = aircrafts.find(a => a.id === m.end.id);
            if (ac && (m.end.x !== ac.x || m.end.y !== ac.y)) { m.end.x = ac.x; m.end.y = ac.y; needsCoordUpdate = true; }
            else if (!ac) { if(m.labelElement) m.labelElement.remove(); measurements = measurements.filter(meas => meas.id !== m.id); return; }
        }
        if (m.start.type === 'runwayCenter' && m.end.type === 'aircraft') {
            const endAc = aircrafts.find(a => a.id === m.end.id);
            if (!endAc) { if(m.labelElement) m.labelElement.remove(); measurements = measurements.filter(meas => meas.id !== m.id); return; }
        } else if (m.start.type === 'aircraft' && m.end.type === 'runwayCenter') {
            const startAc = aircrafts.find(a => a.id === m.start.id);
            if (!startAc) { if(m.labelElement) m.labelElement.remove(); measurements = measurements.filter(meas => meas.id !== m.id); return; }
        }

        const dx = m.end.x - m.start.x; const dy = m.end.y - m.start.y;
        const distanceWorldPixels = Math.sqrt(dx * dx + dy * dy); const newDistanceNM = worldPixelsToNm(distanceWorldPixels);
        const newBearing = calculateBearing(m.start.x, m.start.y, m.end.x, m.end.y); const newReciprocalBearing = (newBearing + 180) % 360;
        let newEstimatedAltitude = null; let newRelativeBearing1 = null; let newRelativeBearing2 = null;
        if (m.start.type === 'aircraft') {
            const startAircraft = aircrafts.find(a => a.id === m.start.id);
            if (startAircraft) {
                if (m.end.type === 'point' || m.end.type === 'runwayCenter') {
                    if (startAircraft.speedKTS > 0) {
                        const timeHours = newDistanceNM / startAircraft.speedKTS; const timeMinutes = timeHours * 60;
                        let verticalDirection = 0; if (startAircraft.altitude !== startAircraft.targetAltitude) { verticalDirection = Math.sign(startAircraft.targetAltitude - startAircraft.altitude); }
                        let effectiveRodMagnitude = 0;
                        if (startAircraft.rateOfDescent !== 0 && verticalDirection < 0) { effectiveRodMagnitude = Math.abs(startAircraft.rateOfDescent);
                        } else if (startAircraft.rateOfClimb !== 0 && verticalDirection > 0) { effectiveRodMagnitude = Math.abs(startAircraft.rateOfClimb);
                        } else if (verticalDirection !== 0) { effectiveRodMagnitude = verticalDirection > 0 ? DEFAULT_CLIMB_RATE : DEFAULT_ROD; }
                        const altitudeChange = verticalDirection * effectiveRodMagnitude * timeMinutes;
                        newEstimatedAltitude = startAircraft.altitude + altitudeChange; newEstimatedAltitude = Math.max(0, newEstimatedAltitude);
                    }
                } else if (m.end.type === 'aircraft') {
                    const endAircraft = aircrafts.find(a => a.id === m.end.id);
                    if (endAircraft) { newRelativeBearing1 = angleDiff(newBearing, startAircraft.heading); newRelativeBearing2 = angleDiff(newReciprocalBearing, endAircraft.heading); }
                }
            }
        } else if (m.start.type === 'runwayCenter' && m.end.type === 'aircraft') {
            const endAircraft = aircrafts.find(a => a.id === m.end.id);
            if(endAircraft){ newRelativeBearing2 = angleDiff(newReciprocalBearing, endAircraft.heading); }
        }

        if (m.distanceNM !== newDistanceNM || m.estimatedAltitude !== newEstimatedAltitude || m.bearing !== newBearing || m.relativeBearing1 !== newRelativeBearing1 || m.relativeBearing2 !== newRelativeBearing2) {
            m.distanceNM = newDistanceNM; m.estimatedAltitude = newEstimatedAltitude; m.bearing = newBearing; m.reciprocalBearing = newReciprocalBearing; m.relativeBearing1 = newRelativeBearing1; m.relativeBearing2 = newRelativeBearing2;
            needsAltUpdate = true;
        }
        if ((needsCoordUpdate || needsAltUpdate) && m.labelElement) {
            let labelContent = "";
            if (m.start.type === 'aircraft' && m.end.type === 'aircraft') {
                const relativeBearingText = `<span class="measurement-relative-bearing">${formatRelativeBearing(m.relativeBearing1)} / ${formatRelativeBearing(m.relativeBearing2)}</span>`;
                const distAltText = `<span class="measurement-dist-alt">${m.distanceNM.toFixed(1)} NM</span>`;
                labelContent = relativeBearingText + distAltText;
            } else if ((m.start.type === 'aircraft' && m.end.type === 'runwayCenter') || (m.start.type === 'runwayCenter' && m.end.type === 'aircraft')) {
                const bearingText = `<span class="measurement-bearing">${formatBearing(m.bearing)} / ${formatBearing(m.reciprocalBearing)}</span>`;
                let distAltText = `<span class="measurement-dist-alt">${m.distanceNM.toFixed(1)} NM`;
                let extraInfo = "";
                if (m.start.type === 'aircraft' && m.estimatedAltitude !== null && m.estimatedAltitude !== undefined) {
                    distAltText += ` / ~${formatFlightLevel(m.estimatedAltitude)} (to RWY)`;
                } else if (m.start.type === 'runwayCenter' && m.end.type === 'aircraft') {
                    const acEnd = aircrafts.find(a => a.id === m.end.id);
                    if (acEnd) {
                        distAltText += ` / ${formatFlightLevel(acEnd.altitude)}`;
                        if(m.relativeBearing2 !== null) { extraInfo = `<span class="measurement-relative-bearing">AC to RWY: ${formatRelativeBearing(m.relativeBearing2)}</span>`; }
                    }
                }
                distAltText += `</span>`; labelContent = bearingText + extraInfo + distAltText;
            } else {
                const bearingText = `<span class="measurement-bearing">${formatBearing(m.bearing)} / ${formatBearing(m.reciprocalBearing)}</span>`;
                let distAltText = `<span class="measurement-dist-alt">${m.distanceNM.toFixed(1)} NM`;
                if (m.estimatedAltitude !== null && m.estimatedAltitude !== undefined) { distAltText += ` / ~${formatFlightLevel(m.estimatedAltitude)}`; }
                distAltText += `</span>`; labelContent = bearingText + distAltText;
            }
            m.labelElement.innerHTML = labelContent;
        }
    });
}

function startLabelDrag(event, item, type) {
    if (event.button !== 1) return; event.preventDefault();
    isDraggingLabel = true; draggedLabelItem = item; draggedLabelType = type;
    const labelRect = item.labelElement.getBoundingClientRect();
    dragOffsetX = event.clientX - labelRect.left; dragOffsetY = event.clientY - labelRect.top;
    item.labelElement.classList.add('dragging');
}

// --- Fonksiyon Tanımlamaları (Güncellenmiş ve Tam Haller) ---



function updateAircraftLabelPositionDOM(ac) {
    // Fonksiyonun her uçak için çağrılıp çağrılmadığını kontrol etmek için log (gerekirse açın)
    // console.log(`[UALPDOM Entry Point] Called for aircraft: ${ac.id}, isTakingOff: ${ac.isTakingOff}, takeoffRunway: ${ac.takeoffRunway}, showTrajectory: ${ac.showTrajectory}`);

    const currentFL = formatFlightLevel(ac.altitude);
    const targetFL = formatFlightLevel(ac.targetAltitude);

    let formattedDistanceToCenterValue = "";
    let distanceNM_raw = 0;
    if (typeof WORLD_ORIGIN_X === 'number' && typeof WORLD_ORIGIN_Y === 'number' &&
        typeof ac.x === 'number' && typeof ac.y === 'number') {
        const dx = ac.x - WORLD_ORIGIN_X;
        const dy = ac.y - WORLD_ORIGIN_Y;
        const distanceWorldPixels = Math.sqrt(dx * dx + dy * dy);
        distanceNM_raw = worldPixelsToNm(distanceWorldPixels);
        formattedDistanceToCenterValue = `${Math.round(distanceNM_raw).toString().padStart(3, '0')}`;
        
        // Kalkış yapan ve ilk 15 mil içinde olan uçaklar için mesafe logu (gerekirse açın)
        // if (ac.takeoffRunway && distanceNM_raw < 15 && distanceNM_raw > 0.05) {
        //     console.log(`[UALPDOM - Mesafe] AC: ${ac.id}, X: ${ac.x.toFixed(1)}, Y: ${ac.y.toFixed(1)}, MesafeNM: ${distanceNM_raw.toFixed(1)}, Gösterilen: d${formattedDistanceToCenterValue}`);
        // }
    }

    if (!ac.labelElement) {
        // console.log(`[UALPDOM - CREATE START] Creating label for ${ac.id}.`);
        ac.labelElement = document.createElement('div');
        ac.labelElement.className = 'dynamic-label aircraft-label';
        ac.labelElement.dataset.aircraftId = ac.id;

        // innerHTML ile temel yapıyı oluştur. LTXX span'ı daha sonra yönetilecek.
        ac.labelElement.innerHTML = `
            <div class="label-line label-id"></div>
            <div class="aircraft-info-panel" style="display: none;">
                <div>Tip: <span class="info-type"></span><span class="info-dep-waypoint" style="margin-left: 8px; font-weight: bold;"></span></div>
                <div class="info-target-fl-line" style="display: none;">Hedef FL: <span class="info-target-fl"></span></div>
            </div>
            <div class="label-line altitude-line">
                <span class="current-altitude"></span>
                <span class="target-altitude clickable-line" data-field="altitude"></span>
                <span class="clickable-line" data-field="rateOfDescent"></span>
            </div>
            <div class="label-line clickable-line" data-field="heading">
                <span class="heading-text"></span><span class="distance-to-center" style="margin-left:1px;"></span>
               
            </div>
            <div class="label-line clickable-line" data-field="speedKTS"></div>
        `;
        
        document.body.appendChild(ac.labelElement);
        // console.log(`[UALPDOM - CREATE END] Label for ${ac.id} created and appended. Attaching listener...`);
        
        // --- CLICK EVENT LISTENER ---
        if (ac.labelElement && ac.labelElement.parentNode) {
            ac.labelElement.addEventListener('click', (e) => {
                // console.log(`[UALPDOM - Click Event] Label for ${ac.id} clicked. Event target:`, e.target);
                const clickableTarget = e.target.closest('.trajectory-toggle, .clickable-line[data-field], .label-id');
                // console.log(`[UALPDOM - Click Event] Closest clickable target for ${ac.id}:`, clickableTarget);

                if (!clickableTarget) return;

                if (clickableTarget.classList.contains('trajectory-toggle')) {
                    // console.log(`[UALPDOM - Click Event] 'trajectory-toggle' (LTXX) clicked for ${ac.id}!`);
                    e.stopPropagation(); 
                    const aircraftId = clickableTarget.dataset.aircraftId;
                    const targetAircraft = aircrafts.find(a => a.id === aircraftId);
                    if (targetAircraft && typeof toggleTrajectoryLine === "function") {
                        toggleTrajectoryLine(targetAircraft);
                    }
                    return; 
                }
                
                if (clickableTarget.classList.contains('clickable-line') || clickableTarget.classList.contains('label-id')) {
                    e.stopPropagation(); 
                    selectedAircraft = aircrafts.find(a => a.id === ac.id); 
                    if (selectedAircraft) {
                        document.querySelectorAll('.aircraft-label.selected').forEach(el => el.classList.remove('selected'));
                        if (ac.labelElement) ac.labelElement.classList.add('selected');
                        if (typeof updateTopCenterButtonStates === "function") updateTopCenterButtonStates();
                        if (clickableTarget.classList.contains('label-id')) {
                            selectedAircraft.showInfoPanel = !selectedAircraft.showInfoPanel;
                            updateAircraftLabelPositionDOM(selectedAircraft); 
                        } else { 
                            const field = clickableTarget.dataset.field;
                            if (field && typeof showPopupForField === "function") {
                                if (field === 'altitude' && !clickableTarget.classList.contains('target-altitude')) return;
                                showPopupForField(e.clientX, e.clientY, field);
                            }
                        }
                    }
                }
            });
            // console.log(`[UALPDOM - LISTENER ADDED] Click listener successfully added for ${ac.id}`);
        } else {
            // console.error(`[UALPDOM - LISTENER FAIL] Cannot add click listener for ${ac.id}.`);
        }
        ac.labelElement.addEventListener('mousedown', (e) => {
            if (typeof startLabelDrag === "function") startLabelDrag(e, ac, 'aircraft');
        });
    }

    // --- ETİKET İÇERİĞİNİ HER ÇAĞRIDA GÜNCELLE ---
    if (ac.labelElement) {
        ac.labelElement.querySelector('.label-id').textContent = ac.id;

        const headingElement = ac.labelElement.querySelector('[data-field="heading"]');
        const headingTextSpan = headingElement.querySelector('.heading-text'); // Bu span'ı innerHTML'de tanımladık
        const distanceTextSpan = headingElement.querySelector('.distance-to-center'); // Bu span'ı da innerHTML'de tanımladık
        
        if(headingTextSpan) headingTextSpan.textContent = `${Math.round(ac.heading)}°`;
        if(distanceTextSpan) distanceTextSpan.textContent = `d${formattedDistanceToCenterValue}`;

        let ltxxSpan = headingElement.querySelector('.trajectory-toggle');

        // LTXX span'ını yönet: Sadece takeoffRunway tanımlıysa (yani bir kalkış uçağıysa) var olmalı.
        if (ac.takeoffRunway) {
            if (!ltxxSpan) { // Yoksa oluştur ve doğru yere ekle
                // console.log(`[UALPDOM - UpdateContent] LTXX span missing for ${ac.id}, CREATING.`);
                ltxxSpan = document.createElement('span');
                ltxxSpan.className = 'trajectory-toggle';
                ltxxSpan.dataset.aircraftId = ac.id;
                ltxxSpan.textContent = 'LTXX';
                // LTXX'i distanceTextSpan'dan sonra ekle (varsa), yoksa headingElement'in sonuna
                if (distanceTextSpan) {
                    distanceTextSpan.insertAdjacentElement('afterend', ltxxSpan);
                } else {
                    headingElement.appendChild(ltxxSpan); 
                }
            }
            // Her zaman stilini güncelle
            const fontWeightForLtxx = ac.showTrajectory ? 'bold' : 'normal'; // Trajektör aktifken kalın
            const colorForLtxx = 'black'; // **LTXX RENGİ HER ZAMAN SİYAH**
            ltxxSpan.style.cssText = `cursor: pointer; color: ${colorForLtxx}; margin-left: 5px; text-decoration: none; font-weight: ${fontWeightForLtxx};`;
        } else if (ltxxSpan) { // takeoffRunway yok ama span varsa (önceden kalmışsa), kaldır
            // console.log(`[UALPDOM - UpdateContent] Removing LTXX span for ${ac.id} as takeoffRunway is not defined.`);
            ltxxSpan.remove();
        }

        ac.labelElement.querySelector('[data-field="speedKTS"]').textContent = `${Math.round(ac.speedKTS)}kts`;
        ac.labelElement.querySelector('.current-altitude').textContent = currentFL;
        ac.labelElement.querySelector('.target-altitude').textContent = `⇢${targetFL}`;
        ac.labelElement.querySelector('[data-field="rateOfDescent"]').textContent = ` RoD ${ac.rateOfDescent > 0 ? ac.rateOfDescent : (ac.rateOfClimb > 0 ? `+${ac.rateOfClimb}` : '0')}`;

        const infoPanel = ac.labelElement.querySelector('.aircraft-info-panel');
        const infoTypeSpan = infoPanel.querySelector('.info-type');
        const infoDepWaypointSpan = infoPanel.querySelector('.info-dep-waypoint');
        const infoTargetFLLine = infoPanel.querySelector('.info-target-fl-line');
        const infoTargetFLSpan = infoPanel.querySelector('.info-target-fl');

        if (ac.showInfoPanel) {
            infoPanel.style.display = 'block';
            infoTypeSpan.textContent = ac.type || 'N/A';
            if (ac.departureTargetFL && ac.targetWaypoint) {
                infoDepWaypointSpan.textContent = ac.targetWaypoint;
                infoDepWaypointSpan.style.display = 'inline';
            } else {
                infoDepWaypointSpan.textContent = '';
                infoDepWaypointSpan.style.display = 'none';
            }
            if (ac.departureTargetFL) {
                infoTargetFLLine.style.display = 'block';
                infoTargetFLSpan.textContent = `FL${ac.departureTargetFL}`;
            } else {
                infoTargetFLLine.style.display = 'none';
            }
        } else {
            infoPanel.style.display = 'none';
        }

        if (!(typeof isDraggingLabel !== 'undefined' && isDraggingLabel && typeof draggedLabelItem !== 'undefined' && draggedLabelItem === ac)) {
            const screenPos = worldToScreen(ac.x, ac.y);
            if (ac.labelDragged) {
                ac.labelX = screenPos.x + ac.draggedLabelDeltaX;
                ac.labelY = screenPos.y + ac.draggedLabelDeltaY;
            } else {
                const aircraftSymbolScreenRadius = 4;
                const horizontalGap = 5;
                ac.labelX = screenPos.x + aircraftSymbolScreenRadius + horizontalGap;
                const labelHeight = ac.labelElement.offsetHeight || 20;
                ac.labelY = screenPos.y - labelHeight - 2;
            }
            if (ac.labelElement) {
                const labelWidth = ac.labelElement.offsetWidth || 80;
                const labelHeightCurrent = ac.labelElement.offsetHeight || 20;
                ac.labelX = Math.max(0, Math.min(ac.labelX, window.innerWidth - labelWidth - 5));
                ac.labelY = Math.max(0, Math.min(ac.labelY, window.innerHeight - labelHeightCurrent - 5));
                ac.labelElement.style.left = `${ac.labelX}px`;
                ac.labelElement.style.top = `${ac.labelY}px`;
            }
        }

        if (ac.labelElement) {
            ac.labelElement.style.fontSize = `${labelFontSize}px`;
            ac.labelElement.classList.toggle('selected', ac === selectedAircraft);
            ac.labelElement.classList.toggle('glow', !!ac.highlighted);
        }
    }
}


function drawRadar() {
    // 1. Canvas'ı Temizle (DPR'yi hesaba katarak)
    ctx.save();
    ctx.setTransform(1, 0, 0, 1, 0, 0); // Transformu sıfırla
    ctx.clearRect(0, 0, canvas.width, canvas.height); // Gerçek piksel boyutlarında temizle
    ctx.restore();

    // 2. Gerekli Veri Güncellemeleri (Çizimden önce)
    if (typeof updateMeasurementData === "function") {
        updateMeasurementData();
    }
    if (typeof updateTopCenterButtonStates === "function") {
        updateTopCenterButtonStates();
    }

    // 3. Dünya Koordinatlarına Geçiş (Pan ve Zoom)
    ctx.save();
    ctx.translate(panX, panY);
    ctx.scale(zoom, zoom);

    // 4. Arka Plan Görselini Çiz (WORLD_ORIGIN'e göre)
    if (backgroundImage.complete && backgroundImage.naturalWidth > 0) {
        const tDiamPx = nmToWorldPixels(innerCircleRadiusNM) * 2;
        const sF = tDiamPx / (backgroundImage.naturalWidth * imageInnerCircleDiameterFraction);
        const sWW = backgroundImage.naturalWidth * sF;
        const sHW = backgroundImage.naturalHeight * sF;
        const dXW = WORLD_ORIGIN_X - sWW / 2 + backgroundOffsetX;
        const dYW = WORLD_ORIGIN_Y - sHW / 2 + backgroundOffsetY;
        ctx.drawImage(backgroundImage, dXW, dYW, sWW, sHW);
    }

    // 5. Sabit Harita Elemanlarını Çiz (Radar Daireleri, Yön Çizgileri, Waypointler, Pist)
    if (typeof drawRadarCircles === "function") drawRadarCircles();
    if (typeof drawDirectionLines === "function") drawDirectionLines();
    if (typeof drawWaypoints === "function") drawWaypoints();
    if (typeof drawRunwayAndLocalizers === "function") drawRunwayAndLocalizers();

    // 6. Ölçüm Araçlarıyla İlgili Çizimler
    if (typeof isMeasuring !== 'undefined' && isMeasuring && typeof measurementStartPoint !== 'undefined' && measurementStartPoint) {
        if (typeof drawTemporaryMeasurementLine === "function") drawTemporaryMeasurementLine();
    }
    // Ölçüm için başlangıç noktası vurgusu
    if (typeof isMeasuring !== 'undefined' && isMeasuring && typeof measurementStartPoint !== 'undefined' && measurementStartPoint) {
        if (measurementStartPoint.type === 'aircraft') {
            const ac = aircrafts.find(a => a.id === measurementStartPoint.id);
            if (ac && typeof drawMeasurementHighlight === "function") drawMeasurementHighlight(ac);
        } else if (measurementStartPoint.type === 'runwayCenter') {
            ctx.save();
            ctx.strokeStyle = 'cyan';
            ctx.lineWidth = 2 / zoom;
            const crosshairSize = 6 / zoom;
            ctx.beginPath();
            ctx.moveTo(WORLD_ORIGIN_X - crosshairSize, WORLD_ORIGIN_Y);
            ctx.lineTo(WORLD_ORIGIN_X + crosshairSize, WORLD_ORIGIN_Y);
            ctx.moveTo(WORLD_ORIGIN_X, WORLD_ORIGIN_Y - crosshairSize);
            ctx.lineTo(WORLD_ORIGIN_X, WORLD_ORIGIN_Y + crosshairSize);
            ctx.stroke();
            ctx.restore();
        }
    }
    // Ölçüm için hover vurgusu
    if (typeof isMeasuring !== 'undefined' && isMeasuring && typeof measurementStartPoint !== 'undefined' && !measurementStartPoint && (typeof hoveredAircraftForMeasure !== 'undefined' && hoveredAircraftForMeasure || typeof hoveredRunwayCenterForMeasure !== 'undefined' && hoveredRunwayCenterForMeasure)) {
        aircrafts.forEach(ac => { ac.highlighted = (ac === hoveredAircraftForMeasure); });
        if (hoveredRunwayCenterForMeasure) {
            ctx.save();
            ctx.fillStyle = 'rgba(0, 255, 255, 0.5)';
            ctx.beginPath();
            ctx.arc(WORLD_ORIGIN_X, WORLD_ORIGIN_Y, 5 / zoom, 0, 2 * Math.PI);
            ctx.fill();
            ctx.restore();
        }
    } else if (typeof isMeasuring !== 'undefined' && !isMeasuring) { // Ölçüm yapılmıyorsa tüm vurguları kaldır
        aircrafts.forEach(ac => { ac.highlighted = false; });
    }
    // Kayıtlı Ölçüm Çizgilerini Çiz
    if (typeof measurements !== 'undefined') {
        measurements.forEach(m => {
            if (typeof drawMeasurementLine === "function") drawMeasurementLine(m);
        });
    }


    // 7. Yeni Uçak Yerleştirme İşaretçisini Çiz
    if (typeof pendingAircraftLocation !== 'undefined' && pendingAircraftLocation && typeof drawPlacementMarker === "function") {
        drawPlacementMarker(pendingAircraftLocation);
    }

    // 8. Uçakları, Hız Vektörlerini ve Trajektör Çizgilerini Çiz
    aircrafts.forEach(ac => {
        if (typeof drawAircraft === "function") drawAircraft(ac);
        if (typeof showVectors !== 'undefined' && showVectors && typeof drawSpeedVector === "function") {
            drawSpeedVector(ac);
        }
        // YENİ EKLENEN: Trajektör çizgisini çiz
        if (typeof drawTrajectoryLine === "function") {
            drawTrajectoryLine(ac); // Bu fonksiyon kendi içinde ac.showTrajectory kontrolü yapar
        }
    });

    // 9. Dünya Koordinat Transformasyonunu Geri Al
    ctx.restore();

    // 10. Ekran Koordinatlarında Çizilecekler veya DOM Güncellemeleri
    // (Bu kısım pan/zoom'dan etkilenmez, doğrudan ekran pikselleriyle çalışır)

    // Geçici ölçüm etiketi (DOM elemanı)
    if (typeof isMeasuring !== 'undefined' && isMeasuring && typeof measurementStartPoint !== 'undefined' && measurementStartPoint && typeof updateTemporaryMeasurementLabel === "function") {
        updateTemporaryMeasurementLabel(); // Bu fonksiyon lastMouseX/Y kullanarak DOM elemanını günceller
    } else {
        if (typeof tempMeasurementLabel !== 'undefined' && tempMeasurementLabel) tempMeasurementLabel.style.display = 'none';
    }

    // Uçak Etiketleri (DOM elemanları)
    aircrafts.forEach(ac => {
        if (typeof updateAircraftLabelPositionDOM === "function") updateAircraftLabelPositionDOM(ac);
    });

    // Ölçüm Etiketleri (DOM elemanları)
    if (typeof measurements !== 'undefined') {
        measurements.forEach(m => {
            if (typeof updateMeasurementLabelPositionDOM === "function") updateMeasurementLabelPositionDOM(m);
        });
    }


    // Sürüklenen Etiketler için Bağlantı Çizgileri (Ekran koordinatlarında çizilir)
    aircrafts.forEach(ac => {
        if (ac.labelDragged && ac.labelElement && typeof drawConnectionLine === "function") {
            drawConnectionLine(ac, 'aircraft');
        }
    });
    if (typeof measurements !== 'undefined') {
        measurements.forEach(m => {
            if (m.labelDragged && m.labelElement && typeof drawConnectionLine === "function") {
                drawConnectionLine(m, 'measurement');
            }
        });
    }
	updateAirIndicatorWindow();
}
function updateAirIndicatorWindow() {
    if (!airIndicatorWindow || !selectedAircraft) {
        if (airIndicatorWindow) airIndicatorWindow.style.display = 'none';
        return;
    }

    airIndicatorWindow.style.display = 'block';
    if (aiCallsign) aiCallsign.textContent = selectedAircraft.id;

    if (aiSpeedValue) {
        aiSpeedValue.textContent = `${Math.round(selectedAircraft.speedKTS)}`;
    }
    if (aiRodValue) {
        let rodText = "0";
        if (selectedAircraft.rateOfClimb > 0) {
            rodText = `+${selectedAircraft.rateOfClimb}`;
        } else if (selectedAircraft.rateOfDescent > 0) {
            rodText = `-${selectedAircraft.rateOfDescent}`;
        }
        aiRodValue.textContent = rodText;
    }
    if (aiHeadingValue) {
        // Mevcut başı mı hedef başı mı göstereceğinize karar verin.
        // Genellikle mevcut baş gösterilir, hedef baş popup'tan ayarlanır.
        aiHeadingValue.textContent = `${Math.round(selectedAircraft.heading)}°`;
    }
}
function toggleTrajectoryLine(aircraft) {
    if (!aircraft) return;
	console.log(`[toggleTrajectoryLine] Called for: ${aircraft.id}`);
    console.log(`[toggleTrajectoryLine] Before toggle - showTrajectory: ${aircraft.showTrajectory}, isTakingOff: ${aircraft.isTakingOff}, takeoffRunway: ${aircraft.takeoffRunway}`);
    aircraft.showTrajectory = !aircraft.showTrajectory;
    // Etiketteki LTXX metninin stilini ve içeriğini güncellemek için etiketi yeniden işle
    if (aircraft.labelElement && typeof updateAircraftLabelPositionDOM === "function") {
        updateAircraftLabelPositionDOM(aircraft);
    }
    // Bir sonraki animasyon karesinde drawRadar zaten çağrılacağı için
    // burada ayrıca drawRadar() çağırmaya genellikle gerek yoktur,
    // ancak anında güncelleme isteniyorsa çağrılabilir.
}

// Bu yardımcı fonksiyon, önceki kısa, süreli trajektör çizim mantığını içerir.
// drawTrajectoryLine içinde, eğer hedef waypoint yoksa veya bulunamazsa çağrılabilir.
function drawShortDefaultTrajectory(ac, context) { // context (ctx) parametresini ekledik
    const trajectoryDurationMinutes = 2; // Kaç dakikalık yol çizileceği
    const segments = 1; // Düz çizgi için 1 segment genellikle yeterli, veya daha fazla "nokta" istenirse artırılabilir
    const timeStepMinutes = trajectoryDurationMinutes / segments;

    let currentX = ac.x;
    let currentY = ac.y;
    let currentHeadingRad = toRadians(ac.heading); // Uçağın mevcut başı

    // Uçağın hızının bu süre boyunca sabit olduğunu varsayıyoruz
    const distanceNMThisSegment = (ac.speedKTS / 60) * trajectoryDurationMinutes; // Toplam mesafeyi hesapla
    const distancePxThisSegment = nmToWorldPixels(distanceNMThisSegment);

    currentX += Math.sin(currentHeadingRad) * distancePxThisSegment;
    currentY -= Math.cos(currentHeadingRad) * distancePxThisSegment; // Canvas Y ekseni ters

    context.lineTo(currentX, currentY); // Uçağın mevcut konumundan hesaplanan noktaya çizgi çek
}

function drawTrajectoryLine(ac) {
    // Koşul: Sadece showTrajectory true ise çiz.
    if (!ac.showTrajectory) {
        // console.log(`[drawTrajectoryLine] NOT DRAWING for ${ac.id} because showTrajectory is false.`);
        return;
    }

    // Uçağın bir hedef waypoint'i var mı kontrol et.
    // 'targetWaypoint' özelliği, uçağın gitmesi gereken waypoint'in adını (string) tutmalıdır.
    // 'waypoints' dizisi ise { name: '...', angle: ..., distanceNM: ... } objelerini içermelidir.
    // Ayrıca, kalkış yapmış bir uçak olduğunu belirtmek için 'takeoffRunway' özelliğini de kontrol edebiliriz.
    // Bu, yanlışlıkla iniş yapan bir uçağın waypoint'ine çizgi çekmeyi engeller (eğer böyle bir ayrım isteniyorsa).
    
    let drawnToWaypoint = false;

    if (ac.targetWaypoint && typeof waypoints !== 'undefined' && waypoints.length > 0) {
        const waypointData = waypoints.find(wp => wp.name === ac.targetWaypoint);

        if (waypointData) {
            // Hedef waypoint bulundu, onun koordinatlarına çizgi çek.
            // Waypoint koordinatları, drawWaypoints fonksiyonunuzdaki gibi WORLD_ORIGIN'e göre hesaplanmalı.
            const angleRad = toRadians(waypointData.angle);
            const distancePixels = nmToWorldPixels(waypointData.distanceNM);
            const wpX = WORLD_ORIGIN_X + Math.sin(angleRad) * distancePixels;
            const wpY = WORLD_ORIGIN_Y - Math.cos(angleRad) * distancePixels; // Y ekseni ters olduğu için çıkarıyoruz

            ctx.save();
            ctx.strokeStyle = 'lime'; // Yeşil çizgi
            ctx.lineWidth = 1.5 / zoom;
            ctx.setLineDash([5 / zoom, 3 / zoom]); // Kesikli çizgi

            ctx.beginPath();
            ctx.moveTo(ac.x, ac.y); // Uçağın mevcut konumundan başla
            ctx.lineTo(wpX, wpY);   // Hedef waypoint'e çizgi çek
            ctx.stroke();
            ctx.restore();

            // console.log(`[drawTrajectoryLine] DRAWN to WAYPOINT ${ac.targetWaypoint} for ${ac.id}`);
            drawnToWaypoint = true;
        } else {
            // console.warn(`[drawTrajectoryLine] Waypoint data for '${ac.targetWaypoint}' NOT FOUND for aircraft ${ac.id}.`);
        }
    }

    // Eğer waypoint'e çizilmediyse VE uçak hala aktif kalkış fazındaysa, kısa varsayılan çizgiyi çiz.
    // "LTXX" sadece isTakingOff true iken göründüğü için, bu koşul mantıklı.
    if (!drawnToWaypoint && ac.isTakingOff) {
        // console.log(`[drawTrajectoryLine] Waypoint not targeted or not found for ${ac.id}, but isTakingOff. Drawing short default trajectory.`);
        ctx.save();
        ctx.strokeStyle = 'lime';
        ctx.lineWidth = 1.5 / zoom;
        ctx.setLineDash([5 / zoom, 3 / zoom]);
        ctx.beginPath();
        ctx.moveTo(ac.x, ac.y);
        drawShortDefaultTrajectory(ac, ctx); // ctx'i parametre olarak geçir
        ctx.stroke();
        ctx.restore();
    } else if (!drawnToWaypoint && !ac.isTakingOff) {
        // console.log(`[drawTrajectoryLine] Not drawing for ${ac.id}: No target waypoint and not in takeoff phase.`);
    }
}

function createMeasurementLabel(measurement) {
    const label = document.createElement('div');
    label.className = 'dynamic-label measurement-label';
    label.dataset.measurementId = measurement.id;
    let labelContent = "";
    if (measurement.start.type === 'aircraft' && measurement.end.type === 'aircraft') {
        const relativeBearingText = `<span class="measurement-relative-bearing">${formatRelativeBearing(measurement.relativeBearing1)} / ${formatRelativeBearing(measurement.relativeBearing2)}</span>`;
        const distAltText = `<span class="measurement-dist-alt">${measurement.distanceNM.toFixed(1)} NM</span>`;
        labelContent = relativeBearingText + distAltText;
    } else if ((measurement.start.type === 'aircraft' && measurement.end.type === 'runwayCenter') || (measurement.start.type === 'runwayCenter' && measurement.end.type === 'aircraft')) {
        const bearingText = `<span class="measurement-bearing">${formatBearing(measurement.bearing)} / ${formatBearing(measurement.reciprocalBearing)}</span>`;
        let distAltText = `<span class="measurement-dist-alt">${measurement.distanceNM.toFixed(1)} NM`;
        let extraInfo = "";
        if (measurement.start.type === 'aircraft' && measurement.estimatedAltitude !== null && measurement.estimatedAltitude !== undefined) {
            distAltText += ` / ~${formatFlightLevel(measurement.estimatedAltitude)} (to RWY)`;
        } else if (measurement.start.type === 'runwayCenter' && measurement.end.type === 'aircraft') {
            const acEnd = aircrafts.find(a => a.id === measurement.end.id);
            if (acEnd) {
                distAltText += ` / ${formatFlightLevel(acEnd.altitude)}`;
                if(measurement.relativeBearing2 !== null) { extraInfo = `<span class="measurement-relative-bearing">AC to RWY: ${formatRelativeBearing(measurement.relativeBearing2)}</span>`; }
            }
        }
        distAltText += `</span>`; labelContent = bearingText + extraInfo + distAltText;
    } else {
        const bearingText = `<span class="measurement-bearing">${formatBearing(measurement.bearing)} / ${formatBearing(measurement.reciprocalBearing)}</span>`;
        let distAltText = `<span class="measurement-dist-alt">${measurement.distanceNM.toFixed(1)} NM`;
        if (measurement.estimatedAltitude !== null && measurement.estimatedAltitude !== undefined) { distAltText += ` / ~${formatFlightLevel(measurement.estimatedAltitude)}`; }
        distAltText += `</span>`; labelContent = bearingText + distAltText;
    }
    label.innerHTML = labelContent; document.body.appendChild(label);
    measurement.labelElement = label; measurement.labelDragged = false;
    measurement.draggedLabelDeltaX = 0; measurement.draggedLabelDeltaY = 0;
    updateMeasurementLabelPositionDOM(measurement);
    label.addEventListener('mousedown', (e) => startLabelDrag(e, measurement, 'measurement'));
    label.addEventListener('contextmenu', (e) => {
        e.preventDefault(); measurements = measurements.filter(m => m.id !== measurement.id); label.remove();
    });
}
function updateMeasurementLabelPositionDOM(measurement) {
    if (measurement.labelElement) {
        if (!(isDraggingLabel && draggedLabelItem === measurement)) {
            const midXWorld = (measurement.start.x + measurement.end.x) / 2;
            const midYWorld = (measurement.start.y + measurement.end.y) / 2;
            const screenPos = worldToScreen(midXWorld, midYWorld);
            const labelHeight = measurement.labelElement.offsetHeight || 20;
            if (measurement.labelDragged) {
                measurement.labelX = screenPos.x + measurement.draggedLabelDeltaX;
                measurement.labelY = screenPos.y + measurement.draggedLabelDeltaY;
            } else {
                measurement.labelX = screenPos.x + 10;
                measurement.labelY = screenPos.y - (labelHeight / 2);
            }
            const labelWidth = measurement.labelElement.offsetWidth || 80;
            measurement.labelX = Math.max(0, Math.min(measurement.labelX, window.innerWidth - labelWidth));
            measurement.labelY = Math.max(0, Math.min(measurement.labelY, window.innerHeight - labelHeight));
            measurement.labelElement.style.left = `${measurement.labelX}px`;
            measurement.labelElement.style.top = `${measurement.labelY}px`;
        }
        measurement.labelElement.style.fontSize = `${labelFontSize}px`;
    }
}

function showPopupForField(x, y, field) {
    if (!selectedAircraft) return;
    popup.innerHTML = ''; // Popup'ı her seferinde temizle
    let values = [];
    let current;
    // Kullanıcının önceden seçtiği L/R dönüş yönünü hatırla (eğer varsa)
    let tempCommandedTurnDirection = (selectedAircraft.turning && selectedAircraft.commandedTurnDirection !== 0) ? selectedAircraft.commandedTurnDirection : 0;

    if (field === 'heading') {
        current = selectedAircraft.targetHeading; // Genellikle hedef başı değiştiririz
        popup.innerHTML = `
            <div id="headingValues" style="max-height: 140px; overflow-y: auto; scrollbar-width: thin; scrollbar-color: #0f0 #555; margin-bottom: 5px;"></div>
            <div id="turnButtons" style="margin-bottom: 5px;">
                <div class="turn-btn control-button" data-direction="-1">LEFT</div>
                <div class="turn-btn control-button" data-direction="1">RIGHT</div>
            </div>
            <div id="manualHeadingEntry" style="display: flex; align-items: center; border-top: 1px solid #777; padding-top: 5px;">
                <input type="number" id="manualHeadingInput" min="0" max="359" step="1" style="width: 50px; text-align: right; margin-right: 5px; padding: 3px; font-size:12px; background-color: #eee; color: #333; border: 1px solid #777; border-radius:2px;" placeholder="HDG" value="${Math.round(selectedAircraft.targetHeading)}">
                <button id="submitManualHeading" class="control-button" style="padding: 3px 8px; font-size: 11px; min-width: unset; margin-bottom:0px; background-color: #4CAF50; border-color: #4CAF50;">Set</button>
            </div>`;

        const headingValuesContainer = document.getElementById('headingValues');
        const turnButtonsContainer = document.getElementById('turnButtons');
        const manualHeadingInput = document.getElementById('manualHeadingInput');
        const submitManualHeadingBtn = document.getElementById('submitManualHeading');

        const applyHeadingChange = (newHeadingStr) => {
            let newHeading = parseInt(newHeadingStr, 10);
            if (newHeadingStr.trim() === "" && selectedAircraft) { // Eğer input boşsa, mevcut hedef başını koru
                newHeading = selectedAircraft.targetHeading;
            } else if (isNaN(newHeading) || newHeading < 0 || newHeading > 359) {
                if (parseInt(newHeadingStr, 10) === 360) { // 360 girilirse 0 kabul et
                    newHeading = 0;
                } else {
                    if(manualHeadingInput) manualHeadingInput.style.borderColor = 'red';
                    setTimeout(() => { if(manualHeadingInput) manualHeadingInput.style.borderColor = '#777'; }, 1500);
                    return; // Geçersiz giriş, popup'ı kapatma
                }
            }

            if (selectedAircraft) {
                selectedAircraft.targetHeading = newHeading;
                if (selectedAircraft.isIntercepting) { // Eğer intercept modundaysa, iptal et
                    selectedAircraft.isIntercepting = false;
                    selectedAircraft.interceptCourse = null;
                    if(typeof updateTopCenterButtonStates === "function") updateTopCenterButtonStates();
                }
                selectedAircraft.turning = true; // Dönüşü başlat/devam ettir
                selectedAircraft.commandedTurnDirection = tempCommandedTurnDirection; // Seçili L/R yönünü kullan
                selectedAircraft.lastHeadingUpdateTime = 0; // Dönüş hesaplamasını tetikle
            }
            popup.style.display = 'none'; // İşlem sonrası popup'ı kapat
        };

        submitManualHeadingBtn.addEventListener('click', () => applyHeadingChange(manualHeadingInput.value));
        manualHeadingInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                submitManualHeadingBtn.click();
            }
        });

        turnButtonsContainer.querySelectorAll('.turn-btn').forEach(btn => {
            if (parseInt(btn.dataset.direction) === tempCommandedTurnDirection) {
                btn.classList.add('active');
            }
            btn.addEventListener('click', (e) => {
                e.stopPropagation();
                const clickedDir = parseInt(e.target.dataset.direction);
                if (tempCommandedTurnDirection === clickedDir) {
                    tempCommandedTurnDirection = 0; // Tekrar tıklayınca yön seçimini kaldır
                    e.target.classList.remove('active');
                } else {
                    tempCommandedTurnDirection = clickedDir;
                    turnButtonsContainer.querySelectorAll('.turn-btn').forEach(b => b.classList.remove('active'));
                    e.target.classList.add('active');
                }
            });
        });

        const div360 = document.createElement('div');
        div360.textContent = `360°`;
        div360.onclick = () => applyHeadingChange("0"); // 360 tıklandığında 0 olarak ayarla
        if (0 === Math.round(current)) div360.classList.add('current-value'); // Eğer mevcut hedef 0 ise
        headingValuesContainer.appendChild(div360);

        for (let i = 355; i >= 5; i -= 5) { // 5'ten başla ki 0 ile çakışmasın (360 zaten 0 oldu)
            const val = i;
            const div = document.createElement('div');
            div.textContent = `${val.toString().padStart(3, '0')}°`;
            if (val === Math.round(current)) { // Mevcut hedef başıyla eşleşiyorsa
                div.classList.add('current-value');
            }
            div.onclick = () => applyHeadingChange(val.toString());
            headingValuesContainer.appendChild(div);
        }
         // YENİ: manualHeadingInput'a odaklan ve metni seç
        if (manualHeadingInput) {
            setTimeout(() => { // DOM güncellemesi ve görünürlük için kısa bir gecikme
                manualHeadingInput.focus();
                manualHeadingInput.select(); // Opsiyonel: Mevcut değeri seçili hale getirir
            }, 50);
        }


    } else if (field === 'speedKTS') {
        current = selectedAircraft.speedKTS;
        values = Array.from({ length: (600 - 100) / 10 + 1 }, (_, i) => 100 + i * 10); // 100'den 600'e 10'ar
        values.reverse(); // Büyükten küçüğe sırala
        values.forEach(val => {
            const div = document.createElement('div');
            div.textContent = `${val} kts`;
            if (val === Math.round(current)) div.classList.add('current-value');
            div.onclick = () => {
                if (selectedAircraft) selectedAircraft.speedKTS = val;
                popup.style.display = 'none';
            };
            popup.appendChild(div);
        });
    } else if (field === 'altitude') {
        current = selectedAircraft.targetAltitude;
        // FL010 (1000ft) - FL450 (45000ft), 500ft (5FL) aralıklarla
        for (let flVal = 450; flVal >= 10; flVal -= 5) {
            const altInFeet = flVal * 100;
            const div = document.createElement('div');
            div.textContent = formatFlightLevel(altInFeet);
            if (altInFeet === current) div.classList.add('current-value');
            div.onclick = () => {
                if (selectedAircraft) {
                    selectedAircraft.targetAltitude = altInFeet;
                    // İrtifa değişiminde ROC/ROD'u otomatik ayarla
                    if (selectedAircraft.altitude < altInFeet && selectedAircraft.rateOfClimb === 0) {
                        selectedAircraft.rateOfClimb = aircraftPerformanceROC[selectedAircraft.type] || DEFAULT_CLIMB_RATE;
                        selectedAircraft.rateOfDescent = 0;
                    } else if (selectedAircraft.altitude > altInFeet && selectedAircraft.rateOfDescent === 0) {
                        selectedAircraft.rateOfDescent = DEFAULT_ROD;
                        selectedAircraft.rateOfClimb = 0;
                    }
                }
                popup.style.display = 'none';
            };
            popup.appendChild(div);
        }
    } else if (field === 'rateOfDescent') { // Bu alan artık ROD/ROC olarak birleşik
        current = selectedAircraft.rateOfClimb > 0 ? -selectedAircraft.rateOfClimb : selectedAircraft.rateOfDescent; // Tırmanış negatif ROD gibi
        values = [3000, 2500, 2000, 1800, 1500, 1000, 500, 0, -500, -1000, -1500, -1800, -2000, -2500, -3000]; // Pozitif: Alçalma, Negatif: Tırmanma
        values.forEach(val => {
            const div = document.createElement('div');
            let textToShow;
            if (val === 0) textToShow = "LVL (0)";
            else if (val > 0) textToShow = `-${val}`; // Alçalma
            else textToShow = `+${Math.abs(val)}`;   // Tırmanma
            div.textContent = textToShow;

            let isActiveValue = false;
            if (val === 0 && selectedAircraft.rateOfClimb === 0 && selectedAircraft.rateOfDescent === 0) isActiveValue = true;
            else if (val > 0 && selectedAircraft.rateOfDescent === val && selectedAircraft.rateOfClimb === 0) isActiveValue = true;
            else if (val < 0 && selectedAircraft.rateOfClimb === Math.abs(val) && selectedAircraft.rateOfDescent === 0) isActiveValue = true;
            
            if (isActiveValue) div.classList.add('current-value');

            div.onclick = () => {
                if (selectedAircraft) {
                    if (val > 0) { // Pozitif değer seçildiyse (alçalma)
                        selectedAircraft.rateOfDescent = val;
                        selectedAircraft.rateOfClimb = 0;
                    } else if (val < 0) { // Negatif değer seçildiyse (tırmanma)
                        selectedAircraft.rateOfClimb = Math.abs(val);
                        selectedAircraft.rateOfDescent = 0;
                    } else { // 0 seçildiyse
                        selectedAircraft.rateOfDescent = 0;
                        selectedAircraft.rateOfClimb = 0;
                    }
                }
                popup.style.display = 'none';
            };
            popup.appendChild(div);
        });
    }

    // Popup konumlandırma ve görünür yapma (bu kısım aynı)
    popup.style.width = '160px';
    popup.style.maxHeight = '260px'; // Biraz artırıldı
    popup.style.visibility = 'hidden';
    popup.style.display = 'block'; // Boyutları hesaplamak için önce block yap

    const actualPopupWidth = popup.offsetWidth;
    const actualPopupHeight = popup.offsetHeight;

    // x, y popup'ın açılacağı referans noktanın (örn. Air Indicator değeri) sağ üstüydü.
    // Popup'ı bu noktanın sağına veya soluna yerleştir.
    let finalX = x;
    let finalY = y - (actualPopupHeight / 2); // Referans noktanın dikey ortasına yakın

    if (finalX + actualPopupWidth > window.innerWidth - 15) { // Sağ kenara taşarsa
        finalX = x - actualPopupWidth - 200; // Air Indicator'ın soluna veya referansın epey soluna al (x, Air Indicator'ın sağını işaret ediyorsa)
    }
     finalX = Math.max(15, finalX); // Sol kenardan taşmasın
     finalY = Math.max(15, Math.min(finalY, window.innerHeight - actualPopupHeight - 15)); // Dikeyde ekran içinde kalsın


    popup.style.left = `${finalX}px`;
    popup.style.top = `${finalY}px`;
    popup.style.visibility = 'visible';

}

// --- Olay Dinleyiciler ---
canvas.addEventListener('mousedown', function(event) {
    if (event.button === 1 || (event.button === 0 && event.ctrlKey)) {
        if (!isDraggingLabel) { isPanning = true; canvas.style.cursor = 'grabbing'; event.preventDefault(); }
    } else if (event.button === 0) {
        if (!isDraggingLabel) canvas.style.cursor = isMeasuring ? 'crosshair' : (isPlacingAircraft ? 'crosshair' : 'grab');
    }
});
canvas.addEventListener('contextmenu', function(event) {
    if (isMeasuring && measurementStartPoint) {
        event.preventDefault(); isMeasuring = false; measurementStartPoint = null;
        hoveredAircraftForMeasure = null; hoveredRunwayCenterForMeasure = false;
        if (measureButton) { measureButton.classList.remove('measuring'); measureButton.textContent = 'Ölçüm Yap'; }
        canvas.style.cursor = isPlacingAircraft ? 'crosshair' : 'grab';
        if (tempMeasurementLabel) tempMeasurementLabel.style.display = 'none';
    }
});

function handleGlobalMouseMove(event) {
    const currentMouseX = event.clientX; const currentMouseY = event.clientY;
    if (isDraggingLabel && draggedLabelItem) {
        let newX = currentMouseX - dragOffsetX; let newY = currentMouseY - dragOffsetY;
        const labelWidth = draggedLabelItem.labelElement.offsetWidth;
        const labelHeight = draggedLabelItem.labelElement.offsetHeight;
        newX = Math.max(0, Math.min(newX, window.innerWidth - labelWidth));
        newY = Math.max(0, Math.min(newY, window.innerHeight - labelHeight));
        draggedLabelItem.labelX = newX; draggedLabelItem.labelY = newY;
        if (draggedLabelItem.labelElement) {
            draggedLabelItem.labelElement.style.left = `${newX}px`;
            draggedLabelItem.labelElement.style.top = `${newY}px`;
        }
        if (runwayCenterHoverText) runwayCenterHoverText.style.display = 'none'; return;
    }
    if (isPanning && (event.buttons === 4 || (event.buttons === 1 && event.ctrlKey))) {
        const dx = currentMouseX - lastMouseX; const dy = currentMouseY - lastMouseY;
        let newPanX = panX + dx; let newPanY = panY + dy;
        const panLimitNM = 150; const panLimitWorldPixels = nmToWorldPixels(panLimitNM);
        const minPanX = centerX * (1 - zoom) - panLimitWorldPixels * zoom;
        const maxPanX = centerX * (1 - zoom) + panLimitWorldPixels * zoom;
        const minPanY = centerY * (1 - zoom) - panLimitWorldPixels * zoom;
        const maxPanY = centerY * (1 - zoom) + panLimitWorldPixels * zoom;
        newPanX = Math.max(minPanX, Math.min(newPanX, maxPanX));
        newPanY = Math.max(minPanY, Math.min(newPanY, maxPanY));
        panX = newPanX; panY = newPanY;
        lastMouseX = currentMouseX; lastMouseY = currentMouseY; event.preventDefault();
        if (runwayCenterHoverText) runwayCenterHoverText.style.display = 'none';
        hoveredAircraftForMeasure = null; hoveredRunwayCenterForMeasure = false; return;
    }
    const worldMousePosForHover = screenToWorld(currentMouseX, currentMouseY);
    const runwayCenterHoverRadiusWorld = 5 / zoom; let isHoveringRunwayCenter = false;
    if (centerX !== undefined && centerY !== undefined) {
        const distToRunwayCenter = Math.sqrt(Math.pow(worldMousePosForHover.x - centerX, 2) + Math.pow(worldMousePosForHover.y - centerY, 2));
        if (distToRunwayCenter < runwayCenterHoverRadiusWorld) isHoveringRunwayCenter = true;
    }
    if (isHoveringRunwayCenter && !isDraggingLabel && !isPanning) {
        if (runwayCenterHoverText) {
            runwayCenterHoverText.style.left = `${currentMouseX + 7}px`;
            runwayCenterHoverText.style.top = `${currentMouseY - 15}px`;
            runwayCenterHoverText.style.display = 'block';
        }
    } else { if (runwayCenterHoverText) runwayCenterHoverText.style.display = 'none'; }
    hoveredAircraftForMeasure = null; hoveredRunwayCenterForMeasure = false;
    if (isMeasuring) {
        const worldMousePos = screenToWorld(currentMouseX, currentMouseY);
        const runwayCenterClickRadiusWorld = 5 / zoom;
        const distToCenterForMeasure = Math.sqrt(Math.pow(worldMousePos.x - centerX, 2) + Math.pow(worldMousePos.y - centerY, 2));
        if (distToCenterForMeasure < runwayCenterClickRadiusWorld) {
            hoveredRunwayCenterForMeasure = true; canvas.style.cursor = 'crosshair';
        } else {
            const hoverThresholdWorld = 6 / zoom; let foundAircraft = null;
            for (const ac of aircrafts) {
                const dist = Math.sqrt(Math.pow(worldMousePos.x - ac.x, 2) + Math.pow(worldMousePos.y - ac.y, 2));
                if (dist < hoverThresholdWorld) { foundAircraft = ac; break; }
            }
            hoveredAircraftForMeasure = foundAircraft;
            if (!foundAircraft) canvas.style.cursor = 'crosshair';
        }
    } else { if (!isPanning && !isDraggingLabel) canvas.style.cursor = isPlacingAircraft ? 'crosshair' : 'grab'; }
    lastMouseX = currentMouseX; lastMouseY = currentMouseY;
}
document.addEventListener('mousemove', handleGlobalMouseMove);

canvas.addEventListener('mouseup', function(event) {
    if (isPanning && (event.button === 1 || (event.button === 0 && event.ctrlKey))) {
        isPanning = false; if (!isDraggingLabel) canvas.style.cursor = isMeasuring ? 'crosshair' : (isPlacingAircraft ? 'crosshair' : 'grab');
    }
});
document.addEventListener('mouseup', function(event) {
    if (event.button === 1) { // Orta tuş bırakıldığında
        if (isDraggingLabel && draggedLabelItem) {
            let anchorScreenX, anchorScreenY;
            if (draggedLabelType === 'aircraft') { const sP = worldToScreen(draggedLabelItem.x, draggedLabelItem.y); anchorScreenX = sP.x; anchorScreenY = sP.y; }
            else if (draggedLabelType === 'measurement') {
                const mXW = (draggedLabelItem.start.x + draggedLabelItem.end.x) / 2; const mYW = (draggedLabelItem.start.y + draggedLabelItem.end.y) / 2;
                const sP = worldToScreen(mXW, mYW); anchorScreenX = sP.x; anchorScreenY = sP.y;
            }
            if (anchorScreenX !== undefined && anchorScreenY !== undefined) {
                draggedLabelItem.draggedLabelDeltaX = draggedLabelItem.labelX - anchorScreenX;
                draggedLabelItem.draggedLabelDeltaY = draggedLabelItem.labelY - anchorScreenY;
            }
            draggedLabelItem.labelDragged = true;
            if (draggedLabelItem.labelElement) draggedLabelItem.labelElement.classList.remove('dragging');
            isDraggingLabel = false; draggedLabelItem = null; draggedLabelType = null;
            canvas.style.cursor = isMeasuring ? 'crosshair' : (isPlacingAircraft ? 'crosshair' : 'grab');
        }
        if (isPanning) { // Eğer orta tuşla pan yapılıyorsa
            isPanning = false;
            canvas.style.cursor = isMeasuring ? 'crosshair' : (isPlacingAircraft ? 'crosshair' : 'grab');
        }
    }
});
canvas.addEventListener('mouseleave', function() {
    hoveredAircraftForMeasure = null; hoveredRunwayCenterForMeasure = false;
    if (runwayCenterHoverText) runwayCenterHoverText.style.display = 'none';
});
canvas.addEventListener('click', function(event) {
    if (isMeasuring) {
        let clickTarget; const worldClickPosForCheck = screenToWorld(event.clientX, event.clientY);
        const runwayCenterClickRadiusWorld = 5 / zoom;
        const distToRunwayCenter = Math.sqrt(Math.pow(worldClickPosForCheck.x - centerX, 2) + Math.pow(worldClickPosForCheck.y - centerY, 2));
        if (distToRunwayCenter < runwayCenterClickRadiusWorld) {
            clickTarget = { x: centerX, y: centerY, type: 'runwayCenter', id: 'RUNWAY_CENTER' };
        } else {
            const clickThresholdWorld = 5 / zoom; let clickedAircraftCheck = null;
            for (const ac of aircrafts) {
                const distance = Math.sqrt(Math.pow(worldClickPosForCheck.x - ac.x, 2) + Math.pow(worldClickPosForCheck.y - ac.y, 2));
                if (distance < clickThresholdWorld) { clickedAircraftCheck = ac; break; }
            }
            if (clickedAircraftCheck) { clickTarget = { x: clickedAircraftCheck.x, y: clickedAircraftCheck.y, type: 'aircraft', id: clickedAircraftCheck.id }; }
            else { const worldClickPos = screenToWorld(event.clientX, event.clientY); clickTarget = { x: worldClickPos.x, y: worldClickPos.y, type: 'point', id: null }; }
        }
        if (!measurementStartPoint) {
            measurementStartPoint = clickTarget; canvas.style.cursor = 'crosshair';
            measureButton.textContent = 'Ölçüm: İkinci Nokta';
            hoveredAircraftForMeasure = null; hoveredRunwayCenterForMeasure = false;
            if (tempMeasurementLabel) tempMeasurementLabel.style.display = 'block';
        } else {
            try {
                const measurementEndPoint = clickTarget;
                const dx = measurementEndPoint.x - measurementStartPoint.x; const dy = measurementEndPoint.y - measurementStartPoint.y;
                const distanceWorldPixels = Math.sqrt(dx * dx + dy * dy); const distanceNM = worldPixelsToNm(distanceWorldPixels);
                let estimatedAltitude = null; let bearing = null; let reciprocalBearing = null; let relativeBearing1 = null; let relativeBearing2 = null;
                bearing = calculateBearing(measurementStartPoint.x, measurementStartPoint.y, measurementEndPoint.x, measurementEndPoint.y);
                reciprocalBearing = (bearing + 180) % 360;
                if (measurementStartPoint.type === 'aircraft') {
                    const startAircraft = aircrafts.find(a => a.id === measurementStartPoint.id);
                    if (startAircraft) {
                        if (measurementEndPoint.type === 'point' || measurementEndPoint.type === 'runwayCenter') {
                            if (startAircraft.speedKTS > 0) {
                                const timeHours = distanceNM / startAircraft.speedKTS; const timeMinutes = timeHours * 60;
                                let verticalDirection = 0; if (startAircraft.altitude !== startAircraft.targetAltitude) verticalDirection = Math.sign(startAircraft.targetAltitude - startAircraft.altitude);
                                let effectiveRodMagnitude = 0;
                                if (startAircraft.rateOfDescent !== 0 && verticalDirection < 0) effectiveRodMagnitude = Math.abs(startAircraft.rateOfDescent);
                                else if (startAircraft.rateOfClimb !== 0 && verticalDirection > 0) effectiveRodMagnitude = Math.abs(startAircraft.rateOfClimb);
                                else if (verticalDirection !== 0) effectiveRodMagnitude = verticalDirection > 0 ? DEFAULT_CLIMB_RATE : DEFAULT_ROD;
                                const altitudeChange = verticalDirection * effectiveRodMagnitude * timeMinutes;
                                estimatedAltitude = startAircraft.altitude + altitudeChange; estimatedAltitude = Math.max(0, estimatedAltitude);
                            }
                        } else if (measurementEndPoint.type === 'aircraft') {
                            const endAircraft = aircrafts.find(a => a.id === measurementEndPoint.id);
                            if (endAircraft) { relativeBearing1 = angleDiff(bearing, startAircraft.heading); relativeBearing2 = angleDiff(reciprocalBearing, endAircraft.heading); }
                        }
                    }
                } else if (measurementStartPoint.type === 'runwayCenter' && measurementEndPoint.type === 'aircraft') {
                    const endAircraft = aircrafts.find(a => a.id === measurementEndPoint.id);
                    if (endAircraft) relativeBearing2 = angleDiff(reciprocalBearing, endAircraft.heading);
                }
                const newMeasurement = {
                    id: Date.now(), start: { ...measurementStartPoint }, end: { ...measurementEndPoint }, distanceNM: distanceNM, bearing: bearing, reciprocalBearing: reciprocalBearing,
                    relativeBearing1: relativeBearing1, relativeBearing2: relativeBearing2, estimatedAltitude: estimatedAltitude,
                    labelElement: null, labelX: 0, labelY: 0, labelDragged: false, draggedLabelDeltaX: 0, draggedLabelDeltaY: 0
                };
                measurements.push(newMeasurement); createMeasurementLabel(newMeasurement);
            } catch (error) { console.error("Error during measurement completion:", error);
            } finally {
                isMeasuring = false; measurementStartPoint = null;
                hoveredAircraftForMeasure = null; hoveredRunwayCenterForMeasure = false;
                measureButton.classList.remove('measuring'); measureButton.textContent = 'Ölçüm Yap';
                canvas.style.cursor = isPlacingAircraft ? 'crosshair' : 'grab';
                if (tempMeasurementLabel) tempMeasurementLabel.style.display = 'none';
            }
        }
        event.stopPropagation(); return;
    }
    if (isPanning || isDraggingLabel || event.ctrlKey || event.button !== 0) return;
    const worldClickPos = screenToWorld(event.clientX, event.clientY); const mouseX = worldClickPos.x; const mouseY = worldClickPos.y;
    if (isPlacingAircraft) {
        pendingAircraftLocation = { x: mouseX, y: mouseY }; isPlacingAircraft = false; canvas.style.cursor = 'grab';
        addAircraftButton.classList.remove('placing'); addAircraftButton.textContent = 'Uçak Ekle';
        addAircraftForm.style.display = 'block'; formErrorDiv.textContent = ''; inputCallsign.focus(); event.stopPropagation(); return;
    }
    const clickThresholdWorld = 5 / zoom; let clickedAircraftCheck = null;
    for (const ac of aircrafts) { const distance = Math.sqrt(Math.pow(mouseX - ac.x, 2) + Math.pow(mouseY - ac.y, 2)); if (distance < clickThresholdWorld) { clickedAircraftCheck = ac; break; } }
    if (clickedAircraftCheck) {
        selectedAircraft = clickedAircraftCheck;
        document.querySelectorAll('.aircraft-label.selected').forEach(el => el.classList.remove('selected'));
        if(selectedAircraft.labelElement) selectedAircraft.labelElement.classList.add('selected');
        updateTopCenterButtonStates();
    } else {
        if (selectedAircraft && !popup.contains(event.target)) {
            selectedAircraft = null; popup.style.display = 'none';
            document.querySelectorAll('.aircraft-label.selected').forEach(el => el.classList.remove('selected'));
            updateTopCenterButtonStates();
        }
    }
});
canvas.addEventListener('wheel', function(event) {
    event.preventDefault(); const zoomIntensity = 0.1; const oldZoom = zoom;
    const delta = event.deltaY < 0 ? (1 + zoomIntensity) : (1 - zoomIntensity);
    zoom = Math.min(Math.max(oldZoom * delta, 0.2), 5.0);
    if (zoom !== oldZoom) {
        const rect = canvas.getBoundingClientRect();
        const mouseXCanvas = event.clientX - rect.left; const mouseYCanvas = event.clientY - rect.top;
        const mouseXWorldBefore = (mouseXCanvas - panX) / oldZoom;
        const mouseYWorldBefore = (mouseYCanvas - panY) / oldZoom;
        panX = mouseXCanvas - mouseXWorldBefore * zoom;
        panY = mouseYCanvas - mouseYWorldBefore * zoom;
    }
});

// --- Buton Olayları ---
fullscreenButton.addEventListener('click', () => {
    if (!document.fullscreenElement) document.documentElement.requestFullscreen().catch(err => console.error(`Tam ekran: ${err.message}`));
    else if (document.exitFullscreen) document.exitFullscreen().catch(err => console.error(`Tam ekrandan çıkış: ${err.message}`));
});
vectorToggle.addEventListener('click', () => { showVectors = !showVectors; vectorToggle.textContent = `Speed Vector: ${showVectors ? 'AÇIK' : 'KAPALI'}`; vectorToggle.classList.toggle('active', showVectors); });
document.querySelectorAll('#vectorControls button[data-minutes]').forEach(btn => {
    btn.addEventListener('click', function() { vectorMinutes = parseInt(this.dataset.minutes); document.querySelectorAll('#vectorControls button[data-minutes]').forEach(b => b.classList.remove('active')); this.classList.add('active'); });
});
labelSizeControl.addEventListener('input', function() { labelFontSize = parseInt(this.value); });
btnLoc21L.addEventListener('click', () => { showLocalizerLeft = !showLocalizerLeft; btnLoc21L.classList.toggle('active', showLocalizerLeft); });
btnLocRight.addEventListener('click', () => { showLocalizerRight = !showLocalizerRight; btnLocRight.classList.toggle('active', showLocalizerRight); });
measureButton.addEventListener('click', () => {
    isMeasuring = !isMeasuring;
    if (isMeasuring) {
        measureButton.classList.add('measuring'); measureButton.textContent = 'Ölçüm: İlk Nokta'; canvas.style.cursor = 'crosshair';
        measurementStartPoint = null; hoveredAircraftForMeasure = null; hoveredRunwayCenterForMeasure = false;
        isPlacingAircraft = false; addAircraftButton.classList.remove('placing'); addAircraftButton.textContent = 'Uçak Ekle';
        addAircraftForm.style.display = 'none'; pendingAircraftLocation = null; selectedAircraft = null; popup.style.display = 'none';
        document.querySelectorAll('.aircraft-label.selected').forEach(el => el.classList.remove('selected'));
        updateTopCenterButtonStates(); if (tempMeasurementLabel) tempMeasurementLabel.style.display = 'none';
        if(runwayCenterHoverText) runwayCenterHoverText.style.display = 'none';
    } else {
        measureButton.classList.remove('measuring'); measureButton.textContent = 'Ölçüm Yap'; canvas.style.cursor = isPlacingAircraft ? 'crosshair' : 'grab';
        measurementStartPoint = null; hoveredAircraftForMeasure = null; hoveredRunwayCenterForMeasure = false;
        if (tempMeasurementLabel) tempMeasurementLabel.style.display = 'none';
    }
});
addAircraftButton.addEventListener('click', () => {
    if (isPlacingAircraft) {
        isPlacingAircraft = false; canvas.style.cursor = 'grab'; addAircraftButton.classList.remove('placing'); addAircraftButton.textContent = 'Uçak Ekle'; pendingAircraftLocation = null;
    } else {
        isPlacingAircraft = true; canvas.style.cursor = 'crosshair'; addAircraftButton.classList.add('placing'); addAircraftButton.textContent = 'Yer Seç (İptal Et)';
        isMeasuring = false; measureButton.classList.remove('measuring'); measureButton.textContent = 'Ölçüm Yap';
        measurementStartPoint = null; hoveredAircraftForMeasure = null; hoveredRunwayCenterForMeasure = false;
        selectedAircraft = null; popup.style.display = 'none'; addAircraftForm.style.display = 'none'; pendingAircraftLocation = null;
        document.querySelectorAll('.aircraft-label.selected').forEach(el => el.classList.remove('selected'));
        updateTopCenterButtonStates(); if (tempMeasurementLabel) tempMeasurementLabel.style.display = 'none';
        if(runwayCenterHoverText) runwayCenterHoverText.style.display = 'none';
    }
});
inputType.addEventListener('change', function() {
    const selectedType = this.value; if (defaultAircraftSpeeds[selectedType]) inputSpeed.value = defaultAircraftSpeeds[selectedType];
});
submitNewAircraftBtn.addEventListener('click', () => {
    formErrorDiv.textContent = ''; const callsign = inputCallsign.value.trim().toUpperCase(); const type = inputType.value;
    const heading = parseInt(inputHeading.value); const speed = parseInt(inputSpeed.value);
    const altitudeFL = parseInt(inputAltitude.value); const altitude = altitudeFL * 100;
    const departureFLValue = inputDepartureFL.value.trim(); const departureFL = departureFLValue ? parseInt(departureFLValue) : null;
    let errorMsg = '';
    if (!callsign) errorMsg = 'Çağrı adı boş olamaz.';
    else if (callsign.length > 7) errorMsg = 'Çağrı adı en fazla 7 karakter olabilir.';
    else if (aircrafts.some(ac => ac.id === callsign)) errorMsg = 'Bu çağrı adı zaten kullanılıyor.';
    else if (!type) errorMsg = 'Uçak tipi seçilmelidir.';
    else if (isNaN(heading) || heading < 0 || heading > 359) errorMsg = 'Geçersiz yön (0-359).';
    else if (isNaN(speed) || speed < 100 || speed > 600) errorMsg = 'Geçersiz hız (100-600 kts).';
    else if (isNaN(altitudeFL) || altitude < 1000 || altitude > 45000) errorMsg = 'Geçersiz irtifa (FL010-FL450).';
    else if (departureFL !== null && (isNaN(departureFL) || departureFL < 10 || departureFL > 450)) errorMsg = 'Geçersiz tırmanış FL (FL010-FL450).';
    else if (!pendingAircraftLocation) errorMsg = 'Uçak konumu belirlenmemiş.';
    if (errorMsg) { formErrorDiv.textContent = errorMsg; return; }
    const newAircraft = {
        id: callsign, x: pendingAircraftLocation.x, y: pendingAircraftLocation.y, heading: heading, targetHeading: heading, speedKTS: speed, altitude: altitude, targetAltitude: altitude,
        rateOfDescent: 0, rateOfClimb: 0,showTrajectory: false, isTakingOff: false, takeoffRunway: null, isIntercepting: false, isHandedOffToTower: false, showVector: false, labelElement: null, labelX: 0, labelY: 0, labelDragged: false,
        bankAngle: 0, maxBankAngle: 25, commandedTurnDirection: 0, turning: false, type: type, departureTargetFL: departureFL, showInfoPanel: false,
        draggedLabelDeltaX: 0, draggedLabelDeltaY: 0, lastHeadingUpdateTime: 0, initialPosSet: true
    };
    aircrafts.push(newAircraft); addAircraftForm.style.display = 'none'; pendingAircraftLocation = null;
    inputCallsign.value = ''; inputType.value = aircraftTypes[0] || ''; inputHeading.value = '';
    inputSpeed.value = defaultAircraftSpeeds[inputType.value] || ''; inputAltitude.value = ''; inputDepartureFL.value = '';
});
cancelNewAircraftBtn.addEventListener('click', () => {
    addAircraftForm.style.display = 'none'; pendingAircraftLocation = null;
    if (addAircraftButton.classList.contains('placing')) { isPlacingAircraft = false; canvas.style.cursor = 'grab'; addAircraftButton.classList.remove('placing'); addAircraftButton.textContent = 'Uçak Ekle'; }
    inputCallsign.value = ''; inputType.value = aircraftTypes[0] || ''; inputHeading.value = '';
    inputSpeed.value = defaultAircraftSpeeds[inputType.value] || ''; inputAltitude.value = ''; inputDepartureFL.value = ''; formErrorDiv.textContent = '';
});
speedButton.addEventListener('click', () => { speedControlContainer.style.display = speedControlContainer.style.display === 'block' ? 'none' : 'block'; });
// speedSlider event listener zaten en başta tanımlı.

playPauseButton.addEventListener('click', () => {
    isPaused = !isPaused; // Duraklatma durumunu tersine çevir
    playPauseButton.textContent = isPaused ? 'Oynat' : 'Durdur'; // Buton metnini güncelle
    playPauseButton.classList.toggle('paused', isPaused); // Buton stilini güncelle
    toggleTimer(isPaused); // Oyun içi zamanlayıcıyı (elapsedTime) duraklat/başlat

    if (isPaused) {
        // Oyun ŞİMDİ DURAKLATILIYOR
        if (animationFrameId) {
            cancelAnimationFrame(animationFrameId); // Mevcut animasyon karesi isteğini iptal et
            animationFrameId = null; // Oyun döngüsünün durduğunu belirtmek için null yap
        }
    } else {
        // Oyun ŞİMDİ DEVAM ETTİRİLİYOR
        lastTime = performance.now(); // 'lastTime'ı şu anki zamana ayarla. Bu, büyük deltaTime sıçramasını önler.
        if (!animationFrameId) { // Eğer oyun döngüsü durmuşsa (ki duraklatınca durmalı)
            // Oyun döngüsünü yeniden başlat. gameLoop kendi içinde bir sonraki frame için animationFrameId'yi ayarlar.
            gameLoop(performance.now());
        }
    }
});


takeoffButton.addEventListener('click', () => { takeoffOptionsContainer.style.display = takeoffOptionsContainer.style.display === 'flex' ? 'none' : 'flex'; });
document.querySelectorAll('.takeoff-option-btn.runway-btn').forEach(btn => {
    btn.addEventListener('click', function() {
        const runway = this.dataset.runway; const select = this.parentElement.querySelector('.waypoint-select');
        const waypointName = select.value || null; if (!waypointName) { alert('Lütfen bir waypoint seçin!'); return; }
        launchAircraft(runway, waypointName); takeoffOptionsContainer.style.display = 'none';
    });
});
// interceptButton033 için Event Listener
// interceptButton033 için Event Listener (MODİFİYE EDİLMİŞ)
// interceptButton033 için Event Listener (İSTEĞİNİZE GÖRE MODİFİYE EDİLMİŞ)
interceptButton033.addEventListener('click', () => {
    if (selectedAircraft && !interceptButton033.disabled) {
        if (selectedAircraft.isIntercepting && selectedAircraft.interceptCourse === INTERCEPT_TARGET_COURSE_033) {
            // Mevcut intercept'i iptal et
            selectedAircraft.isIntercepting = false;
            selectedAircraft.interceptCourse = null;
            selectedAircraft.turning = false; // İptal edildiğinde dönüşü de durdurabiliriz
            console.log(`${selectedAircraft.id} intercept to LOC 033 CANCELLED by user.`);
        } else {
            // Yeni intercept başlat: Mevcut başıyla devam et
            selectedAircraft.isIntercepting = true;
            selectedAircraft.interceptCourse = INTERCEPT_TARGET_COURSE_033;
            selectedAircraft.isHandedOffToTower = false;

            // Uçağın mevcut başını hedef başı olarak ayarla ve dönüşü durdur (düz uçması için)
            selectedAircraft.targetHeading = Math.round(selectedAircraft.heading);
            selectedAircraft.turning = false;
            selectedAircraft.commandedTurnDirection = 0; // Önceki komutlu dönüşü sıfırla

            console.log(`${selectedAircraft.id} INTERCEPTING LOC ${INTERCEPT_TARGET_COURSE_033}. Continuing on current heading: ${Math.round(selectedAircraft.heading)}°`);
        }
        updateTopCenterButtonStates();
        if (popup) popup.style.display = 'none';
    }
});

// interceptButton21L için Event Listener (İSTEĞİNİZE GÖRE MODİFİYE EDİLMİŞ)
interceptButton21L.addEventListener('click', () => {
    if (selectedAircraft && !interceptButton21L.disabled) {
        if (selectedAircraft.isIntercepting && selectedAircraft.interceptCourse === INTERCEPT_TARGET_COURSE_21L) {
            selectedAircraft.isIntercepting = false;
            selectedAircraft.interceptCourse = null;
            selectedAircraft.turning = false;
            console.log(`${selectedAircraft.id} intercept to LOC 21L CANCELLED by user.`);
        } else {
            selectedAircraft.isIntercepting = true;
            selectedAircraft.interceptCourse = INTERCEPT_TARGET_COURSE_21L;
            selectedAircraft.isHandedOffToTower = false;

            selectedAircraft.targetHeading = Math.round(selectedAircraft.heading);
            selectedAircraft.turning = false;
            selectedAircraft.commandedTurnDirection = 0;

            console.log(`${selectedAircraft.id} INTERCEPTING LOC ${INTERCEPT_TARGET_COURSE_21L}. Continuing on current heading: ${Math.round(selectedAircraft.heading)}°`);
        }
        updateTopCenterButtonStates();
        if (popup) popup.style.display = 'none';
    }
});
towerButton.addEventListener('click', () => {
    if (selectedAircraft && !towerButton.disabled) {
        if (selectedAircraft.isHandedOffToTower) selectedAircraft.isHandedOffToTower = false;
        else { selectedAircraft.isHandedOffToTower = true; selectedAircraft.isIntercepting = false; selectedAircraft.commandedTurnDirection = 0; }
        updateTopCenterButtonStates(); popup.style.display = 'none';
    }
});
removeButton.addEventListener('click', () => {
    if (selectedAircraft && !removeButton.disabled) {
        const indexToRemove = aircrafts.findIndex(ac => ac.id === selectedAircraft.id);
        if (indexToRemove > -1) {
            if (selectedAircraft.labelElement) selectedAircraft.labelElement.remove();
            aircrafts.splice(indexToRemove, 1); selectedAircraft = null;
            updateTopCenterButtonStates(); popup.style.display = 'none';
        }
    }
});

function updateTopCenterButtonStates() {
    const btn033 = document.getElementById('interceptButton033');
    const btn21L = document.getElementById('interceptButton21L');
    const indicator033 = btn033 ? btn033.querySelector('.intercept-indicator') : null;
    const indicator21L = btn21L ? btn21L.querySelector('.intercept-indicator') : null;
    const towerBtn = document.getElementById('towerButton');
    const removeBtn = document.getElementById('removeButton');

    let canEnable033ConditionsMet = false;
    let canEnable21LConditionsMet = false;
    let canEnableTower = false;
    let canRemove = false;

    if (selectedAircraft) {
        canRemove = true; // Uçak seçiliyse her zaman kaldırılabilir.

        // Intercept butonları için mesafe kontrolleri (mevcut kodunuzdaki gibi)
        const loc033Rad_btn = toRadians(INTERCEPT_TARGET_COURSE_033);
        const lineEnd033X_btn = WORLD_ORIGIN_X + Math.sin(loc033Rad_btn) * nmToWorldPixels(localizerLengthNM + 5);
        const lineEnd033Y_btn = WORLD_ORIGIN_Y - Math.cos(loc033Rad_btn) * nmToWorldPixels(localizerLengthNM + 5);
        const distToLocLine033NM = worldPixelsToNm(pointLineDistance(selectedAircraft.x, selectedAircraft.y, WORLD_ORIGIN_X, WORLD_ORIGIN_Y, lineEnd033X_btn, lineEnd033Y_btn));

        const loc21LRad_btn = toRadians(INTERCEPT_TARGET_COURSE_21L);
        const lineEnd21LX_btn = WORLD_ORIGIN_X + Math.sin(loc21LRad_btn) * nmToWorldPixels(localizerLengthNM + 5);
        const lineEnd21LY_btn = WORLD_ORIGIN_Y - Math.cos(loc21LRad_btn) * nmToWorldPixels(localizerLengthNM + 5);
        const distToLocLine21LNM = worldPixelsToNm(pointLineDistance(selectedAircraft.x, selectedAircraft.y, WORLD_ORIGIN_X, WORLD_ORIGIN_Y, lineEnd21LX_btn, lineEnd21LY_btn));

        // Yeni baş açısı kontrolleri
        const headingOKFor033 = isHeadingInRange(selectedAircraft.heading, 349, 76);
        const headingOKFor21L = isHeadingInRange(selectedAircraft.heading, 169, 256);

        const distOKFor033 = distToLocLine033NM <= INTERCEPT_MAX_DIST_NM; // INTERCEPT_MAX_DIST_NM sabitiniz olmalı
        const distOKFor21L = distToLocLine21LNM <= INTERCEPT_MAX_DIST_NM;

        if (!selectedAircraft.isHandedOffToTower) {
            // Intercept 033 için koşullar
            if (selectedAircraft.isIntercepting && selectedAircraft.interceptCourse === INTERCEPT_TARGET_COURSE_033) {
                canEnable033ConditionsMet = true; // Aktif intercept'i iptal edebilmesi için
            } else if (!(selectedAircraft.isIntercepting && selectedAircraft.interceptCourse === INTERCEPT_TARGET_COURSE_21L)) { // Diğer LOC'a intercept etmiyorsa
                if (distOKFor033 && headingOKFor033) {
                    canEnable033ConditionsMet = true;
                }
            }

            // Intercept 21L için koşullar
            if (selectedAircraft.isIntercepting && selectedAircraft.interceptCourse === INTERCEPT_TARGET_COURSE_21L) {
                canEnable21LConditionsMet = true; // Aktif intercept'i iptal edebilmesi için
            } else if (!(selectedAircraft.isIntercepting && selectedAircraft.interceptCourse === INTERCEPT_TARGET_COURSE_033)) { // Diğer LOC'a intercept etmiyorsa
                if (distOKFor21L && headingOKFor21L) {
                    canEnable21LConditionsMet = true;
                }
            }

            // Tower butonu: Herhangi bir intercept komutu verildiyse (isIntercepting veya interceptCourse doluysa) aktifleşir
            if (selectedAircraft.isIntercepting || selectedAircraft.interceptCourse !== null) {
                canEnableTower = true;
            }
        }

        // Eğer uçak zaten kuleye devredilmişse, Tower butonu "devri geri al" işlevi için aktif kalır.
        if (selectedAircraft.isHandedOffToTower) {
            canEnableTower = true;
        }

        if (towerBtn) towerBtn.classList.toggle('handed-off', selectedAircraft.isHandedOffToTower);

    } else { // Seçili uçak yoksa tüm butonlar pasif
        canEnable033ConditionsMet = false;
        canEnable21LConditionsMet = false;
        canEnableTower = false;
        canRemove = false;
        if (towerBtn) towerBtn.classList.remove('handed-off');
    }

    // Butonların disabled durumlarını ayarla
    if (btn033 && indicator033) {
        btn033.disabled = !canEnable033ConditionsMet;
        btn033.classList.toggle('intercepting', selectedAircraft && selectedAircraft.isIntercepting && selectedAircraft.interceptCourse === INTERCEPT_TARGET_COURSE_033);
        indicator033.textContent = (selectedAircraft && selectedAircraft.isIntercepting && selectedAircraft.interceptCourse === INTERCEPT_TARGET_COURSE_033) ? '✓' : '';
    }
    if (btn21L && indicator21L) {
        btn21L.disabled = !canEnable21LConditionsMet;
        btn21L.classList.toggle('intercepting', selectedAircraft && selectedAircraft.isIntercepting && selectedAircraft.interceptCourse === INTERCEPT_TARGET_COURSE_21L);
        indicator21L.textContent = (selectedAircraft && selectedAircraft.isIntercepting && selectedAircraft.interceptCourse === INTERCEPT_TARGET_COURSE_21L) ? '✓' : '';
    }
    if (towerBtn) towerBtn.disabled = !canEnableTower;
    if (removeBtn) removeBtn.disabled = !canRemove;
}



// --- Global veya Erişilebilir Kapsamda Olması Gerekenler ---
// const WORLD_ORIGIN_X = 0; // Sabit dünya merkezi X
// const WORLD_ORIGIN_Y = 0; // Sabit dünya merkezi Y
// let departureCounter = 0;   // Kalkan uçaklara benzersiz ID vermek için sayaç
// const aircraftTypes = ['A320', 'B737', /* ... diğer uçak tipleri ... */];
// const defaultAircraftSpeeds = { /* ... uçak tiplerine göre hızlar ... */ }; // Bu fonksiyon içinde doğrudan kullanılmıyor ama referans olabilir
// const aircraftPerformanceROC = { 'A320': 2500, 'B737': 2500, /* ... diğerleri ... */ }; // Ayak/dakika cinsinden tırmanma oranları
// const DEFAULT_CLIMB_RATE = 2000; // ft/min, eğer uçak tipi için özel bir değer yoksa
// let aircrafts = []; // Oyundaki tüm uçakları tutan dizi

// Pist başlarını tutan sabitler (kodunuzdaki tanımlamalara göre güncelleyin)
// const RUNWAY_HEADING_03R = 33; // Örnek: 03R pistinin manyetik başı
// const RUNWAY_HEADING_21L = 213; // Örnek: 21L pistinin manyetik başı
// Veya intercept kurslarını kullanabilirsiniz eğer bunlar pist başlarıyla aynıysa:
// const INTERCEPT_TARGET_COURSE_033 = 33;
// const INTERCEPT_TARGET_COURSE_21L = 213;

// Yardımcı fonksiyonlar (tanımlı olmalı)
// function formatFlightLevel(altitude) { /* ... */ } (konsol logu için)


function launchAircraft(runway, waypointName) {
    departureCounter++;
    // Çağrı adı için daha benzersiz bir yapı (isteğe bağlı)
    const randomPrefix = callsignPrefixes && callsignPrefixes.length > 0 ? callsignPrefixes[Math.floor(Math.random() * callsignPrefixes.length)] : "DEP";
    const callsign = `${randomPrefix}${700 + departureCounter}`; // Örn: THY701, PGT702

    const type = aircraftTypes[Math.floor(Math.random() * aircraftTypes.length)];
    const initialSpeedKTS = 160; // Kalkış için tipik başlangıç hızı (knot)
    const initialAltitudeFeet = 0; // Yerden başlar (pist seviyesi)

    // Kalkış sonrası tırmanılacak hedef Uçuş Seviyesi (FL)
    // Bu değer daha dinamik veya kullanıcı tarafından seçilebilir olabilir.
    const possibleTargetFLs = [180, 190, 200, 210, 220, 230, 240, 250, 260, 270, 280]; // Örnek FL'ler
    const selectedTargetFL = possibleTargetFLs[Math.floor(Math.random() * possibleTargetFLs.length)];
    const targetAltitudeFeet = selectedTargetFL * 100; // Feet'e çevir

    const climbRate = (aircraftPerformanceROC && aircraftPerformanceROC[type]) ? aircraftPerformanceROC[type] : DEFAULT_CLIMB_RATE;

    let initialHeading;
    // Pist adına göre doğru kalkış başını belirle
    // INTERCEPT_TARGET_COURSE_XXX değişkenlerinizin pist başlarını temsil ettiğini varsayıyoruz.
    if (runway === '03R') {
        initialHeading = typeof INTERCEPT_TARGET_COURSE_033 !== 'undefined' ? INTERCEPT_TARGET_COURSE_033 : 33;
    } else if (runway === '21L') {
        initialHeading = typeof INTERCEPT_TARGET_COURSE_21L !== 'undefined' ? INTERCEPT_TARGET_COURSE_21L : 213;
    } else {
        // Bilinmeyen pist adı için varsayılan bir baş veya hata yönetimi
        initialHeading = typeof INTERCEPT_TARGET_COURSE_033 !== 'undefined' ? INTERCEPT_TARGET_COURSE_033 : 33; // Varsayılan olarak birini ata
        console.warn(`launchAircraft: Bilinmeyen pist adı "${runway}". Varsayılan baş ${initialHeading}° kullanılıyor.`);
    }

    const newAircraft = {
        id: callsign,
        x: WORLD_ORIGIN_X, // Kalkış pozisyonu: Pistin merkezi (dünya (0,0)'ı veya tanımladığınız origin)
        y: WORLD_ORIGIN_Y,
        heading: initialHeading,          // Pist başı
        targetHeading: initialHeading,    // Başlangıçta pist başında devam eder
        speedKTS: initialSpeedKTS,
        altitude: initialAltitudeFeet,
        targetAltitude: targetAltitudeFeet, // Hedef irtifa
        rateOfDescent: 0,
        rateOfClimb: climbRate,           // Ayarlanan tırmanma oranı
        isTakingOff: true,                // Kalkış durumunda
        takeoffRunway: runway,            // Hangi pistten kalktığı bilgisi
        isIntercepting: false,
        isHandedOffToTower: false,
        showVector: false,                // Hız vektörü başlangıçta kapalı olabilir
        labelElement: null,               // DOM etiketi daha sonra oluşturulur
        labelX: 0, labelY: 0, labelDragged: false,
        bankAngle: 0, maxBankAngle: 25,   // Standart yatış limiti
        commandedTurnDirection: 0, turning: false,
        type: type,
        departureTargetFL: selectedTargetFL, // Kalkış SID'i veya tırmanış için hedef FL
        showInfoPanel: false,             // Bilgi paneli başlangıçta kapalı
        draggedLabelDeltaX: 0, draggedLabelDeltaY: 0,
        lastHeadingUpdateTime: 0,         // Dönüş hesaplamaları için
        initialPosSet: true,              // Dünya koordinatları doğrudan ayarlandığı için true
		showTrajectory: false,
        targetWaypoint: waypointName || null // Kalkış sonrası yöneleceği ilk waypoint (isteğe bağlı)
    };

    aircrafts.push(newAircraft); // Uçağı ana listeye ekle

    // Konsola bilgi logla (isteğe bağlı)
    console.log(`MANUEL KALKIŞ: ${newAircraft.id} (${newAircraft.type}) pist ${runway} -> ${waypointName || 'SID'}. Hedef: ${formatFlightLevel ? formatFlightLevel(targetAltitudeFeet) : `FL${selectedTargetFL}`}. Hız: ${initialSpeedKTS}kts. Tırmanma: ${climbRate}ft/min.`);

    // Gerekirse UI'ı güncelle (örneğin, seçili uçağı bu yeni uçak yap)
    // selectedAircraft = newAircraft;
    // updateTopCenterButtonStates(); // Buton durumlarını güncelle
}

let animationFrameId = null;
function gameLoop(currentTime) {
    animationFrameId = requestAnimationFrame(gameLoop);
    if (isPaused) {
        // lastTime = currentTime; // Duraklatıldığında lastTime'ı güncellemeye devam etme
        return; // Eğer duraklatılmışsa, çizim ve güncelleme yapma
    }
    const deltaTime = (currentTime - lastTime) / 1000; // Saniye cinsinden
    lastTime = currentTime;
    updateAircrafts(deltaTime);
    drawRadar();
}

// --- Global veya Erişilebilir Kapsamda Olması Gerekenler ---
// const canvas = document.getElementById('radar');
// const ctx = canvas.getContext('2d');
// const inputType = document.getElementById('acType');
// const inputSpeed = document.getElementById('acSpeed');
// const vectorToggle = document.getElementById('vectorToggle');
// const btnLoc21L = document.getElementById('showLocalizer21L'); // Kodunuzda "showLocalizer21L" ID'li eleman
// const btnLocRight = document.getElementById('showLocalizer033Right'); // Kodunuzda "showLocalizer033Right" ID'li eleman
// const speedSlider = document.getElementById('speedSlider');
// const speedButton = document.getElementById('speedButton');
// const playPauseButton = document.getElementById('playPauseButton');
// const tempMeasurementLabel = document.getElementById('tempMeasurementLabel');
// const takeoffOptionsContainer = document.getElementById('takeoffOptionsContainer');
// const generateScenarioBtn = document.getElementById('generateScenarioBtn');
// const selectRunway03RBtn = document.getElementById('selectRunway03RBtn');
// const selectRunway21LBtn = document.getElementById('selectRunway21LBtn');
// const cancelRunwaySelectionBtn = document.getElementById('cancelRunwaySelectionBtn');

// const aircraftTypes = ['C130', /* ... diğer tipler ... */];
// const defaultAircraftSpeeds = { 'C130': 230, /* ... diğer hızlar ... */ };
// const speedMultipliers = [0.25, 0.5, 0.75, 1, 1.25, 1.5, 2, 3, 5, 10];

// let canvasWidth, canvasHeight, centerX, centerY; // resizeCanvas tarafından ayarlanır
// let zoom = 1.0; // Başlangıç zoom değeri
// let panX = 0; // BU DEĞER initializeApp içinde AYARLANACAK
// let panY = 0; // BU DEĞER initializeApp içinde AYARLANACAK
// const WORLD_ORIGIN_X = 0; // Sabit dünya merkezi X
// const WORLD_ORIGIN_Y = 0; // Sabit dünya merkezi Y

// let showVectors = false;
// let showLocalizerLeft = false; // btnLoc21L'nin başlangıç durumu
// let showLocalizerRight = false; // btnLocRight'ın başlangıç durumu
// let gameSpeedMultiplier = 1.0; // Başlangıç oyun hızı
// let isPaused = false; // Oyunun başlangıçta duraklatılıp duraklatılmadığı
// let lastTime;
// let animationFrameId = null;

// Fonksiyonlar (resizeCanvas, updateTopCenterButtonStates, startGameTimer, gameLoop, vs. tanımlı olmalı)
// function resizeCanvas() { /* ... */ }
// function updateTopCenterButtonStates() { /* ... */ }
// function startGameTimer() { /* ... */ }
// function gameLoop(currentTime) { /* ... */ }
// function showRunwaySelection() { /* ... */ }
// function initializeScenarioGeneration(runway) { /* ... */ }
// function hideRunwaySelection() { /* ... */ }

function initializeAirIndicator() {
    airIndicatorWindow = document.getElementById('airIndicatorWindow');
    aiCallsign = document.getElementById('aiCallsign');
    aiSpeedValue = document.getElementById('aiSpeedValue');
    aiRodValue = document.getElementById('aiRodValue');
    aiHeadingValue = document.getElementById('aiHeadingValue');

    if (!airIndicatorWindow || !aiCallsign || !aiSpeedValue || !aiRodValue || !aiHeadingValue) {
        console.error("Air Indicator elementlerinden biri bulunamadı!");
        return;
    }

    const header = airIndicatorWindow.querySelector('.air-indicator-header');
    if (header) {
        header.addEventListener('mousedown', (e) => {
            if (e.button !== 0) return; // Sadece sol tıkla sürükle
            isDraggingAirIndicator = true;
            airIndicatorDragOffsetX = e.clientX - airIndicatorWindow.offsetLeft;
            airIndicatorDragOffsetY = e.clientY - airIndicatorWindow.offsetTop;
            header.style.cursor = 'grabbing';
            e.preventDefault(); // Metin seçilmesini veya diğer varsayılan olayları engelle
        });
    }

    document.addEventListener('mousemove', (e) => {
        if (isDraggingAirIndicator) {
            let newX = e.clientX - airIndicatorDragOffsetX;
            let newY = e.clientY - airIndicatorDragOffsetY;

            // Pencerenin ekran dışına çıkmasını engelle (isteğe bağlı)
            const maxX = window.innerWidth - airIndicatorWindow.offsetWidth;
            const maxY = window.innerHeight - airIndicatorWindow.offsetHeight;
            newX = Math.max(0, Math.min(newX, maxX));
            newY = Math.max(0, Math.min(newY, maxY));

            airIndicatorWindow.style.left = `${newX}px`;
            airIndicatorWindow.style.top = `${newY}px`;
        }
    });

    document.addEventListener('mouseup', (e) => {
        if (isDraggingAirIndicator) {
            isDraggingAirIndicator = false;
            if (header) header.style.cursor = 'grab';
        }
    });

    // Tıklanabilir değer alanlarına olay dinleyicileri ekle
    [aiSpeedValue, aiRodValue, aiHeadingValue].forEach(el => {
        el.addEventListener('click', (e) => {
            if (selectedAircraft) {
                const field = e.currentTarget.dataset.field;
                if (field && typeof showPopupForField === "function") {
                    // Popup'ın Air Indicator'a yakın açılması için koordinatları ayarla
                    const rect = airIndicatorWindow.getBoundingClientRect();
                    let popupX = rect.right + 10;
                    let popupY = rect.top;
                    if (popupX + 160 > window.innerWidth) { // Popup genişliği (160px)
                        popupX = rect.left - 160 - 10;
                    }
                    showPopupForField(popupX, popupY, field);
                }
            }
        });
    });
}




function initializeApp() {
    // Uçak Tipi dropdown'ını doldur
    const typeDropdown = document.getElementById('acType'); // inputType ile aynı eleman olmalı
    if (typeDropdown) {
        aircraftTypes.forEach(type => {
            const option = document.createElement('option');
            option.value = type;
            option.textContent = type;
            typeDropdown.appendChild(option);
        });
        if (aircraftTypes.length > 0) {
            typeDropdown.value = aircraftTypes[0]; // Varsayılan tipi seç
            if (inputSpeed && defaultAircraftSpeeds[aircraftTypes[0]]) {
                inputSpeed.value = defaultAircraftSpeeds[aircraftTypes[0]]; // Varsayılan hızı ayarla
            }
        }
    }

    // Pencere yeniden boyutlandırma olayını dinle
    window.addEventListener('resize', resizeCanvas);

    // Canvas'ı ilk kez boyutlandır ve panX/panY için canvasWidth/Height değerlerini al
    resizeCanvas();

    // DEĞİŞİKLİK: panX ve panY'yi WORLD_ORIGIN'i merkeze alacak şekilde ayarla
    // Bu, dünya (WORLD_ORIGIN_X, WORLD_ORIGIN_Y)'nin ekranın (canvasWidth/2, canvasHeight/2)'sine gelmesini sağlar.
    // Eğer WORLD_ORIGIN_X ve WORLD_ORIGIN_Y sıfır ise ve zoom 1.0 ise,
    // panX = canvasWidth / 2 ve panY = canvasHeight / 2 olur.
    // Bu, dünya (0,0)'ının ekranın tam ortasına yerleşeceği anlamına gelir.
    panX = (canvasWidth / 2) - (WORLD_ORIGIN_X * zoom);
    panY = (canvasHeight / 2) - (WORLD_ORIGIN_Y * zoom);

    // UI elemanlarının başlangıç durumlarını ayarla
    if (vectorToggle) {
        vectorToggle.classList.toggle('active', showVectors);
        vectorToggle.textContent = `Speed Vector: ${showVectors ? 'AÇIK' : 'KAPALI'}`;
    }
    if (btnLoc21L) { // showLocalizer21L ID'li buton
        btnLoc21L.classList.toggle('active', showLocalizerLeft);
    }
    if (btnLocRight) { // showLocalizer033Right ID'li buton
        btnLocRight.classList.toggle('active', showLocalizerRight);
    }
    if (typeof updateTopCenterButtonStates === "function") {
         updateTopCenterButtonStates(); // Seçili uçak yokken butonları devre dışı bırakır
    }


    // Hız kaydırıcısı ve butonu
    if (speedSlider && speedButton) {
        const initialSpeedIndex = speedMultipliers.findIndex(s => s === gameSpeedMultiplier);
        speedSlider.value = initialSpeedIndex !== -1 ? initialSpeedIndex : 3; // 1x hız için index 3 (0-tabanlı)
        speedButton.textContent = `Hız: ${gameSpeedMultiplier}x`;
        if (speedValueSpan) { // speedValueSpan varsa onu da güncelle
             speedValueSpan.textContent = `${gameSpeedMultiplier}x`;
        }
    }

    // Oynat/Durdur butonu
    if (playPauseButton) {
        playPauseButton.textContent = isPaused ? 'Oynat' : 'Durdur';
        playPauseButton.classList.toggle('paused', isPaused);
    }

    // Geçici ölçüm etiketi ve kalkış seçenekleri
    if (tempMeasurementLabel) {
        tempMeasurementLabel.style.display = 'none';
    }
    if (takeoffOptionsContainer) {
        takeoffOptionsContainer.style.display = 'none';
    }

    // Senaryo üretme butonları için olay dinleyicileri
    if (generateScenarioBtn && typeof showRunwaySelection === "function") {
        generateScenarioBtn.addEventListener('click', showRunwaySelection);
    }
    if (selectRunway03RBtn && typeof initializeScenarioGeneration === "function") {
        selectRunway03RBtn.addEventListener('click', () => { initializeScenarioGeneration('03R'); });
    }
    if (selectRunway21LBtn && typeof initializeScenarioGeneration === "function") {
        selectRunway21LBtn.addEventListener('click', () => { initializeScenarioGeneration('21L'); });
    }
    if (cancelRunwaySelectionBtn && typeof hideRunwaySelection === "function") {
        cancelRunwaySelectionBtn.addEventListener('click', () => { hideRunwaySelection(); });
    }

    // Oyun zamanlayıcısını ve döngüsünü başlat
    lastTime = performance.now();
    if (typeof startGameTimer === "function") {
        startGameTimer(); // Oyun içi zamanı (elapsedTime) başlatır/günceller
    }

    if (!isPaused && typeof gameLoop === "function") { // Sadece duraklatılmamışsa başlat
        gameLoop(lastTime); // Oyun döngüsünü başlat
    } else if (isPaused && typeof drawRadar === "function") {
        // Eğer oyun duraklatılmışsa, en azından ilk radar görüntüsünü çiz
        // Bu, updateAircrafts olmadan statik bir çizim yapar.
        // Ya da gameLoop'un içinden çağrılmasını bekleyebilirsiniz.
        // Şimdilik, gameLoop'un bu durumu yönettiğini varsayalım.
        // Eğer gameLoop duraklatılmışken hiçbir şey çizmiyorsa,
        // ve başlangıçta bir şeylerin görünmesi gerekiyorsa, buraya bir drawRadar() eklenebilir.
        // Ancak, mevcut gameLoop yapınız muhtemelen duraklatılmışken en az bir kez çizecektir veya
        // duraklatılmamış durumda ilk frame'i çizecektir.
    }
	initializeAirIndicator();
	displayInfoPopup();
}



// --- Bilgilendirme Pop-up Mantığı ---

// Pop-up içeriğini bu obje üzerinden kolayca değiştirebilirsiniz
const infoPopupDetails = {
    version: "1.0.2", // Pop-up içeriği her değiştiğinde bu versiyonu artırın
    title: "Radar Simülasyonuna Hoş Geldiniz!",
    messageHTML: `
        <p><strong>Temel Amaçlar:</strong></p>
        <ul>
            <li>Uçakları localizer (LOC) hatlarına yönlendirerek piste yaklaştırın.</li>
            <li>Kuleye devir için uygun mesafede ve irtifada olduklarından emin olun.</li>
            <li>Uçaklar arasında güvenli mesafeyi (yatay ve dikey) koruyun! (Airmiss uyarısına dikkat!)</li>
        </ul>
        <p><strong>Son Güncellemeler (18 Mayıs 2025):  MUTLAKA OKUYUNUZ!!!</strong></p>
        <ul>
		    <li>Uçaklar waypointlere doğru açılarla gelip waypointten sonra IAF'ye doğru açı ile dönüyorlar örneğin TELVO 349</li>
            <li>Artık eğer farenizde forward tuşu varsa (nitadaki ölçüm yapmaya yarayan tuş) bu tuşu kullanarak ölçümü başlatabilirsiniz.</li>
            <li>Kalkış yapan uçaklar için "LTXX" trajektör gösterimi eklendi LTXX'e basarak kalkış uçaklarının trajectory'sini açıp kapatabilirsiniz.</li>
			<li>Tam ekran butonuna istediğiniz zaman basabilirsiniz. Uçaklar küçük ekrandan tam ekrana geçerken artık pozisyon değiştirmiyor.</li>
        </ul>
        <p>Geri bildirimleriniz ve önerileriniz bizim için çok değerli. İyi eğlenceler dileriz!</p>
    `
};

function displayInfoPopup() {
    // console.log("[displayInfoPopup] Fonksiyon başlatıldı."); // Test için log
    const popupOverlay = document.getElementById('infoPopupOverlay');
    const popupTitleEl = document.getElementById('infoPopupTitle');
    const popupMessageEl = document.getElementById('infoPopupMessage');
    const popupCloseBtn = document.getElementById('infoPopupCloseButton');

    if (!popupOverlay || !popupTitleEl || !popupMessageEl || !popupCloseBtn) {
        console.error("[displayInfoPopup] HATA: Pop-up elementlerinden biri veya birkaçı bulunamadı! HTML ID'lerini kontrol edin.");
        return;
    }
    // console.log("[displayInfoPopup] Tüm pop-up DOM elementleri bulundu.");

    // localStorage kontrolü ve kaydı kaldırıldığı için pop-up her zaman gösterilecek.

    // Pop-up içeriğini ayarla
    // infoPopupDetails objesinin en güncel halini kullanmak için,
    // eğer bu obje başka bir yerde dinamik olarak güncelleniyorsa,
    // buradaki atamadan önce güncel olduğundan emin olun.
    // Şimdilik global tanımlı olduğunu varsayıyoruz.
    // Tarih ve versiyonu dinamik olarak almak için:
    let messageContent = infoPopupDetails.messageHTML;
    // Eğer mesaj içinde dinamik yer tutucular kullanmak isterseniz (örneğin {currentDate}):
    // messageContent = messageContent.replace('{currentDate}', new Date().toLocaleDateString('tr-TR'));
    // Şimdilik infoPopupDetails içindeki statik metni kullanıyoruz ama dinamik tarih eklemesi yapıldı.
    const dynamicDateVersion = `(${new Date().toLocaleDateString('tr-TR', { day: 'numeric', month: 'long', year: 'numeric' })} - v${infoPopupDetails.version})`;
    popupTitleEl.textContent = infoPopupDetails.title;
    // Son güncellemeler başlığını dinamik hale getirelim
    popupMessageEl.innerHTML = infoPopupDetails.messageHTML.replace(
        /\(.*\s-\sv\d+\.\d+\.\d+\):/, // Örnek: (18 Mayıs 2025 - v1.0.3): gibi bir deseni bulur
        dynamicDateVersion + ":"
    );


    // console.log("[displayInfoPopup] Pop-up başlığı ve mesajı ayarlandı.");

    // Pop-up'ı göster
    popupOverlay.style.display = 'flex';
    // console.log("[displayInfoPopup] popupOverlay.style.display 'flex' olarak ayarlandı.");
    
    setTimeout(() => { // CSS geçişinin düzgün çalışması için class eklemesini küçük bir gecikmeyle yap
        popupOverlay.classList.add('visible');
        // console.log("[displayInfoPopup] 'visible' class'ı popupOverlay'e eklendi.");
    }, 20); // Küçük bir gecikme yeterli

    // Kapatma butonuna olay dinleyici ekle
    // Eğer pop-up tekrar tekrar gösteriliyorsa ve displayInfoPopup her seferinde çağrılıyorsa,
    // {once: true} kullanmak veya olay dinleyicisini eklemeden önce removeEventListener ile temizlemek iyi bir pratiktir.
    // Mevcut senaryoda, sayfa her yüklendiğinde displayInfoPopup çağrıldığı için {once:true} uygundur,
    // çünkü her sayfa yüklemesinde buton için yeni bir dinleyici (tek seferlik) eklenir.
    const closeButtonClickHandler = () => {
        // console.log("[displayInfoPopup] Kapatma butonuna tıklandı.");
        popupOverlay.classList.remove('visible');
        setTimeout(() => {
            popupOverlay.style.display = 'none';
        }, 300); // CSS transition süresiyle (0.3s) aynı olmalı
        // localStorage'a kayıt işlemi kaldırıldı.
        popupCloseBtn.removeEventListener('click', closeButtonClickHandler); // Dinleyiciyi kaldır (once:true zaten bunu yapar ama emin olmak için)
    };
    
    // Önceki dinleyiciyi kaldır (eğer varsa ve once:true kullanılmıyorsa)
    // popupCloseBtn.removeEventListener('click', closeButtonClickHandler); // Bu satıra gerek yok eğer aşağıdaki {once: true} kullanılıyorsa
    popupCloseBtn.addEventListener('click', closeButtonClickHandler, { once: true });
    // console.log("[displayInfoPopup] Kapatma butonu olay dinleyicisi eklendi.");
}

// Bu fonksiyonun initializeApp() fonksiyonunuzun sonunda veya
// sayfa yüklendikten sonra uygun bir yerde çağrıldığından emin olun.
// Örneğin:
// function initializeApp() {
//     // ... diğer initializeApp kodları ...
//     displayInfoPopup();
// }
// initializeApp();

// Bu fonksiyonu initializeApp fonksiyonunuzun sonunda veya 
// sayfa yüklendikten sonra uygun bir yerde çağırın.
// Örnek:
// document.addEventListener('DOMContentLoaded', displayInfoPopup);
// veya initializeApp içinde:

// Bu satırın zaten kodunuzda olduğunu varsayıyorum:
// const measureButton = document.getElementById('measureButton');

// Eğer measureButton henüz tanımlanmadıysa veya emin olmak isterseniz:
const measureButtonForForwardKey = document.getElementById('measureButton');

document.addEventListener('mousedown', function(event) {
    // event.button === 4 genellikle faredeki "ileri" (Forward) tuşudur.
    // (Sol tık: 0, Orta tık/tekerlek: 1, Sağ tık: 2, Geri tuşu: 3)
    if (event.button === 4) {
        if (measureButtonForForwardKey) {
            // Tarayıcının varsayılan "ileri git" eylemini engelle
            event.preventDefault();

            // "Ölçüm Yap" butonuna programatik olarak tıkla
            measureButtonForForwardKey.click();

            console.log('Fare "Forward" tuşuna basıldı, "Ölçüm Yap" tetiklendi.');
        } else {
            console.warn('Fare "Forward" tuşu için "measureButton" bulunamadı.');
        }
    }
});

// Alternatif olarak 'mouseup' olayını da dinleyebilirsiniz.
// 'mousedown' daha anlık bir tepki verir.
/*
document.addEventListener('mouseup', function(event) {
    if (event.button === 4) { // "Forward" tuşu bırakıldığında
        if (measureButtonForForwardKey) {
            event.preventDefault();
            // measureButtonForForwardKey.click(); // mousedown'de tetiklediysek burada tekrar gerek yok
                                                // ya da sadece mouseup'ta tetikleyebilirsiniz.
        }
    }
});
*/
// ÖNEMLİ: initializeApp() fonksiyonunu DOM yüklendikten sonra çağırın:
// document.addEventListener('DOMContentLoaded', initializeApp);
// Veya script'iniz body'nin sonunda ise doğrudan çağırabilirsiniz:
// initializeApp();

const generateScenarioBtn = document.getElementById('generateScenarioBtn');
if (generateScenarioBtn) generateScenarioBtn.addEventListener('click', showRunwaySelection);
if (selectRunway03RBtn) selectRunway03RBtn.addEventListener('click', () => { initializeScenarioGeneration('03R'); });
if (selectRunway21LBtn) selectRunway21LBtn.addEventListener('click', () => { initializeScenarioGeneration('21L'); });
if (cancelRunwaySelectionBtn) cancelRunwaySelectionBtn.addEventListener('click', () => { hideRunwaySelection(); });

initializeApp();
</script>














</body>
</html>
