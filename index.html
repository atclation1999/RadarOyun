<!DOCTYPE html>
<html lang="tr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Radar Yaklaşma Oyunu</title>








<style>
   
    /* Temel stiller */
    html, body { height: 100%; margin: 0; overflow: hidden; /* Kaydırma çubuklarını engelle */ background-color: #333; color: white; font-family: Arial, sans-serif; display: flex; /* Flexbox ile canvas'ı ortala */ align-items: center; /* Dikey ortala */ justify-content: center; /* Yatay ortala */ }
    canvas { display: block; /* margin: auto kaldırıldı */ background: rgba(160, 160, 160, 0.5); cursor: grab; /* max-width/height kaldırıldı, JS ile ayarlanacak */ border: none; /* Kenarlık olmadığından emin ol */ }
    button { cursor: pointer; } /* Genel buton stili */

    /* Kontrol Butonları */
    .control-button { padding: 8px 15px; background: #555; border: 1px solid #0f0; color: #fff; font-weight: bold; border-radius: 3px; margin-bottom: 5px; text-align: center; z-index: 10; transition: background-color 0.2s, color 0.2s, border-color 0.2s; }
    .control-button.active { background: #0f0; color: black; }
    .control-button:disabled { background: #777; color: #aaa; border-color: #666; cursor: not-allowed; }

    /* Sol Üst Kontroller */
    #topLeftControls { position: absolute; top: 10px; left: 10px; z-index: 10; display: flex; flex-direction: column; }
    #fullscreenButton { /* control-button stilini kullanır */ }
    .loc-btn { /* control-button stilini kullanır */ }

    /* Üst Orta Kontroller */
    #topCenterControls {
        position: absolute;
        top: 10px;
        left: 50%;
        transform: translateX(-50%);
        z-index: 10;
        display: flex;
        gap: 10px; /* Butonlar arası boşluk */
    }
    #interceptButton033, #interceptButton21L { /* Ortak Intercept Buton Stili */
        background-color: #6c757d; /* Başlangıçta gri */
        border-color: #888;
    }
    #interceptButton033:not(:disabled), #interceptButton21L:not(:disabled) { /* Aktifken */
        background-color: #ffc107; /* Sarı */
        color: black;
        border-color: #ffc107;
    }
    #interceptButton033:not(:disabled):hover, #interceptButton21L:not(:disabled):hover {
        background-color: #e0a800;
        border-color: #e0a800;
    }
    #towerButton { background-color: #17a2b8; border-color: #17a2b8; }
    #towerButton.handed-off { background-color: #0d6efd; border-color: #0d6efd; } /* Kuleye devredilince farklı renk */
    #removeButton { background-color: #dc3545; border-color: #dc3545; }

    /* Sağ Üst Kontroller (Vector) */
    #vectorControls {
        position: absolute;
        top: 10px;
        right: 10px;
        display: flex;
        flex-direction: column; /* Dakika butonları dikey sıralanacak */
        gap: 5px; /* Elemanlar arasında dikey boşluk */
        z-index: 10;
    }
    #vectorToggleWrapper {
        display: flex;
        flex-direction: row; /* Timer ve vectorToggle yan yana */
        align-items: center;
        gap: 10px; /* Timer ile buton arasında boşluk */
    }
    #gameTimer {
        color: white;
        font-weight: bold;
        font-size: 14px;
        font-family: Arial, sans-serif;
        background: rgba(50, 50, 50, 0.2);
        padding: 5px 10px;
        border: 1px solid #0f0;
        border-radius: 3px;
    }
    #vectorToggle { background: #a00; color: white; }
    #vectorToggle.active { background: #0f0; color: black; }

    /* Sol Alt Kontroller */
    #bottomLeftControls { position: absolute; bottom: 10px; left: 10px; z-index: 10; display: flex; flex-direction: column; align-items: flex-start; /* Butonları sola yasla */ }
    #bottomLeftControls .control-button {
        width: 130px; /* Sabit veya max-width ayarlanabilir */
        box-sizing: border-box; /* Padding dahil */
    }
    #measureButton { background-color: #17a2b8; /* Farklı renk */ }
    #measureButton.measuring { background: cyan; color: black; border-color: black; } /* Ölçüm rengi */
    #addAircraftButton { background-color: #007bff; }
    #addAircraftButton.placing { background: #ffc107; color: black; }
    #speedButton { background-color: #fd7e14; /* Turuncu */ }
    #speedControlContainer {
        background: rgba(50, 50, 50, 0.8);
        padding: 10px;
        border: 1px solid #0f0;
        border-radius: 5px;
        margin-bottom: 5px;
        display: none; /* Başlangıçta gizli */
        width: 130px; /* Butonlarla aynı genişlik */
        box-sizing: border-box;
    }
    #speedSlider { width: 100%; margin-top: 5px; /* Üst boşluk eklendi */ }
    #speedValue { display: none; text-align: center; margin-top: 5px; font-weight: bold; }
    #playPauseButton { background-color: #28a745; border-color: #28a745; } /* Yeşil */
    #playPauseButton.paused { background-color: #ffc107; border-color: #ffc107; color: black; } /* Sarı */
    #takeoffButton { background-color: #6f42c1; border-color: #6f42c1; } /* Mor */
    #takeoffOptionsContainer {
        background: rgba(50, 50, 50, 0.9);
        padding: 10px;
        border: 1px solid #6f42c1;
        border-radius: 5px;
        margin-bottom: 5px;
        width: 130px; /* Butonlarla aynı genişlik */
        box-sizing: border-box;
        display: flex;
        flex-direction: column; /* Seçenekleri alt alta */
        gap: 5px; /* Seçenekler arası boşluk */
    }
    .takeoff-option-btn {
        width: 100%; /* Konteyner genişliğini doldur */
        padding: 5px;
        background-color: #5a379e;
        border: 1px solid #8a63d2;
        color: white;
        font-size: 12px;
        text-align: center;
        border-radius: 3px;
        cursor: pointer;
        transition: background-color 0.2s;
    }
    .takeoff-option-btn:hover {
        background-color: #8a63d2;
    }
    .takeoff-runway-option {
        display: flex;
        flex-direction: column;
        margin-bottom: 5px;
    }
    .waypoint-select {
        width: 100%;
        padding: 5px;
        background-color: #5a379e;
        border: 1px solid #8a63d2;
        color: white;
        font-size: 12px;
        border-radius: 3px;
        margin-top: 3px;
    }
    .waypoint-select:hover {
        background-color: #8a63d2;
    }

    /* Sağ Alt Kontroller (Label Size) */
    #labelControls { position: absolute; bottom: 10px; right: 10px; background: rgba(50, 50, 50, 0.8); padding: 10px; border: 1px solid #0f0; z-index: 10; border-radius: 5px; }
    #labelControls label { color: white; display: block; margin-bottom: 5px; font-size: 12px; }
    #labelSize { width: 100%; }

    /* Popup Menü */
    #popup { position: absolute; background: rgba(50, 50, 50, 0.3); /* Saydamlık */ border: 1px solid #0f0; padding: 8px; display: none; z-index: 20; font-family: monospace; color: white; max-height: 200px; overflow-y: auto; scrollbar-width: thin; scrollbar-color: #0f0 #555; border-radius: 4px; backdrop-filter: blur(2px); /* Hafif bulanıklık efekti */ }
    #popup::-webkit-scrollbar { width: 8px; }
    #popup::-webkit-scrollbar-track { background: #555; border-radius: 4px;}
    #popup::-webkit-scrollbar-thumb { background-color: #0f0; border-radius: 4px; border: 1px solid #555;}
    #popup div:not(#turnButtons) { margin: 2px 0; padding: 4px 8px; cursor: pointer; border-bottom: 1px solid #666; font-size: 13px; transition: background-color 0.1s, color 0.1s; /* Yumuşak geçiş */ }
    #popup div:not(#turnButtons):last-child { border-bottom: none; }
    #popup div:not(#turnButtons):hover { background-color: #0f0; color: black; } /* Hover efekti */
    #popup div.current-value:not(#headingValues div) { /* Sadece hız, irtifa, rod için */
        font-weight: bold; color: #0f0 !important; background-color: rgba(0, 255, 0, 0.1);
    }
    #turnButtons { display: flex; justify-content: space-between; margin-top: 8px; padding-top: 8px; border-top: 1px solid #777; position: sticky; bottom: 0; background: rgba(50, 50, 50, 0.3); /* Saydamlık */ padding-bottom: 2px; }
    .turn-btn { background: #444; border: 1px solid #0f0; color: #0f0; flex-grow: 1; margin: 0 2px; height: 25px; border-radius: 3px; cursor: pointer; font-size: 12px; display: flex; align-items: center; justify-content: center; font-weight: bold; }
    .turn-btn:hover { background: #0f0; color: black; }
    .turn-btn.active { background: #0f0; color: black; border: 1px solid black; }

    /* --- YENİ VE GÜNCELLENMİŞ ETİKET STİLLERİ --- */
    .dynamic-label { /* Ortak stil */
        position: absolute;
        font-family: monospace;
        pointer-events: auto; /* Olayları yakalaması için */
        white-space: nowrap;
        z-index: 5;
        color: black !important; /* YENİ: Metin rengi siyah */
        font-weight: bold !important; /* YENİ: Metin kalın */
        background: transparent !important; /* YENİ: Tamamen transparan */
        padding: 3px 6px;
        border: none; /* YENİ: Kenarlık yok */
        border-radius: 3px;
        cursor: default; /* Varsayılan imleç, sürükleme orta tuşla */
        user-select: none;
        /* font-size: 12px; Bu JS ile ayarlanıyor */
        transform-origin: left center;
    }

    .dynamic-label.dragging {
        cursor: grabbing !important; /* Sürüklerken */
        border: 1px dashed black !important; /* Sürüklerken kenarlık stili siyah ve kesikli */
        background: rgba(0,0,0,0.05) !important; /* Sürüklerken çok hafif bir arka plan */
    }

    .aircraft-label { /* Uçak etiketine özel */
        cursor: grab; /* Sürükleme imleci */
    }
    /* .aircraft-label.dragging zaten .dynamic-label.dragging tarafından kapsanıyor */

    /* Etiket içindeki tüm alt elementlerin de siyah ve bold olmasını sağla */
    .aircraft-label .label-line,
    .aircraft-label .label-id,
    .aircraft-label .current-altitude,
    .aircraft-label .target-altitude,
    .aircraft-label [data-field="rateOfDescent"],
    .aircraft-label .aircraft-info-panel div,
    .aircraft-label .aircraft-info-panel span {
        color: black !important;
        font-weight: bold !important; /* Her ihtimale karşı tekrar */
    }

    .clickable-line { /* Uçak etiketi içindeki tıklanabilir satırlar için */
        cursor: pointer;
        text-decoration: underline;
        color: black !important;
        padding: 2px 0;
        margin: 1px 0;
    }
    .clickable-line:hover {
        background-color: rgba(180, 180, 180, 0.3); /* Hover için hafif gri */
        color: black !important; /* Hover'da renk değişmesin */
    }
    .target-altitude.clickable-line:hover { /* Uçak etiketi içindeki hedef irtifa için özel hover */
        background-color: rgba(170, 170, 170, 0.4); /* Hover için biraz daha belirgin gri */
    }

    .aircraft-label.selected {
        border: 1px solid black !important; /* Seçiliyken siyah kenarlık */
        box-shadow: 0 0 6px rgba(0, 0, 0, 0.6); /* Seçiliyken siyah gölge */
        /* background: transparent !important; // Seçiliyken de transparan kalsın */
    }
    .target-altitude { /* Uçak etiketi içindeki hedef irtifa */
        margin-left: 5px; /* Sol boşluk */
    }
    .current-altitude { /* Uçak etiketi içindeki mevcut irtifa */
        cursor: default; /* Tıklanamaz olduğunu belirt */
        text-decoration: none !important; /* Alt çizgiyi kaldır */
    }
    .label-id { /* Uçak etiketi içindeki ID */
        cursor: pointer;
        text-decoration: underline;
    }
    .label-id:hover {
        background-color: rgba(180, 180, 180, 0.2);
    }

    /* Ölçüm etiketi stilleri */
    .measurement-label {
        /* .dynamic-label'den miras alır: background: transparent !important; */
        /* .dynamic-label'den miras alır: font-weight: bold !important; */
        color: cyan !important; /* YENİ: Metin rengi cyan */
        cursor: grab;
        /* border: 1px solid cyan; /* İsteğe bağlı: Ölçüm etiketi için cyan kenarlık */
    }
    /* .measurement-label.dragging .dynamic-label.dragging'den alır */

    .measurement-label .measurement-bearing,
    .measurement-label .measurement-relative-bearing,
    .measurement-label .measurement-dist-alt {
        display: block; /* Ayrı satırda göster */
        color: cyan !important; /* YENİ: Metin rengi cyan */
        font-weight: bold !important; /* Kalınlık cyan için de geçerli olsun */
        margin-bottom: 2px; /* Alt boşluk */
    }
    /* --- ETİKET STİLLERİ SONU --- */

    /* Geçici Ölçüm Etiketi */
    #tempMeasurementLabel {
        position: absolute;
        font-family: monospace;
        font-size: 11px;
        color: cyan;
        background: rgba(0, 0, 0, 0.5);
        padding: 2px 4px;
        border: 1px dashed cyan;
        border-radius: 3px;
        white-space: nowrap;
        pointer-events: none; /* Tıklanamaz */
        z-index: 25; /* Diğer etiketlerin üstünde */
        display: none; /* Başlangıçta gizli */
    }

    .altitude-line span {
        display: inline-block; /* Yan yana durmalarını sağla */
        vertical-align: middle; /* Dikey hizalama (isteğe bağlı) */
    }
    /* Uçak Bilgi Paneli Stilleri (dynamic-label içindeki renkler zaten ayarlandı) */
    .aircraft-info-panel {
        border-top: 1px solid #555; /* Siyah metinle daha uyumlu bir ayıraç rengi */
        margin-top: 3px;
        padding-top: 3px;
        font-size: 0.9em; /* Ana etiketten biraz daha küçük */
    }
    /* .aircraft-info-panel div ve span renkleri yukarıda .aircraft-label altında ayarlandı */

    /* Uçak Ekleme Formu */
    #addAircraftForm { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(60, 60, 60, 0.95); border: 2px solid #0f0; padding: 20px; border-radius: 8px; z-index: 30; color: white; font-family: Arial, sans-serif; width: 320px; box-shadow: 0 5px 15px rgba(0,0,0,0.5); display: none; }
    #addAircraftForm h3 { margin-top: 0; text-align: center; color: #0f0; }
    #addAircraftForm label { display: block; margin-bottom: 5px; font-weight: bold; font-size: 14px; }
    #addAircraftForm input[type="text"],
    #addAircraftForm input[type="number"],
    #addAircraftForm select {
        width: calc(100% - 16px);
        padding: 8px;
        margin-bottom: 10px;
        border: 1px solid #aaa;
        border-radius: 4px;
        background: #eee;
        color: #333;
        font-size: 14px;
        box-sizing: border-box;
    }
    #addAircraftForm .form-buttons { display: flex; justify-content: space-between; margin-top: 15px; }
    #addAircraftForm button { padding: 10px 20px; border: none; border-radius: 5px; font-weight: bold; cursor: pointer; }
    #addAircraftForm #submitNewAircraft { background-color: #0f0; color: black; }
    #addAircraftForm #cancelNewAircraft { background-color: #dc3545; color: white; }
    #formError { color: #ffc107; font-size: 12px; min-height: 15px; text-align: center; margin-top: 10px; }
    .glow {
        box-shadow: 0 0 8px 3px #00aaff, 0 0 2px 1px #00aaff;
        border-color: #00aaff !important;
    }

    /* YENİ CSS (Bu kısımlar zaten yukarıda vardı, birleştirirken dikkat edin) */
    html, body {
        width: 100vw; height: 100vh; margin: 0; padding: 0; overflow: hidden;
        background-color: #333; color: white; font-family: Arial, sans-serif;
    }
    canvas {
        position: fixed; left: 50%; top: 50%; transform: translate(-50%, -50%);
        z-index: 1; display: block; background: rgba(160, 160, 160, 0.5);
        cursor: grab; border: none;
    }
    /* AIRMISS Alert */
    #airmissAlert {
        position: absolute; top: 50%; left: 30px; transform: translateY(-50%);
        background: rgba(0, 0, 0, 0.8); padding: 20px; border: 2px solid red;
        border-radius: 10px; color: red; font-family: monospace; font-size: 48px;
        font-weight: bold; text-align: center; z-index: 50; display: none;
        text-shadow: 2px 2px 4px black;
    }
    #airmissAlert span { display: block; font-size: 24px; margin-top: 10px; color: white; }
    #generateScenarioBtn {
        background-color: #4CAF50; color: white; padding: 10px 20px; margin: 5px;
        border: none; border-radius: 5px; cursor: pointer; font-size: 14px;
    }
    #generateScenarioBtn:hover { background-color: #45a049; }
    #generateScenarioBtn:active { background-color: #3d8b40; }

    #headingValues div:hover {
        background-color: #0f0; color: black; box-shadow: 0 0 8px #0f0;
    }

    #submitManualHeading {
        padding: 3px 6px; font-size: 11px; background-color: #4CAF50;
        border: none; color: white; border-radius: 2px; margin-left: 5px;
    }
    #submitManualHeading:hover { background-color: #45a049; }
    #manualHeadingInput {
        width: 50px; padding: 3px; font-size: 12px; text-align: right;
        background-color: #ddd; color: #333; border: 1px solid #777; border-radius: 2px;
    }
	
	
	/* ... (Diğer stilleriniz) ... */

.intercept-btn {
    display: flex;
    align-items: center;
    justify-content: space-between;
    /* Gerekirse buton genişliğini ayarlayın, örn: width: 190px; */
}

.intercept-indicator {
    display: inline-block;
    width: 16px;
    height: 16px;
    border: 1px solid #888; /* Pasifken daha soluk kenarlık */
    border-radius: 3px;
    margin-left: 10px; /* Metinle arasında boşluk */
    background-color: #666; /* Pasifken daha koyu arka plan */
    font-size: 12px;
    line-height: 16px; /* Check işaretini dikeyde ortalamak için */
    text-align: center;
    color: #0f0; /* Aktif check işareti rengi */
    font-weight: bold;
    transition: background-color 0.2s, border-color 0.2s;
}

/* Aktif intercept durumundaki buton ve gösterge */
.intercept-btn.intercepting {
    /* background-color: #e0a800; /* Aktifken buton rengi (isteğe bağlı) */
    /* border-color: #ffc107; */
    box-shadow: 0 0 5px #ffc107; /* Aktifken hafif parlama */
}

.intercept-btn.intercepting .intercept-indicator {
    background-color: #0f0; /* Aktif (intercept ediyor) durumda yeşil arka plan */
    border-color: #0a0;   /* Aktifken yeşil kenarlık */
    color: black;         /* Check işareti siyah */
}

/* Disabled durumundaki gösterge (daha soluk) */
.intercept-btn:disabled .intercept-indicator {
    border-color: #555;
    background-color: #444;
    color: #777; /* Check işareti çok soluk veya görünmez */
}
</style>
	
	







</head>
<body>

<div id="topLeftControls">
    <button id="fullscreenButton" class="control-button">Tam Ekran</button>
    <button id="showLocalizer21L" class="loc-btn control-button">LOC 03R</button>
    <button id="showLocalizer033Right" class="loc-btn control-button">LOC 21L</button>
	<button id="generateScenarioBtn">Senaryo Üret</button>
</div>

<div id="topCenterControls">
    <button id="interceptButton033" class="control-button intercept-btn">
        Intercept LOC 033 <span class="intercept-indicator"></span>
    </button>
    <button id="interceptButton21L" class="control-button intercept-btn">
        Intercept LOC 21L <span class="intercept-indicator"></span>
    </button>
    <button id="towerButton" class="control-button" disabled>Tower</button>
    <button id="removeButton" class="control-button" disabled>Remove</button>
</div>

<div id="bottomLeftControls">
    <div id="takeoffOptionsContainer" style="display: none;">
        <div class="takeoff-runway-option" data-runway="03R">
            <button class="takeoff-option-btn runway-btn" data-runway="03R">Kalkış 03R</button>
            <select class="waypoint-select" data-runway="03R">
                <option value="">Waypoint Seç</option>
                <option value="PETAR">PETAR</option>
                <option value="SALGO">SALGO</option>
                <option value="ASTAL">ASTAL</option>
                <option value="İLHAN">İLHAN</option>
                <option value="GURBU">GURBU</option>
                <option value="KUBER">KUBER</option>
                <option value="YUCEL">YUCEL</option>
                <option value="BAKIR">BAKIR</option>
                <option value="TELVO">TELVO</option>
                <option value="HAY">HAY</option>
            </select>
        </div>
        <div class="takeoff-runway-option" data-runway="21L">
            <button class="takeoff-option-btn runway-btn" data-runway="21L">Kalkış 21L</button>
            <select class="waypoint-select" data-runway="21L">
                <option value="">Waypoint Seç</option>
                <option value="PETAR">PETAR</option>
                <option value="SALGO">SALGO</option>
                <option value="ASTAL">ASTAL</option>
                <option value="İLHAN">İLHAN</option>
                <option value="GURBU">GURBU</option>
                <option value="KUBER">KUBER</option>
                <option value="YUCEL">YUCEL</option>
                <option value="BAKIR">BAKIR</option>
                <option value="TELVO">TELVO</option>
                <option value="HAY">HAY</option>
            </select>
        </div>
    </div>
    <button id="takeoffButton" class="control-button">Uçak Kaldır</button>
    <button id="playPauseButton" class="control-button">Durdur</button>
    <div id="speedControlContainer">
        <input type="range" id="speedSlider" min="0" max="9" step="1" value="3">
        <span id="speedValue">1x</span>
    </div>
    <button id="speedButton" class="control-button">Hız: 1x</button>
    <button id="measureButton" class="control-button">Ölçüm Yap</button>
    <button id="addAircraftButton" class="control-button">Uçak Ekle</button>
</div>

<div id="vectorControls">
    <div id="vectorToggleWrapper">
        <span id="gameTimer">00:00</span>
        <button class="control-button vector-btn" id="vectorToggle">Speed Vector: KAPALI</button>
    </div>
    <button class="control-button vector-btn active" data-minutes="1">1 Dakika</button>
    <button class="control-button vector-btn" data-minutes="2">2 Dakika</button>
    <button class="control-button vector-btn" data-minutes="3">3 Dakika</button>
    <button class="control-button vector-btn" data-minutes="4">4 Dakika</button>
    <button class="control-button vector-btn" data-minutes="5">5 Dakika</button>
    <button class="control-button vector-btn" data-minutes="6">6 Dakika</button>
    <button class="control-button vector-btn" data-minutes="7">7 Dakika</button>
</div>

<div id="labelControls">
    <label for="labelSize">Etiket Boyutu:</label>
    <input type="range" id="labelSize" min="8" max="24" value="12">
</div>

<canvas id="radar"></canvas>
<div id="popup"></div>
<div id="addAircraftForm">
    <h3>Yeni Uçak Bilgileri</h3>
    <div id="formError"></div>
    <label for="acCallsign">Çağrı Adı (ID):</label>
    <input type="text" id="acCallsign" name="callsign" required maxlength="7">

    <label for="acType">Uçak Tipi:</label>
    <select id="acType" name="type"></select>

    <label for="acHeading">Başlangıç Yönü (0-359):</label>
    <input type="number" id="acHeading" name="heading" min="0" max="359" required>
    <label for="acSpeed">Hız (kts):</label>
    <input type="number" id="acSpeed" name="speed" min="100" max="600" required>
    <label for="acAltitude">İrtifa (FL):</label>
    <input type="number" id="acAltitude" name="altitude" min="10" max="450" step="5" required>

    <label for="acDepartureFL">Tırmanış FL (Kalkış ise, örn: 240):</label>
    <input type="number" id="acDepartureFL" name="departureFL" min="10" max="450" step="5">


    <div class="form-buttons">
        <button type="button" id="cancelNewAircraft">İptal</button>
        <button type="button" id="submitNewAircraft">Uçağı Ekle</button>
    </div>
</div>
<div id="tempMeasurementLabel"></div>
<div id="runwayCenterHoverText" style="display:none; position:absolute; font-size:9px; color:white; background:rgba(0,0,0,0.6); padding:1px 3px; border-radius:2px; pointer-events:none; z-index:30; white-space:nowrap;">LTAC</div>
<div id="airmissAlert">
    AIRMISS!<br>
    <span id="airmissCallsigns"></span>
</div>
<div id="runwaySelectionModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.75); z-index: 100; align-items: center; justify-content: center;">
    <div style="background-color: #3a3a3a; padding: 25px 30px; border-radius: 8px; border: 2px solid #0f0; text-align: center; box-shadow: 0 8px 20px rgba(0,0,0,0.6);">
        <h3 style="color: #0f0; margin-top: 0; margin-bottom: 25px; font-size: 18px; font-weight: bold;">Aktif Pisti Seçin</h3>
        <button id="selectRunway03RBtn" class="control-button" style="margin: 5px 12px; padding: 12px 25px; background-color: #4CAF50; border-color: #3e8e41; font-size: 16px;">03R</button>
        <button id="selectRunway21LBtn" class="control-button" style="margin: 5px 12px; padding: 12px 25px; background-color: #4CAF50; border-color: #3e8e41; font-size: 16px;">21L</button>
        <button id="cancelRunwaySelectionBtn" class="control-button" style="margin: 15px 12px 5px; padding: 10px 22px; background-color: #f44336; border-color: #d32f2f; font-size: 14px;">İptal</button>
    </div>
</div>




<script>
// --- Canvas ve DOM Elementleri ---
const canvas = document.getElementById('radar');
const ctx = canvas.getContext('2d');
const fullscreenButton = document.getElementById('fullscreenButton');
const vectorToggle = document.getElementById('vectorToggle');
const popup = document.getElementById('popup');
const labelSizeControl = document.getElementById('labelSize');
const btnLoc21L = document.getElementById('showLocalizer21L');
const btnLocRight = document.getElementById('showLocalizer033Right');
const addAircraftButton = document.getElementById('addAircraftButton');
const addAircraftForm = document.getElementById('addAircraftForm');
const submitNewAircraftBtn = document.getElementById('submitNewAircraft');
const cancelNewAircraftBtn = document.getElementById('cancelNewAircraft');
const formErrorDiv = document.getElementById('formError');
const inputCallsign = document.getElementById('acCallsign');
const inputType = document.getElementById('acType');
const inputHeading = document.getElementById('acHeading');
const inputSpeed = document.getElementById('acSpeed');
const inputAltitude = document.getElementById('acAltitude');
const inputDepartureFL = document.getElementById('acDepartureFL');
const measureButton = document.getElementById('measureButton');
const interceptButton033 = document.getElementById('interceptButton033');
const interceptButton21L = document.getElementById('interceptButton21L');
const speedButton = document.getElementById('speedButton');
const speedControlContainer = document.getElementById('speedControlContainer');
const speedSlider = document.getElementById('speedSlider');
const speedValueSpan = document.getElementById('speedValue');
const towerButton = document.getElementById('towerButton');
const removeButton = document.getElementById('removeButton');
const playPauseButton = document.getElementById('playPauseButton');
const takeoffButton = document.getElementById('takeoffButton');
const takeoffOptionsContainer = document.getElementById('takeoffOptionsContainer');
const tempMeasurementLabel = document.getElementById('tempMeasurementLabel');
const runwayCenterHoverText = document.getElementById('runwayCenterHoverText');
const runwaySelectionModal = document.getElementById('runwaySelectionModal');
const selectRunway03RBtn = document.getElementById('selectRunway03RBtn');
const selectRunway21LBtn = document.getElementById('selectRunway21LBtn');
const cancelRunwaySelectionBtn = document.getElementById('cancelRunwaySelectionBtn');

speedSlider.addEventListener('input', () => {
    const sliderValue = parseInt(speedSlider.value); // Integer from 0 to 9
    speedFactor = speedMultipliers[sliderValue]; // Map to [0.25, 0.5, 0.75, 1, 1.25, 1.5, 2, 3, 5, 10]
    gameSpeedMultiplier = speedFactor; // Synchronize game speed
    speedValue.textContent = `${speedFactor}x`;
    speedButton.textContent = `Hız: ${speedFactor}x`;
    console.log(`Speed changed to ${speedFactor}x, sliderValue: ${sliderValue}`); // Debug
    // Clear and restart timer
    if (timerInterval) {
        clearInterval(timerInterval);
        timerInterval = null;
    }
    startGameTimer();
});

const callsignPrefixes = ['THY', 'PGT', 'SXS', 'ONR', 'AFR', 'BAW', 'DLH', 'KLM', 'UAE', 'QTR', 'BER', 'AUA'];
let scenarioAircraftIdCounter = 0;
let activeScenarioTimeouts = [];

// --- Uçak Tipleri Veritabanı ---
const aircraftTypes = ['C130', 'A342', 'B737', 'B747', 'A321', 'A320', 'A319', 'MD83', 'AN12', 'F16'];
const defaultAircraftSpeeds = { // Knot cinsinden ortalama seyir hızları
    'C130': 230, 'A342': 280, 'B737': 300, 'B747': 270, 'A321': 290,
    'A320': 300, 'A319': 275, 'MD83': 260, 'AN12': 210, 'F16': 440
};
const aircraftPerformanceROC = { // Feet/dakika cinsinden tipik tırmanma oranları
    'C130': 1800, 'A342': 2200, 'B737': 2500, 'B747': 1500, 'A321': 2400,
    'A320': 2500, 'A319': 2400, 'MD83': 2300, 'AN12': 2000, 'F16': 3500
};

// --- Arka Plan Resmi ---
const backgroundImage = new Image();
backgroundImage.src = 'arkaplanim2.jpeg';
backgroundImage.onload = () => { console.log("Arka plan resmi yüklendi."); };
backgroundImage.onerror = () => {
    console.error("Arka plan resmi yüklenemedi! Placeholder kullanılıyor.");
};
const imageInnerCircleDiameterFraction = 0.21;
let backgroundOffsetX = -34; let backgroundOffsetY = 50;

// --- Canvas Boyutları ve Merkez ---
let canvasWidth, canvasHeight, centerX, centerY;

// --- Durum Değişkenleri ---
let zoom = 1.0; let panX = 0; let panY = 0;
let isPanning = false; let isDraggingLabel = false;
let draggedLabelItem = null; let draggedLabelType = null;
let dragOffsetX = 0; let dragOffsetY = 0;
let lastMouseX = 0; let lastMouseY = 0;
const baseNmToPixels = 20; const innerCircleRadiusNM = 10;
let labelFontSize = 12; let lastTime = performance.now();
let showVectors = false; let vectorMinutes = 1;
let selectedAircraft = null; let isPlacingAircraft = false;
let pendingAircraftLocation = null; let showLocalizerLeft = false; let showLocalizerRight = false;
const runwayCourse = 33;
const localizerCourse033Right = 33;
const localizerCourse21L = 213;
const INTERCEPT_TARGET_COURSE_033 = localizerCourse033Right;
const INTERCEPT_TARGET_COURSE_21L = localizerCourse21L;
const localizerLengthNM = 25;
const runwayLengthNM = 2; const runwayWidthNM = 0.2;
const DEFAULT_ROD = 1500; const DEFAULT_CLIMB_RATE = 2500;
const INTERCEPT_ANGLE_MIN_033 = 30; const INTERCEPT_ANGLE_MAX_033 = 60;
const INTERCEPT_ANGLE_MIN_21L = 170; const INTERCEPT_ANGLE_MAX_21L = 255;
const INTERCEPT_MAX_DIST_NM = 25; const ON_LOCALIZER_THRESHOLD_PX = 0.5;
const ON_LOCALIZER_THRESHOLD_NM = 0.05;
const RUNWAY_THRESHOLD_DIST_PX = 5; let gameSpeedMultiplier = 1.0;
const speedMultipliers = [0.25, 0.5, 0.75, 1, 1.25, 1.5, 2, 3, 5, 10];
let isPaused = false;
let departureCounter = 0;
let gameStartTime = null;
let elapsedTime = 36000;
let timerInterval = null;
let speedFactor = 1;

// --- Ölçüm Durumu ---
let isMeasuring = false; let measurementStartPoint = null; let hoveredAircraftForMeasure = null;
let measurements = [];
let hoveredRunwayCenterForMeasure = false;

// --- Uçak Verileri ---
const aircrafts = [
    { id: 'THY123', x: 0, y: 0, heading: 210, targetHeading: 210, speedKTS: defaultAircraftSpeeds['A321'] || 220, altitude: 5000, targetAltitude: 5000, rateOfDescent: 0, rateOfClimb: 0, isTakingOff: false, takeoffRunway: null, isIntercepting: false, isHandedOffToTower: false, showVector: false, labelElement: null, labelX: 0, labelY: 0, labelDragged: true, bankAngle: 0, maxBankAngle: 25, commandedTurnDirection: 0, turning: false, type: 'A321', departureTargetFL: 280, showInfoPanel: false, draggedLabelDeltaX: 0, draggedLabelDeltaY: 0, lastHeadingUpdateTime: 0, initialPosSet: false },
    { id: 'PGS456', x: 0, y: 0, heading: 30, targetHeading: 30, speedKTS: defaultAircraftSpeeds['B737'] || 250, altitude: 4000, targetAltitude: 4000, rateOfDescent: 0, rateOfClimb: 0, isTakingOff: false, takeoffRunway: null, isIntercepting: false, isHandedOffToTower: false, showVector: false, labelElement: null, labelX: 0, labelY: 0, labelDragged: true, bankAngle: 0, maxBankAngle: 25, commandedTurnDirection: 0, turning: false, type: 'B737', departureTargetFL: null, showInfoPanel: false, draggedLabelDeltaX: 0, draggedLabelDeltaY: 0, lastHeadingUpdateTime: 0, initialPosSet: false },
];

// --- WAYPOINT ADDITION START ---
const waypoints = [
    { name: 'PETAR', angle: 270, distanceNM: 43 }, { name: 'SALGO', angle: 296, distanceNM: 43.3 },
    { name: 'ASTAL', angle: 6,   distanceNM: 38.8 }, { name: 'İLHAN', angle: 57,  distanceNM: 39 },
    { name: 'GURBU', angle: 83,  distanceNM: 40 },   { name: 'KUBER', angle: 118, distanceNM: 33.5 },
    { name: 'YUCEL', angle: 136, distanceNM: 42.3 }, { name: 'BAKIR', angle: 155, distanceNM: 42.9 },
    { name: 'TELVO', angle: 181, distanceNM: 44 },   { name: 'HAY',   angle: 206, distanceNM: 46 }
];
// --- WAYPOINT ADDITION END ---

// --- Yardımcı Fonksiyonlar ---
function toRadians(degrees) { return degrees * Math.PI / 180; }
function toDegrees(radians) { return (radians * 180 / Math.PI + 360) % 360; }
function nmToWorldPixels(nm) { return nm * baseNmToPixels; }
function worldPixelsToNm(pixels) { return pixels / baseNmToPixels; }
function angleDiff(a1, a2) { let diff = a1 - a2; while (diff <= -180) diff += 360; while (diff > 180) diff -= 360; return diff; }
function pointLineDistance(px, py, ax, ay, bx, by) { const n = Math.sqrt((bx - ax) ** 2 + (by - ay) ** 2); if (n === 0) return Math.sqrt((px - ax) ** 2 + (py - ay) ** 2); return Math.abs((px - ax) * (by - ay) - (py - ay) * (bx - ax)) / n; }
function calculateBearing(x1, y1, x2, y2) { const dx = x2 - x1; const dy = y2 - y1; const aR = Math.atan2(dx, -dy); return toDegrees(aR); }
function formatBearing(b) { return (b === null || b === undefined) ? "---" : Math.round(b).toString().padStart(3, '0'); }
function formatRelativeBearing(rb) { if (rb === null || rb === undefined) return ""; const r = Math.round(Math.abs(rb)); const d = rb >= 0 ? 'R' : 'L'; return `${d}${r.toString().padStart(2, '0')}`; }
function formatFlightLevel(alt) { return (alt === null || alt === undefined) ? "---" : `F${Math.round(alt / 100).toString().padStart(3, '0')}`; }

function calculateDynamicInterceptAngle(aircraft, locCourse) {
    const interceptCutAngle = 30; // İstenen kesme açısı (derece)

    // Pist merkezi (veya LOC hattının geçtiği referans nokta)
    const refX = centerX;
    const refY = centerY;

    // Uçaktan referans noktasına olan vektör
    const vectorAircraftToRefX = refX - aircraft.x;
    const vectorAircraftToRefY = refY - aircraft.y;

    // Uçaktan referans noktasına olan açı (Kuzey 0, saat yönünde artan)
    const angleAircraftToRef = toDegrees(Math.atan2(vectorAircraftToRefX, -vectorAircraftToRefY));

    // Uçağın LOC'a göre hangi tarafta olduğunu ve nasıl bir kesme yapması gerektiğini belirle
    // angleDiff(A, B) -> A'dan B'ye en kısa açı.
    // Eğer locCourse, angleAircraftToRef'in "sağında" ise (saat yönünde), sola doğru kesmeliyiz.
    // Eğer locCourse, angleAircraftToRef'in "solunda" ise (saat yönü tersinde), sağa doğru kesmeliyiz.
    let diff = angleDiff(locCourse, angleAircraftToRef);

    let targetHeading;

    if (Math.abs(diff) < 5) { // Uçak zaten neredeyse LOC hattı üzerinde (referans noktasına göre)
        targetHeading = locCourse; // Doğrudan LOC'a dön
    } else if (diff > 0) {
        // LOC, uçağın referans noktasına baktığı açının "sağında".
        // Sola dönerek kesmeli (LOC + kesme açısı)
        targetHeading = (locCourse + interceptCutAngle + 360) % 360;
    } else {
        // LOC, uçağın referans noktasına baktığı açının "solunda".
        // Sağa dönerek kesmeli (LOC - kesme açısı)
        targetHeading = (locCourse - interceptCutAngle + 360) % 360;
    }
    
    // Ekstra kontrol: Eğer uçak zaten LOC'a doğru bir kesme açısıyla uçuyorsa
    // ve hedef baş mevcut baştan çok farklı bir dönüş gerektiriyorsa,
    // mevcut başı korumak veya daha yumuşak bir ayar yapmak daha iyi olabilir.
    // Bu kısım daha fazla ayar gerektirebilir.
    // Örneğin, eğer uçak zaten LOC'a 30-60 derece arası bir açıyla yaklaşıyorsa,
    // ve hesaplanan targetHeading bu yönden çok saptırıyorsa, bir sorun olabilir.

    // Şimdilik yukarıdaki hesaplamayı kullanalım.
    // En iyi sonuç için, uçağın localizer hattına olan dik mesafesi ve
    // kesişme noktası gibi geometrik hesaplamalar yapılmalıdır.

    return Math.round(targetHeading);
}


// Süreyi HH:MM:SS formatına çeviren fonksiyon
function formatTime(totalSeconds) {
    const hours = Math.floor(totalSeconds / 3600);
    const minutes = Math.floor((totalSeconds % 3600) / 60);
    const secs = Math.floor(totalSeconds % 60); // Kalan saniyeler

    // Her zaman iki basamaklı göstermek için padStart kullan
    const formattedHours = hours.toString().padStart(2, '0');
    const formattedMinutes = minutes.toString().padStart(2, '0');
    const formattedSeconds = secs.toString().padStart(2, '0');

    return `${formattedHours}:${formattedMinutes}:${formattedSeconds}`;
}

// Zamanlayıcıyı başlatma ve güncelleme fonksiyonu
function startGameTimer() {
    const gameTimer = document.getElementById('gameTimer');

    // Başlangıçta veya yeniden başlatıldığında zamanı hemen ayarla
    if (gameTimer) {
        gameTimer.textContent = formatTime(Math.floor(elapsedTime)); // Math.floor() ile tam saniye gösterimi
    }

    // Clear any existing interval
    if (timerInterval) {
        clearInterval(timerInterval);
        timerInterval = null;
    }

    if (!isPaused) {
        timerInterval = setInterval(() => {
            if (!isPaused) {
                // speedFactor, her bir "gerçek" saniyede oyun zamanına eklenecek saniye sayısıdır.
                // Örneğin, speedFactor = 1 ise, her saniye 1 oyun saniyesi eklenir.
                // speedFactor = 2 ise, her saniye 2 oyun saniyesi eklenir (oyun 2x hızında).
                elapsedTime += speedFactor; 
                if (gameTimer) {
                    gameTimer.textContent = formatTime(Math.floor(elapsedTime)); // Gösterimi güncelle
                }
            }
        }, 1000); // Her 1000 milisaniyede (1 gerçek saniyede) bir çalışır
    }
}

function toggleTimer(pause) {
    if (pause) {
        if (timerInterval) {
            clearInterval(timerInterval);
            timerInterval = null;
        }
    } else {
        if (timerInterval) { // Clear any existing before restarting
            clearInterval(timerInterval);
            timerInterval = null;
        }
        startGameTimer();
    }
}

// --- Koordinat Dönüşüm Fonksiyonları ---
function worldToScreen(worldX, worldY) { return { x: (worldX * zoom) + panX, y: (worldY * zoom) + panY }; }
function screenToWorld(screenX, screenY) { const r = canvas.getBoundingClientRect(); return { x: (screenX - r.left - panX) / zoom, y: (screenY - r.top - panY) / zoom }; }

// --- Canvas ve Arka Plan Boyutlandırma ---
function resizeCanvas() {
    const prevCanvasWidth = canvasWidth;
    const prevCanvasHeight = canvasHeight;
    const oldPanX = panX;
    const oldPanY = panY;
    const currentZoom = zoom;

    const bodyWidth = document.body.clientWidth;
    const bodyHeight = document.body.clientHeight;
    const newSize = Math.min(bodyWidth, bodyHeight);

    canvasWidth = newSize;
    canvasHeight = newSize;

    const dpr = window.devicePixelRatio || 1;
    canvas.width = canvasWidth * dpr;
    canvas.height = canvasHeight * dpr;

    canvas.style.width = `${canvasWidth}px`;
    canvas.style.height = `${canvasHeight}px`;

    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.scale(dpr, dpr);

    const newScreenCenterX = canvasWidth / 2;
    const newScreenCenterY = canvasHeight / 2;

    if (typeof prevCanvasWidth === 'number' && typeof prevCanvasHeight === 'number' &&
        prevCanvasWidth > 0 && prevCanvasHeight > 0 && currentZoom !== 0) {
        const worldPointX_atOldScreenCenter = (prevCanvasWidth / 2 - oldPanX) / currentZoom;
        const worldPointY_atOldScreenCenter = (prevCanvasHeight / 2 - oldPanY) / currentZoom;
        panX = newScreenCenterX - worldPointX_atOldScreenCenter * currentZoom;
        panY = newScreenCenterY - worldPointY_atOldScreenCenter * currentZoom;
    }

    centerX = newScreenCenterX;
    centerY = newScreenCenterY;

    aircrafts.forEach(ac => {
        if (!ac.initialPosSet) {
            if (ac.id === 'THY123') {
                ac.x = centerX + nmToWorldPixels(10); ac.y = centerY - nmToWorldPixels(7.5);
            } else if (ac.id === 'PGS456') {
                ac.x = centerX - nmToWorldPixels(5); ac.y = centerY + nmToWorldPixels(12.5);
            } else {
                ac.x = centerX + (Math.random() - 0.5) * nmToWorldPixels(innerCircleRadiusNM * 2);
                ac.y = centerY + (Math.random() - 0.5) * nmToWorldPixels(innerCircleRadiusNM * 2);
            }
            ac.initialPosSet = true;
        }
    });
    startGameTimer(); // Timer'ı yeniden başlat/güncelle
}

// --- Çizim Fonksiyonları ---
function drawRadar() {
    ctx.save(); ctx.setTransform(1, 0, 0, 1, 0, 0); ctx.clearRect(0, 0, canvas.width, canvas.height); ctx.restore();
    updateMeasurementData(); updateTopCenterButtonStates();
    ctx.save(); ctx.translate(panX, panY); ctx.scale(zoom, zoom);
    if (backgroundImage.complete && backgroundImage.naturalWidth > 0) {
        const tDiamPx = nmToWorldPixels(innerCircleRadiusNM) * 2; const sF = tDiamPx / (backgroundImage.naturalWidth * imageInnerCircleDiameterFraction);
        const sWW = backgroundImage.naturalWidth * sF; const sHW = backgroundImage.naturalHeight * sF;
        const dXW = centerX - sWW / 2 + backgroundOffsetX; const dYW = centerY - sHW / 2 + backgroundOffsetY;
        ctx.drawImage(backgroundImage, dXW, dYW, sWW, sHW);
    }

    drawRadarCircles();
    drawDirectionLines();
    drawWaypoints();
    drawRunwayAndLocalizers();

    if (isMeasuring && measurementStartPoint) {
        drawTemporaryMeasurementLine();
        updateTemporaryMeasurementLabel();
    } else {
        if (tempMeasurementLabel) tempMeasurementLabel.style.display = 'none';
    }

    if (isMeasuring && measurementStartPoint) {
        if (measurementStartPoint.type === 'aircraft') {
            const ac = aircrafts.find(a => a.id === measurementStartPoint.id);
            if (ac) drawMeasurementHighlight(ac);
        } else if (measurementStartPoint.type === 'runwayCenter') {
            ctx.save(); ctx.strokeStyle = 'cyan'; ctx.lineWidth = 2 / zoom;
            const crosshairSize = 6 / zoom;
            ctx.beginPath();
            ctx.moveTo(centerX - crosshairSize, centerY); ctx.lineTo(centerX + crosshairSize, centerY);
            ctx.moveTo(centerX, centerY - crosshairSize); ctx.lineTo(centerX, centerY + crosshairSize);
            ctx.stroke(); ctx.restore();
        }
    }

    if (isMeasuring && !measurementStartPoint && (hoveredAircraftForMeasure || hoveredRunwayCenterForMeasure)) {
        aircrafts.forEach(ac => { ac.highlighted = (ac === hoveredAircraftForMeasure); });
        if (hoveredRunwayCenterForMeasure) {
            ctx.save(); ctx.fillStyle = 'rgba(0, 255, 255, 0.5)'; ctx.beginPath();
            ctx.arc(centerX, centerY, 5 / zoom, 0, 2 * Math.PI); ctx.fill(); ctx.restore();
        }
    } else {
        aircrafts.forEach(ac => { ac.highlighted = false; });
    }

    measurements.forEach(m => drawMeasurementLine(m));
    if (pendingAircraftLocation) { drawPlacementMarker(pendingAircraftLocation); }
    aircrafts.forEach(ac => { drawAircraft(ac); if (showVectors) { drawSpeedVector(ac); } });
    ctx.restore(); // Pan ve zoom transformasyonunu geri al

    // Etiketler ve bağlantı çizgileri, pan/zoom'dan etkilenmeyen mutlak canvas koordinatlarında çizilir
    aircrafts.forEach(updateAircraftLabelPositionDOM);
    measurements.forEach(updateMeasurementLabelPositionDOM);
    aircrafts.forEach(ac => { if (ac.labelDragged) { drawConnectionLine(ac, 'aircraft'); } });
    measurements.forEach(m => { if (m.labelDragged) { drawConnectionLine(m, 'measurement'); } });
}

function updateTemporaryMeasurementLabel() {
    if (!isMeasuring || !measurementStartPoint || !tempMeasurementLabel) {
        if (tempMeasurementLabel) tempMeasurementLabel.style.display = 'none';
        return;
    }
    try {
        const worldMousePos = screenToWorld(lastMouseX, lastMouseY);
        let startX = measurementStartPoint.x; let startY = measurementStartPoint.y;
        if (measurementStartPoint.type === 'aircraft') {
            const ac = aircrafts.find(a => a.id === measurementStartPoint.id);
            if (ac) { startX = ac.x; startY = ac.y; }
            else { tempMeasurementLabel.style.display = 'none'; return; }
        }
        const dx = worldMousePos.x - startX; const dy = worldMousePos.y - startY;
        const distanceNM = worldPixelsToNm(Math.sqrt(dx * dx + dy * dy));
        const bearing = calculateBearing(startX, startY, worldMousePos.x, worldMousePos.y);
        tempMeasurementLabel.style.display = 'block';
        const labelWidth = tempMeasurementLabel.offsetWidth || 80;
        const labelHeight = tempMeasurementLabel.offsetHeight || 20;
        let labelX = lastMouseX + 15; let labelY = lastMouseY - 10;
        labelX = Math.max(0, Math.min(labelX, window.innerWidth - labelWidth - 5));
        labelY = Math.max(0, Math.min(labelY, window.innerHeight - labelHeight - 5));
        tempMeasurementLabel.style.left = `${labelX}px`;
        tempMeasurementLabel.style.top = `${labelY}px`;
        tempMeasurementLabel.textContent = `${formatBearing(bearing)}° / ${distanceNM.toFixed(1)} NM`;
    } catch (error) {
        console.error("Error updating temporary measurement label:", error);
        if (tempMeasurementLabel) tempMeasurementLabel.style.display = 'none';
    }
}

function drawRadarCircles() {
    ctx.strokeStyle = 'rgba(128, 0, 32, 0.6)'; ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
    ctx.lineWidth = 1 / zoom; ctx.font = `${12 / zoom}px Arial`; ctx.textAlign = 'center';
    for (let i = 1; i <= 4; i++) {
        const rNM = innerCircleRadiusNM * i; const rPx = nmToWorldPixels(rNM);
        ctx.beginPath(); ctx.arc(centerX, centerY, rPx, 0, 2 * Math.PI); ctx.stroke();
        const tY = centerY - rPx - (5 / zoom); ctx.fillText(`${rNM}NM`, centerX, tY);
    }
}
function drawDirectionLines() {
    const lenPx = nmToWorldPixels(innerCircleRadiusNM * 4.5); ctx.strokeStyle = 'rgba(128, 128, 128, 0.5)';
    ctx.lineWidth = 1 / zoom; ctx.fillStyle = 'rgba(255, 255, 255, 0.8)'; ctx.font = `${12 / zoom}px Arial`; ctx.textAlign = 'center';
    const dirs = [{deg: 0, label: 'N'}, {deg: 90, label: 'E'}, {deg: 180, label: 'S'}, {deg: 270, label: 'W'}];
    dirs.forEach(d => {
        const r = toRadians(d.deg); const eX = centerX + Math.sin(r) * lenPx; const eY = centerY - Math.cos(r) * lenPx;
        ctx.beginPath(); ctx.moveTo(centerX, centerY); ctx.lineTo(eX, eY); ctx.stroke();
        const lX = centerX + Math.sin(r) * (lenPx + (15 / zoom)); const lY = centerY - Math.cos(r) * (lenPx + (15 / zoom));
        ctx.fillText(d.label, lX, lY + (4 / zoom));
    });
}

function drawWaypoints() {
    const waypointColor = 'saddlebrown'; const waypointTextColor = 'saddlebrown';
    const triangleSize = 6 / zoom; const textOffsetY = (triangleSize * 0.5) + (10 / zoom);
    ctx.fillStyle = waypointColor; ctx.strokeStyle = 'rgba(50,20,0,0.8)'; ctx.lineWidth = 0.5 / zoom;
    waypoints.forEach(wp => {
        const angleRad = toRadians(wp.angle); const distancePixels = nmToWorldPixels(wp.distanceNM);
        const wpX = centerX + Math.sin(angleRad) * distancePixels;
        const wpY = centerY - Math.cos(angleRad) * distancePixels;
        ctx.beginPath();
        ctx.moveTo(wpX, wpY - triangleSize * 0.66);
        ctx.lineTo(wpX - triangleSize * 0.5, wpY + triangleSize * 0.33);
        ctx.lineTo(wpX + triangleSize * 0.5, wpY + triangleSize * 0.33);
        ctx.closePath(); ctx.fill(); ctx.stroke();
        ctx.fillStyle = waypointTextColor; ctx.font = `${10 / zoom}px Arial`;
        ctx.textAlign = 'center'; ctx.textBaseline = 'top';
        ctx.fillText(wp.name, wpX, wpY + triangleSize * 0.33 + (2 / zoom));
    });
}

function drawRunwayAndLocalizers() {
    ctx.save(); ctx.translate(centerX, centerY); ctx.rotate(toRadians(runwayCourse));
    const rLenPx = nmToWorldPixels(runwayLengthNM); const rWidPx = nmToWorldPixels(runwayWidthNM);
    ctx.fillStyle = 'rgba(255, 255, 255, 0.6)'; ctx.fillRect(-rWidPx / 2, -rLenPx / 2, rWidPx, rLenPx);
    ctx.restore();
    if (showLocalizerLeft) { drawLocalizerBeam(1); } if (showLocalizerRight) { drawLocalizerBeam(-1); }
}
function drawLocalizerBeam(side) {
    let angleDeg = (side === 1) ? localizerCourse21L : localizerCourse033Right;
    const rRad = toRadians(angleDeg);
    const defC = 'rgba(128, 0, 32, 0.8)'; const hiC = '#ffffff'; const ptR = 2 / zoom; const pts = [];
    for (let i = 1; i <= localizerLengthNM; i++) {
        const xPW = centerX + Math.sin(rRad) * nmToWorldPixels(i);
        const yPW = centerY - Math.cos(rRad) * nmToWorldPixels(i);
        ctx.fillStyle = (i === 12) ? hiC : defC;
        ctx.beginPath(); ctx.arc(xPW, yPW, ptR, 0, 2 * Math.PI); ctx.fill();
        pts.push({ x: xPW, y: yPW });
    }
    if (pts.length > 1) {
        ctx.save(); ctx.strokeStyle = 'rgba(128, 0, 32, 0.4)'; ctx.lineWidth = 1 / zoom;
        ctx.beginPath(); ctx.moveTo(pts[0].x, pts[0].y);
        for (let i = 1; i < pts.length; i++) { ctx.lineTo(pts[i].x, pts[i].y); }
        ctx.stroke(); ctx.restore();
    }
}
function drawAircraft(ac) {
    ctx.save();
    ctx.translate(ac.x, ac.y);
    const s = 4 / zoom;
    if (ac.highlighted) {
        ctx.beginPath(); ctx.arc(0, 0, s + 5, 0, 2 * Math.PI);
        ctx.strokeStyle = '#00aaff'; ctx.lineWidth = 3 / zoom;
        ctx.shadowColor = '#00aaff'; ctx.shadowBlur = 10 / zoom;
        ctx.stroke(); ctx.shadowBlur = 0;
    }
    ctx.fillStyle = ac === selectedAircraft ? '#0f0' : '#fff'; // Yeşil seçiliyse, değilse beyaz
    if (isMeasuring && hoveredAircraftForMeasure && ac.id === hoveredAircraftForMeasure.id) {
        ctx.fillStyle = '#00aaff'; // Ölçüm için hover rengi
    }
    ctx.beginPath(); ctx.arc(0, 0, s, 0, 2 * Math.PI); ctx.fill();
    ctx.strokeStyle = 'rgba(0, 0, 0, 0.7)'; ctx.lineWidth = 1 / zoom; // Uçak sembolü kenarlığı
    ctx.beginPath(); ctx.arc(0, 0, s, 0, 2 * Math.PI); ctx.stroke();
    ctx.restore();
}

function drawSpeedVector(ac) {
    const spNMm = ac.speedKTS / 60; // NM per minute
    const totalMinutes = vectorMinutes;
    const segmentLengthNM = spNMm; // Each segment represents 1 minute of travel

    const rad = toRadians(ac.heading); // Uçağın global yönü (0 derece = -Y ekseni)
    const startX = ac.x;
    const startY = ac.y;

    const baseLineWidth = 1 / zoom;
    ctx.lineWidth = baseLineWidth * 1.3;

    const arrowSize = 8 / zoom;
    const arrowAngleRad = Math.PI / 8; // Okun yarım açısı

    for (let i = 0; i < totalMinutes; i++) {
        const segmentStartDistPx = nmToWorldPixels(i * segmentLengthNM);
        const segmentEndDistPx = nmToWorldPixels((i + 1) * segmentLengthNM);

        const segStartX = startX + Math.sin(rad) * segmentStartDistPx;
        const segStartY = startY - Math.cos(rad) * segmentStartDistPx;
        const segEndX = startX + Math.sin(rad) * segmentEndDistPx;
        const segEndY = startY - Math.cos(rad) * segmentEndDistPx;

        ctx.strokeStyle = i % 2 === 0 ? 'rgba(0, 0, 0, 0.9)' : 'rgba(255, 255, 255, 0.9)';

        ctx.beginPath();
        ctx.moveTo(segStartX, segStartY);
        ctx.lineTo(segEndX, segEndY);
        ctx.stroke();

        // Ok başını çiz
        ctx.save();
        ctx.fillStyle = 'rgba(0, 0, 0, 0.95)'; // Ok başı her zaman siyah

        // Okun sivri ucu (segEndX, segEndY)
        // İki taban noktasını hesaplayalım.
        // Ok, (segEndX, segEndY)'den geriye doğru, uçağın gittiği yöne zıt bir açıyla açılmalı.
        // Uçağın gidiş yönünün tersi olan açı: rad + Math.PI
        const tailAngle1 = rad + Math.PI - arrowAngleRad;
        const tailAngle2 = rad + Math.PI + arrowAngleRad;

        const tailX1 = segEndX + arrowSize * Math.sin(tailAngle1);
        const tailY1 = segEndY - arrowSize * Math.cos(tailAngle1);

        const tailX2 = segEndX + arrowSize * Math.sin(tailAngle2);
        const tailY2 = segEndY - arrowSize * Math.cos(tailAngle2);

        ctx.beginPath();
        ctx.moveTo(segEndX, segEndY); // Sivri uç
        ctx.lineTo(tailX1, tailY1);   // Bir taban noktası
        ctx.lineTo(tailX2, tailY2);   // Diğer taban noktası
        ctx.closePath();
        ctx.fill();
        ctx.restore();
    }
}

function drawConnectionLine(item, type) {
    if (!item.labelElement || !item.labelDragged) return;
    let sSX, sSY;
    let strC; // Rengi burada belirleyeceğiz
    let lineWidth = 1.5; // Varsayılan çizgi kalınlığı

    if (type === 'aircraft') {
        strC = 'rgba(0, 0, 0, 0.7)'; // Uçak bağlantı çizgisi siyah
        // lineWidth = 1.5; // Zaten varsayılan
        const sP = worldToScreen(item.x, item.y); sSX = sP.x; sSY = sP.y;
    } else if (type === 'measurement') {
        strC = 'rgba(0, 255, 255, 0.75)'; // YENİ: Ölçüm bağlantı çizgisi cyan (biraz daha opak)
        // lineWidth = 1.5; // Zaten varsayılan
        const mXW = (item.start.x + item.end.x) / 2; const mYW = (item.start.y + item.end.y) / 2;
        const sP = worldToScreen(mXW, mYW); sSX = sP.x; sSY = sP.y;
    } else { return; }

    const lR = item.labelElement.getBoundingClientRect();
    const cR = canvas.getBoundingClientRect();
    // Etiketin merkezine bağla
    const lCX = lR.left - cR.left + lR.width / 2;
    const lCY = lR.top - cR.top + lR.height / 2;

    ctx.save();
    const dpr = window.devicePixelRatio || 1;
    // drawRadar sonundaki ctx.restore() sonrası bu fonksiyon çağrıldığı için
    // pan/zoom'suz mutlak canvas koordinatlarına geçiş yapmalıyız.
    // sSX, sSY (worldToScreen'den gelen) ve lCX, lCY (DOM'dan gelen) canvas'ın görünen CSS pikselleridir.
    // Canvas context'i zaten DPR'ye göre ölçeklenmiş durumda (resizeCanvas içinde ctx.scale(dpr,dpr)).
    // Bu yüzden doğrudan bu koordinatları kullanabiliriz.
    // Ancak, setLineDash gibi özellikler DPR'den etkilenebilir.
    // En temizi, bu fonksiyonun başında ctx.setTransform(dpr, 0, 0, dpr, 0, 0) yapmak ve
    // sonra koordinatları buna göre ayarlamak ya da lineDash gibi değerleri dpr ile çarpmak.
    // Mevcut yapıda, drawRadar'ın sonundaki ctx.restore() pan/zoom'u sıfırlar ama DPR ölçeklemesini korur.
    // Bu yüzden doğrudan sSX, lCX kullanabiliriz.

    ctx.beginPath();
    ctx.moveTo(sSX, sSY);
    ctx.lineTo(lCX, lCY);

    ctx.strokeStyle = strC;
    ctx.lineWidth = lineWidth; // Kalınlık önceki güncellemeden
    // Noktalı çizgi stilini DPR'ye göre ayarlamak iyi bir pratiktir.
    ctx.setLineDash([2 * dpr, 2 * dpr]);
    ctx.stroke();
    ctx.setLineDash([]); // Çizgi stilini sıfırla
    ctx.restore(); // Eğer bu fonksiyon kendi save/restore'unu yönetiyorsa
}

function drawPlacementMarker(loc) {
    if (!loc) return; ctx.save(); const mS = 8 / zoom; ctx.strokeStyle = 'red'; ctx.lineWidth = 2 / zoom;
    ctx.beginPath(); ctx.moveTo(loc.x - mS, loc.y); ctx.lineTo(loc.x + mS, loc.y);
    ctx.moveTo(loc.x, loc.y - mS); ctx.lineTo(loc.x, loc.y + mS); ctx.stroke(); ctx.restore();
}
function drawMeasurementHighlight(ac) {
    if (!ac) return; ctx.save(); ctx.strokeStyle = 'cyan'; ctx.lineWidth = 2 / zoom;
    const size = 8 / zoom; ctx.strokeRect(ac.x - size / 2, ac.y - size / 2, size, size); ctx.restore();
}

function drawTemporaryMeasurementLine() {
    if (!measurementStartPoint) return;
    const worldMousePos = screenToWorld(lastMouseX, lastMouseY);
    let startX = measurementStartPoint.x; let startY = measurementStartPoint.y;
    if (measurementStartPoint.type === 'aircraft') {
        const ac = aircrafts.find(a => a.id === measurementStartPoint.id);
        if (ac) { startX = ac.x; startY = ac.y; } else { return; }
    }
    ctx.save(); ctx.beginPath(); ctx.moveTo(startX, startY); ctx.lineTo(worldMousePos.x, worldMousePos.y);
    ctx.strokeStyle = 'cyan';
    ctx.lineWidth = (1.5 * 1.5) / zoom; // Kalınlığı 1.5x artırıldı (2.25)
    ctx.setLineDash([4 / zoom, 4 / zoom]); ctx.stroke(); ctx.setLineDash([]); ctx.restore();

    const pointRadius = (3 / zoom) * 1.5; // Nokta yarıçapını da artır
    ctx.save(); ctx.fillStyle = 'cyan'; ctx.beginPath();
    ctx.arc(startX, startY, pointRadius, 0, 2 * Math.PI); ctx.fill(); ctx.restore();
}

function drawMeasurementLine(measurement) {
    ctx.save(); ctx.beginPath();
    ctx.moveTo(measurement.start.x, measurement.start.y);
    ctx.lineTo(measurement.end.x, measurement.end.y);
    ctx.strokeStyle = 'cyan';
    ctx.lineWidth = (1.5 * 1.5) / zoom; // Kalınlığı 1.5x artırıldı (2.25)
    ctx.stroke(); ctx.restore();

    const pointRadius = (2 / zoom) * 1.5; // Nokta yarıçapını da artır
    ctx.save(); ctx.fillStyle = 'cyan';
    ctx.beginPath(); ctx.arc(measurement.start.x, measurement.start.y, pointRadius, 0, 2 * Math.PI); ctx.fill();
    ctx.beginPath(); ctx.arc(measurement.end.x, measurement.end.y, pointRadius, 0, 2 * Math.PI); ctx.fill();
    ctx.restore();
}

// --- Uçak Güncelleme Mantığı ---
function updateAircrafts(deltaTime) {
    const effectiveDeltaTime = deltaTime * gameSpeedMultiplier;
    const aircraftsToRemove = [];
    const airmissPairs = [];

    for (let i = 0; i < aircrafts.length; i++) {
        for (let j = i + 1; j < aircrafts.length; j++) {
            const ac1 = aircrafts[i]; const ac2 = aircrafts[j];
            const dx = ac2.x - ac1.x; const dy = ac2.y - ac1.y;
            const distanceWorldPixels = Math.sqrt(dx * dx + dy * dy);
            const distanceNM = worldPixelsToNm(distanceWorldPixels);
            const verticalSeparation = Math.abs(ac2.altitude - ac1.altitude);
            if (distanceNM < 5 && verticalSeparation < 1000) {
                if (!airmissPairs.some(pair => (pair[0] === ac1 && pair[1] === ac2) || (pair[0] === ac2 && pair[1] === ac1))) {
                    airmissPairs.push([ac1, ac2]);
                }
            }
        }
    }
    updateAirmissAlert(airmissPairs);

    aircrafts.forEach((ac, index) => {
        if (ac.isHandedOffToTower) {
            const distToRunwayCenterWorldPixels = Math.sqrt((ac.x - centerX) ** 2 + (ac.y - centerY) ** 2);
            if (distToRunwayCenterWorldPixels < (RUNWAY_THRESHOLD_DIST_PX / zoom)) {
                if (!aircraftsToRemove.includes(index)) aircraftsToRemove.push(index);
                return;
            }
        }
        const distFromCenterWorldPixels = Math.sqrt((ac.x - centerX) ** 2 + (ac.y - centerY) ** 2);
        const distFromCenterNM = worldPixelsToNm(distFromCenterWorldPixels);
        if (distFromCenterNM > 55) {
            if (!aircraftsToRemove.includes(index)) aircraftsToRemove.push(index);
            return;
        }

        if (ac.altitude !== ac.targetAltitude) {
            const altDiff = ac.targetAltitude - ac.altitude;
            const direction = Math.sign(altDiff); let rate = 0;
            if (direction > 0 && ac.rateOfClimb > 0) rate = ac.rateOfClimb;
            else if (direction < 0 && ac.rateOfDescent > 0) rate = -ac.rateOfDescent;
            else if (direction !== 0) {
                rate = direction * (direction > 0 ? (aircraftPerformanceROC[ac.type] || DEFAULT_CLIMB_RATE) : DEFAULT_ROD);
                if (direction > 0) ac.rateOfClimb = Math.abs(rate); else ac.rateOfDescent = Math.abs(rate);
            }
            if (rate !== 0) {
                const changeAmount = rate * (effectiveDeltaTime / 60);
                if (Math.abs(changeAmount) >= Math.abs(altDiff)) {
                    ac.altitude = ac.targetAltitude; ac.rateOfClimb = 0; ac.rateOfDescent = 0;
                } else { ac.altitude += changeAmount; }
            }
        }

        if (ac.isTakingOff) {
            const distFromTakeoffPointNM = worldPixelsToNm(Math.sqrt((ac.x - centerX) ** 2 + (ac.y - centerY) ** 2));
            if (distFromTakeoffPointNM > 12 || ac.altitude > 7000) {
                ac.isTakingOff = false;
                if (ac.targetWaypoint) {
                    const wp = waypoints.find(w => w.name === ac.targetWaypoint);
                    if (wp) {
                        const wpAngleRad = toRadians(wp.angle);
                        const wpX = centerX + Math.sin(wpAngleRad) * nmToWorldPixels(wp.distanceNM);
                        const wpY = centerY - Math.cos(wpAngleRad) * nmToWorldPixels(wp.distanceNM);
                        ac.targetHeading = Math.round(calculateBearing(ac.x, ac.y, wpX, wpY));
                        ac.turning = true; ac.commandedTurnDirection = 0;
                    }
                }
            }
            if (ac.speedKTS < (defaultAircraftSpeeds[ac.type] || 250) - 20) {
                ac.speedKTS += 1.5 * effectiveDeltaTime;
                if (ac.speedKTS > (defaultAircraftSpeeds[ac.type] || 250) - 20) {
                    ac.speedKTS = (defaultAircraftSpeeds[ac.type] || 250) - 20;
                }
            }
        }

        if (ac.isIntercepting) {
            let targetCourse = (ac.interceptCourse === INTERCEPT_TARGET_COURSE_21L) ? INTERCEPT_TARGET_COURSE_21L : INTERCEPT_TARGET_COURSE_033;
            if (!ac.interceptCourse) ac.interceptCourse = ac.targetHeading;
            targetCourse = ac.interceptCourse;
            const locRad = toRadians(targetCourse);
            const lineEndX = centerX + Math.sin(locRad) * nmToWorldPixels(localizerLengthNM * 2);
            const lineEndY = centerY - Math.cos(locRad) * nmToWorldPixels(localizerLengthNM * 2);
            const distToLocNM = worldPixelsToNm(pointLineDistance(ac.x, ac.y, centerX, centerY, lineEndX, lineEndY));
            if (distToLocNM < ON_LOCALIZER_THRESHOLD_NM) {
                ac.heading = targetCourse; ac.targetHeading = targetCourse;
                ac.turning = false; ac.isIntercepting = false; ac.commandedTurnDirection = 0;
                ac.bankAngle = 0; ac.interceptCourse = null;
            } else { if (!ac.turning) ac.turning = true; }
        }

        // f. Dönüş Mantığı (turning) - GÜNCELLENMİŞ
        if (ac.turning && !ac.isIntercepting) {
            const turnRateDegreesPerFrameUpdate = 3.0; // Her güncelleme adımında 3 derece.
            const updateIntervalSeconds = 1.0 / gameSpeedMultiplier; // Oyun hızına göre 1 saniyelik interval
            const updateIntervalMs = updateIntervalSeconds * 1000;

            if (ac.lastHeadingUpdateTime === undefined || ac.lastHeadingUpdateTime === 0) {
                ac.lastHeadingUpdateTime = performance.now();
            }
            const currentTimeMs = performance.now();

            if (currentTimeMs - ac.lastHeadingUpdateTime >= updateIntervalMs) {
                ac.lastHeadingUpdateTime = currentTimeMs;
                const diffToTarget = angleDiff(ac.targetHeading, ac.heading);
                const arrivalThreshold = turnRateDegreesPerFrameUpdate + 0.5;

                if (Math.abs(diffToTarget) < arrivalThreshold) {
                    ac.heading = ac.targetHeading;
                    ac.turning = false;
                    // ac.bankAngle = 0; // Bank açısı yumuşakça sıfırlanacak
                    ac.commandedTurnDirection = 0;
                } else {
                    let turnDirectionForStep = ac.commandedTurnDirection;
                    if (turnDirectionForStep === 0) {
                        turnDirectionForStep = Math.sign(diffToTarget);
                    }
                    const turnAmount = turnDirectionForStep * turnRateDegreesPerFrameUpdate;
                    ac.heading = (ac.heading + turnAmount + 360) % 360;
                }
            }
            // Bank açısını yumuşakça hedef bank açısına getirme (her frame'de çalışabilir)
            if (ac.turning) {
                let turnDirectionForBank = ac.commandedTurnDirection;
                 if (turnDirectionForBank === 0) {
                    const diffToTargetForBank = angleDiff(ac.targetHeading, ac.heading);
                    if (Math.abs(diffToTargetForBank) > 0.5) {
                        turnDirectionForBank = Math.sign(diffToTargetForBank);
                    } else { turnDirectionForBank = 0; }
                }
                let requiredBank = Math.min(ac.maxBankAngle, (ac.speedKTS / 10) + 7);
                const targetBankAngle = turnDirectionForBank * requiredBank;
                ac.bankAngle += (targetBankAngle - ac.bankAngle) * (effectiveDeltaTime * 5); // 5 yumuşatma faktörü
                if (Math.abs(ac.bankAngle - targetBankAngle) < 0.5) ac.bankAngle = targetBankAngle;
            }

        } else if (!ac.isIntercepting) { // Dönmüyor ve intercept etmiyorsa
            ac.bankAngle += (0 - ac.bankAngle) * (effectiveDeltaTime * 5); // Bank açısını yumuşakça sıfırla
            if (Math.abs(ac.bankAngle) < 0.1) ac.bankAngle = 0;
        }

        const speedNMPerSecond = ac.speedKTS / 3600;
        const distanceNM = speedNMPerSecond * effectiveDeltaTime;
        const worldDistancePixels = nmToWorldPixels(distanceNM);
        const rad = toRadians(ac.heading);
        ac.x += Math.sin(rad) * worldDistancePixels;
        ac.y -= Math.cos(rad) * worldDistancePixels;
    });

    if (aircraftsToRemove.length > 0) {
        for (let i = aircraftsToRemove.length - 1; i >= 0; i--) {
            const indexToRemove = aircraftsToRemove[i];
            const removedAircraft = aircrafts[indexToRemove];
            if (removedAircraft) {
                if (removedAircraft.labelElement) removedAircraft.labelElement.remove();
                if (selectedAircraft && selectedAircraft.id === removedAircraft.id) {
                    selectedAircraft = null; if(popup) popup.style.display = 'none';
                }
                aircrafts.splice(indexToRemove, 1);
            }
        }
        updateTopCenterButtonStates();
    }
}

function updateAirmissAlert(airmissPairs) {
    const airmissAlert = document.getElementById('airmissAlert');
    const airmissCallsigns = document.getElementById('airmissCallsigns');
    if (airmissPairs.length > 0) {
        const [ac1, ac2] = airmissPairs[0];
        airmissCallsigns.textContent = `${ac1.id} - ${ac2.id}`;
        airmissAlert.style.display = 'block';
    } else {
        airmissAlert.style.display = 'none';
        airmissCallsigns.textContent = '';
    }
}

function showRunwaySelection() {
    if (runwaySelectionModal) runwaySelectionModal.style.display = 'flex';
}
function hideRunwaySelection() {
    if (runwaySelectionModal) runwaySelectionModal.style.display = 'none';
}

function initializeScenarioGeneration(activeRunway) {
   
    // --- YENİ EKLENEN SATIR: gameSpeedMultiplier'ı slider'dan yeniden oku ---
    gameSpeedMultiplier = speedMultipliers[parseInt(speedSlider.value)];
    // speedFactor'ı da senkronize et (eğer başka yerlerde speedFactor kullanılıyorsa)
    speedFactor = gameSpeedMultiplier;


    hideRunwaySelection(); // Seçim yapıldıktan sonra modalı gizle

    // --- 1. ZAMANLAYICIYI SIFIRLA VE 10:00:00'DAN BAŞLAT ---
    elapsedTime = 36000; // 10 saat = 10 * 60 * 60 saniye

    // Mevcut zamanlayıcı interval'ini durdur (eğer çalışıyorsa)
    if (timerInterval) {
        clearInterval(timerInterval);
        timerInterval = null; // ID'yi temizle
    }

    // Oyunun duraklatılmış olma durumunu kaldır (yeni senaryo başladığında oyun çalışsın)
    if (isPaused) {
        isPaused = false;
        playPauseButton.textContent = 'Durdur';
        playPauseButton.classList.remove('paused');
        // lastTime'ın oyun döngüsü için güncellenmesi gerekebilir,
        // ve eğer animasyon frame'i durmuşsa yeniden başlatılması.
        // Bu, genellikle toggleTimer(false) içinde veya benzer bir yerde yapılır.
        // Şimdilik, startGameTimer'ın !isPaused durumuna göre interval'i başlatacağını varsayıyoruz.
    }

    // Zamanlayıcıyı yeni elapsedTime değeriyle hemen başlat ve DOM'da göster
    // startGameTimer fonksiyonu, isPaused false ise interval'i de başlatacaktır.
    startGameTimer();
    // --- ZAMANLAYICI SIFIRLAMA SONU ---

    // 2. ÖNCEKİ UÇAK SPAWN ZAMANLAYICILARINI TEMİZLE
    if (activeScenarioTimeouts && activeScenarioTimeouts.length > 0) {
        activeScenarioTimeouts.forEach(timeoutId => clearTimeout(timeoutId));
        activeScenarioTimeouts = []; // Diziyi de boşaltmak iyi bir pratik
    }

    // Loglama (opsiyonel, hata ayıklama için)
    console.log(`YENİ SENARYO BAŞLADI - Zaman: ${formatTime(elapsedTime)}, Oyun Hızı (gameSpeedMultiplier): ${gameSpeedMultiplier}x`);

    // 3. Mevcut uçakları ve etiketlerini temizle
    aircrafts.forEach(ac => {
        if (ac.labelElement) ac.labelElement.remove();
    });
    aircrafts.length = 0;
    selectedAircraft = null;
    updateTopCenterButtonStates(); // Buton durumlarını güncelle
    if (popup) popup.style.display = 'none'; // Açık popup varsa kapat
    scenarioAircraftIdCounter = 0; // Senaryoya özel sayaç sıfırlanır

    // 4. Oyun döngüsünün çalıştığından emin ol (eğer duraklatılmışsa ve yeniden başlatıldıysa)
    // Eğer isPaused true iken buraya gelindiyse ve false yapıldıysa, gameLoop'un devam etmesi gerekir.
    if (!isPaused) { // Bu koşul yukarıda false yapıldığı için her zaman true olacak.
        lastTime = performance.now(); // Oyun döngüsü için lastTime'ı güncelle
        if (!animationFrameId && gameLoop) { // gameLoop tanımlıysa ve animationFrameId yoksa (yani durmuşsa)
            // gameLoop(lastTime); // Yeniden başlat. Eğer gameLoop zaten requestAnimationFrame ile çalışıyorsa,
                               // isPaused = false; olması yeterli olabilir.
            // playPauseButton olay dinleyicisindeki mantık zaten bunu handle ediyor olabilir.
            // En güvenlisi, eğer oyun durmuşsa ve devam ettiriliyorsa, game loop'u da tetiklemek.
            // Ancak, toggleTimer(false) çağrısı yapıyorsak bu zaten içerebilir.
            // Şimdilik, toggleTimer'ı doğrudan çağırmadık, startGameTimer kullandık.
            // Bu yüzden, eğer oyun döngüsü isPaused'a bağlıysa, isPaused = false yapmak yeterli.
            // Eğer ayrıca başlatmak gerekiyorsa:
            if (!animationFrameId) { // Eğer gameLoop bir şekilde durmuşsa
                 requestAnimationFrame(gameLoop); // Veya gameLoop(performance.now());
            }
        }
    }


    // --- PİST VE HEDEF NOKTA AYARLARI ---
    const localizerCourse = activeRunway === '03R' ? INTERCEPT_TARGET_COURSE_033 : INTERCEPT_TARGET_COURSE_21L;
    let targetPointAngleDeg;
    if (activeRunway === '03R') {
        targetPointAngleDeg = (localizerCourse + 180) % 360;
    } else { // 21L
        targetPointAngleDeg = (localizerCourse + 180) % 360;
    }
    const targetPointAngleRad = toRadians(targetPointAngleDeg);
    const targetPointDistanceNM = 12;
    const targetPointX = centerX + Math.sin(targetPointAngleRad) * nmToWorldPixels(targetPointDistanceNM);
    const targetPointY = centerY - Math.cos(targetPointAngleRad) * nmToWorldPixels(targetPointDistanceNM);

    // --- İNİŞ TRAFİĞİ (Arrivals) ---
    const numArrivals = 5;
    const arrivalSpawnWindowSeconds = 60;
    let availableWaypointsForScenario = [...waypoints].sort(() => 0.5 - Math.random());
    const baseWaypoints = [...waypoints]; // Orijinal waypoints listesini kopyala

    if (availableWaypointsForScenario.length < 4 && baseWaypoints.length > 0) {
        console.warn("İniş senaryosu için yeterli sayıda farklı waypoint yok. Mevcut waypointler tekrar kullanılacak.");
        while(availableWaypointsForScenario.length < 4 && baseWaypoints.length > 0) {
            availableWaypointsForScenario.push(baseWaypoints[Math.floor(Math.random() * baseWaypoints.length)]);
        }
    } else if (baseWaypoints.length === 0) {
         console.error("Hiç waypoint tanımlı değil. İniş trafiği waypointler üzerinden üretilemiyor.");
    }

    let arrivalWaypointsSelection = [];
    if (availableWaypointsForScenario.length >= 4) {
        const wp_double_use = availableWaypointsForScenario.pop();
        const wp_single_use1 = availableWaypointsForScenario.pop();
        const wp_single_use2 = availableWaypointsForScenario.pop();
        const wp_single_use3 = availableWaypointsForScenario.pop();
        arrivalWaypointsSelection = [wp_double_use, wp_double_use, wp_single_use1, wp_single_use2, wp_single_use3];
    } else if (availableWaypointsForScenario.length > 0) {
        for(let k=0; k < numArrivals; k++) {
            arrivalWaypointsSelection.push(availableWaypointsForScenario[k % availableWaypointsForScenario.length]);
        }
    }
    arrivalWaypointsSelection.sort(() => 0.5 - Math.random());
    let firstFLForWaypoint = {};

    for (let i = 0; i < numArrivals; i++) {
        if (arrivalWaypointsSelection.length === 0) break;
        const spawnTimeSeconds = Math.random() * arrivalSpawnWindowSeconds;
        const waypoint = arrivalWaypointsSelection[i % arrivalWaypointsSelection.length];
        const wpAngleRad = toRadians(waypoint.angle);
        const spawnX = centerX + Math.sin(wpAngleRad) * nmToWorldPixels(waypoint.distanceNM);
        const spawnY = centerY - Math.cos(wpAngleRad) * nmToWorldPixels(waypoint.distanceNM);
        const bearingToTargetPoint = calculateBearing(spawnX, spawnY, targetPointX, targetPointY);
        let baseFLArr = Math.floor(Math.random() * (22 - 13 + 1)) + 13;
        let altitudeFLArr = baseFLArr * 10;
        const waypointKey = waypoint.name;
        if (firstFLForWaypoint[waypointKey] === undefined) {
            firstFLForWaypoint[waypointKey] = altitudeFLArr;
        } else {
            let attempts = 0; const originalFL = firstFLForWaypoint[waypointKey];
            while (altitudeFLArr === originalFL && attempts < 20) {
                baseFLArr = Math.floor(Math.random() * (22 - 13 + 1)) + 13;
                altitudeFLArr = baseFLArr * 10; attempts++;
            }
        }
        const altitudeFeetArr = altitudeFLArr * 100;
        const acTypeArr = aircraftTypes[Math.floor(Math.random() * aircraftTypes.length)];
        const realTimeDelayArrMs = spawnTimeSeconds * 1000 / gameSpeedMultiplier;

        const timeoutIdArrival = setTimeout(() => {
            const currentElapsedTimeAtSpawn = elapsedTime;
            scenarioAircraftIdCounter++;
            const callsignArr = (callsignPrefixes[Math.floor(Math.random() * callsignPrefixes.length)]) + (100 + scenarioAircraftIdCounter);
            const aircraft = {
                id: callsignArr, x: spawnX, y: spawnY,
                heading: Math.round(bearingToTargetPoint), targetHeading: Math.round(bearingToTargetPoint),
                speedKTS: defaultAircraftSpeeds[acTypeArr] || 230, altitude: altitudeFeetArr, targetAltitude: altitudeFeetArr,
                rateOfDescent: 0, rateOfClimb: 0, isTakingOff: false, takeoffRunway: null,
                isIntercepting: false, isHandedOffToTower: false, showVector: false, labelElement: null,
                labelX: 0, labelY: 0, labelDragged: true, bankAngle: 0, maxBankAngle: 25,
                commandedTurnDirection: 0, turning: false, type: acTypeArr, departureTargetFL: null,
                showInfoPanel: false, draggedLabelDeltaX: 0, draggedLabelDeltaY: 0,
                lastHeadingUpdateTime: 0, initialPosSet: true, targetWaypoint: null
            };
            aircrafts.push(aircraft);
            console.log(`ARRIVAL: Uçak ${aircraft.id} oyuna eklendi. Oyun Zamanı: ${formatTime(currentElapsedTimeAtSpawn)}`);
        }, realTimeDelayArrMs);
        activeScenarioTimeouts.push(timeoutIdArrival);
    }

    // --- KALKIŞ TRAFİĞİ (Departures) ---
	// kalkış zamanlaması
    const departureSpawnTimes = [
        Math.random() * 30,
        120 + (Math.random() * 40)
    ];
    let waypointsForDeparture = [...waypoints].sort(() => 0.5 - Math.random());
    if (waypointsForDeparture.length === 0 && baseWaypoints.length > 0) {
        waypointsForDeparture.push(baseWaypoints[Math.floor(Math.random() * baseWaypoints.length)]);
    }

    console.log("--- Kalkış Uçakları Zamanlaması (Yeni senaryo başlangıcına göre) ---");
    departureSpawnTimes.forEach((spawnDelay, index) => {
        const aircraftNum = index + 1;
        const realTimeDelayForTimeout = spawnDelay * 1000 / gameSpeedMultiplier;
        // elapsedTime burada sıfırlanmış 10:00:00'a göre hesap yapar.
        const expectedGameTimeAtSpawn = elapsedTime + spawnDelay; 

        console.log(`Kalkış Uçağı #${aircraftNum}:`);
        console.log(`  Planlanan Kalkış Gecikmesi (Oyun Zamanı): ${spawnDelay.toFixed(1)}s (yeni senaryo zamanına göre)`);
        console.log(`  Kullanılan gameSpeedMultiplier: ${gameSpeedMultiplier}`);
        console.log(`  Hesaplanan Gerçek Zaman Gecikmesi (setTimeout için): ${realTimeDelayForTimeout.toFixed(0)}ms`);
        console.log(`  Bu uçağın kalkışında BEKLENEN Oyun Zamanı (HH:MM:SS): ${formatTime(expectedGameTimeAtSpawn)}`);
    });

    for (let i = 0; i < departureSpawnTimes.length; i++) {
        const takeoffTimeSeconds = departureSpawnTimes[i];
        const aircraftIndexForLog = i + 1;
        const realTimeDelayMs = takeoffTimeSeconds * 1000 / gameSpeedMultiplier;

        const timeoutIdDeparture = setTimeout(() => {
            const currentTimeOfSpawn = elapsedTime;
            const acType = aircraftTypes[Math.floor(Math.random() * aircraftTypes.length)];
            scenarioAircraftIdCounter++;
            const callsignNumberBase = (aircraftIndexForLog === 1) ? 100 : 500;
            const callsign = (callsignPrefixes[Math.floor(Math.random() * callsignPrefixes.length)]) + (callsignNumberBase + scenarioAircraftIdCounter);
            const departureTargetBaseFL = Math.floor(Math.random() * (28 - 18 + 1)) + 18;
            const departureTargetFL = departureTargetBaseFL * 10;
            const climbRate = aircraftPerformanceROC[acType] || DEFAULT_CLIMB_RATE;
            let takeoffTargetWaypointName = null;
            if (waypointsForDeparture.length > 0) {
                takeoffTargetWaypointName = waypointsForDeparture[i % waypointsForDeparture.length].name;
            } else {
                console.warn(`Kalkış yapan ${callsign} için hedef waypoint bulunamadı.`);
            }
            const aircraft = {
                id: callsign, x: centerX, y: centerY, heading: localizerCourse, targetHeading: localizerCourse,
                speedKTS: 160, altitude: 0, targetAltitude: departureTargetFL * 100,
                rateOfClimb: climbRate, rateOfDescent: 0, isTakingOff: true, takeoffRunway: activeRunway,
                isIntercepting: false, isHandedOffToTower: false, showVector: false, labelElement: null,
                labelX: 0, labelY: 0, labelDragged: true, bankAngle: 0, maxBankAngle: 25,
                commandedTurnDirection: 0, turning: false, type: acType, departureTargetFL: departureTargetFL,
                showInfoPanel: false, draggedLabelDeltaX: 0, draggedLabelDeltaY: 0,
                lastHeadingUpdateTime: 0, initialPosSet: true, targetWaypoint: takeoffTargetWaypointName
            };
            aircrafts.push(aircraft);
            console.log(`KALKIŞ GERÇEKLEŞTİ: Uçak #${aircraftIndexForLog} (${aircraft.id}) oyuna eklendi. Oyun Zamanı: ${formatTime(currentTimeOfSpawn)}`);
        }, realTimeDelayMs);
        activeScenarioTimeouts.push(timeoutIdDeparture);
    }
    console.log("Senaryo üretimi tamamlandı ve tüm zamanlayıcılar (uçak spawn) kuruldu.");
}

function updateMeasurementData() {
    measurements.forEach(m => {
        let needsCoordUpdate = false; let needsAltUpdate = false;
        if (m.start.type === 'aircraft') {
            const ac = aircrafts.find(a => a.id === m.start.id);
            if (ac && (m.start.x !== ac.x || m.start.y !== ac.y)) { m.start.x = ac.x; m.start.y = ac.y; needsCoordUpdate = true; }
            else if (!ac) { if(m.labelElement) m.labelElement.remove(); measurements = measurements.filter(meas => meas.id !== m.id); return; }
        }
        if (m.end.type === 'aircraft') {
            const ac = aircrafts.find(a => a.id === m.end.id);
            if (ac && (m.end.x !== ac.x || m.end.y !== ac.y)) { m.end.x = ac.x; m.end.y = ac.y; needsCoordUpdate = true; }
            else if (!ac) { if(m.labelElement) m.labelElement.remove(); measurements = measurements.filter(meas => meas.id !== m.id); return; }
        }
        if (m.start.type === 'runwayCenter' && m.end.type === 'aircraft') {
            const endAc = aircrafts.find(a => a.id === m.end.id);
            if (!endAc) { if(m.labelElement) m.labelElement.remove(); measurements = measurements.filter(meas => meas.id !== m.id); return; }
        } else if (m.start.type === 'aircraft' && m.end.type === 'runwayCenter') {
            const startAc = aircrafts.find(a => a.id === m.start.id);
            if (!startAc) { if(m.labelElement) m.labelElement.remove(); measurements = measurements.filter(meas => meas.id !== m.id); return; }
        }

        const dx = m.end.x - m.start.x; const dy = m.end.y - m.start.y;
        const distanceWorldPixels = Math.sqrt(dx * dx + dy * dy); const newDistanceNM = worldPixelsToNm(distanceWorldPixels);
        const newBearing = calculateBearing(m.start.x, m.start.y, m.end.x, m.end.y); const newReciprocalBearing = (newBearing + 180) % 360;
        let newEstimatedAltitude = null; let newRelativeBearing1 = null; let newRelativeBearing2 = null;
        if (m.start.type === 'aircraft') {
            const startAircraft = aircrafts.find(a => a.id === m.start.id);
            if (startAircraft) {
                if (m.end.type === 'point' || m.end.type === 'runwayCenter') {
                    if (startAircraft.speedKTS > 0) {
                        const timeHours = newDistanceNM / startAircraft.speedKTS; const timeMinutes = timeHours * 60;
                        let verticalDirection = 0; if (startAircraft.altitude !== startAircraft.targetAltitude) { verticalDirection = Math.sign(startAircraft.targetAltitude - startAircraft.altitude); }
                        let effectiveRodMagnitude = 0;
                        if (startAircraft.rateOfDescent !== 0 && verticalDirection < 0) { effectiveRodMagnitude = Math.abs(startAircraft.rateOfDescent);
                        } else if (startAircraft.rateOfClimb !== 0 && verticalDirection > 0) { effectiveRodMagnitude = Math.abs(startAircraft.rateOfClimb);
                        } else if (verticalDirection !== 0) { effectiveRodMagnitude = verticalDirection > 0 ? DEFAULT_CLIMB_RATE : DEFAULT_ROD; }
                        const altitudeChange = verticalDirection * effectiveRodMagnitude * timeMinutes;
                        newEstimatedAltitude = startAircraft.altitude + altitudeChange; newEstimatedAltitude = Math.max(0, newEstimatedAltitude);
                    }
                } else if (m.end.type === 'aircraft') {
                    const endAircraft = aircrafts.find(a => a.id === m.end.id);
                    if (endAircraft) { newRelativeBearing1 = angleDiff(newBearing, startAircraft.heading); newRelativeBearing2 = angleDiff(newReciprocalBearing, endAircraft.heading); }
                }
            }
        } else if (m.start.type === 'runwayCenter' && m.end.type === 'aircraft') {
            const endAircraft = aircrafts.find(a => a.id === m.end.id);
            if(endAircraft){ newRelativeBearing2 = angleDiff(newReciprocalBearing, endAircraft.heading); }
        }

        if (m.distanceNM !== newDistanceNM || m.estimatedAltitude !== newEstimatedAltitude || m.bearing !== newBearing || m.relativeBearing1 !== newRelativeBearing1 || m.relativeBearing2 !== newRelativeBearing2) {
            m.distanceNM = newDistanceNM; m.estimatedAltitude = newEstimatedAltitude; m.bearing = newBearing; m.reciprocalBearing = newReciprocalBearing; m.relativeBearing1 = newRelativeBearing1; m.relativeBearing2 = newRelativeBearing2;
            needsAltUpdate = true;
        }
        if ((needsCoordUpdate || needsAltUpdate) && m.labelElement) {
            let labelContent = "";
            if (m.start.type === 'aircraft' && m.end.type === 'aircraft') {
                const relativeBearingText = `<span class="measurement-relative-bearing">${formatRelativeBearing(m.relativeBearing1)} / ${formatRelativeBearing(m.relativeBearing2)}</span>`;
                const distAltText = `<span class="measurement-dist-alt">${m.distanceNM.toFixed(1)} NM</span>`;
                labelContent = relativeBearingText + distAltText;
            } else if ((m.start.type === 'aircraft' && m.end.type === 'runwayCenter') || (m.start.type === 'runwayCenter' && m.end.type === 'aircraft')) {
                const bearingText = `<span class="measurement-bearing">${formatBearing(m.bearing)} / ${formatBearing(m.reciprocalBearing)}</span>`;
                let distAltText = `<span class="measurement-dist-alt">${m.distanceNM.toFixed(1)} NM`;
                let extraInfo = "";
                if (m.start.type === 'aircraft' && m.estimatedAltitude !== null && m.estimatedAltitude !== undefined) {
                    distAltText += ` / ~${formatFlightLevel(m.estimatedAltitude)} (to RWY)`;
                } else if (m.start.type === 'runwayCenter' && m.end.type === 'aircraft') {
                    const acEnd = aircrafts.find(a => a.id === m.end.id);
                    if (acEnd) {
                        distAltText += ` / ${formatFlightLevel(acEnd.altitude)}`;
                        if(m.relativeBearing2 !== null) { extraInfo = `<span class="measurement-relative-bearing">AC to RWY: ${formatRelativeBearing(m.relativeBearing2)}</span>`; }
                    }
                }
                distAltText += `</span>`; labelContent = bearingText + extraInfo + distAltText;
            } else {
                const bearingText = `<span class="measurement-bearing">${formatBearing(m.bearing)} / ${formatBearing(m.reciprocalBearing)}</span>`;
                let distAltText = `<span class="measurement-dist-alt">${m.distanceNM.toFixed(1)} NM`;
                if (m.estimatedAltitude !== null && m.estimatedAltitude !== undefined) { distAltText += ` / ~${formatFlightLevel(m.estimatedAltitude)}`; }
                distAltText += `</span>`; labelContent = bearingText + distAltText;
            }
            m.labelElement.innerHTML = labelContent;
        }
    });
}

function startLabelDrag(event, item, type) {
    if (event.button !== 1) return; event.preventDefault();
    isDraggingLabel = true; draggedLabelItem = item; draggedLabelType = type;
    const labelRect = item.labelElement.getBoundingClientRect();
    dragOffsetX = event.clientX - labelRect.left; dragOffsetY = event.clientY - labelRect.top;
    item.labelElement.classList.add('dragging');
}

function updateAircraftLabelPositionDOM(ac) {
    const currentFL = formatFlightLevel(ac.altitude);
    const targetFL = formatFlightLevel(ac.targetAltitude);
    if (!ac.labelElement) {
        ac.labelElement = document.createElement('div');
        ac.labelElement.className = 'dynamic-label aircraft-label';
        ac.labelElement.dataset.aircraftId = ac.id;
        document.body.appendChild(ac.labelElement);
        ac.labelElement.innerHTML = `
            <div class="label-line label-id">${ac.id}</div>
            <div class="aircraft-info-panel" style="display: none;">
                <div>Tip: <span class="info-type"></span><span class="info-dep-waypoint" style="margin-left: 8px; font-weight: bold;"></span></div>
                <div class="info-target-fl-line" style="display: none;">Hedef FL: <span class="info-target-fl"></span></div>
            </div>
            <div class="label-line clickable-line" data-field="heading">${Math.round(ac.heading)}°</div>
            <div class="label-line clickable-line" data-field="speedKTS">${Math.round(ac.speedKTS)}kts</div>
            <div class="label-line altitude-line">
                <span class="current-altitude">${currentFL}</span>
                <span class="target-altitude clickable-line" data-field="altitude">⇢${targetFL}</span>
                <span class="clickable-line" data-field="rateOfDescent"> RoD ${ac.rateOfDescent > 0 ? ac.rateOfDescent : (ac.rateOfClimb > 0 ? `+${ac.rateOfClimb}` : '0')}</span>
            </div>`;
        ac.labelElement.addEventListener('click', (e) => {
            const clickableTarget = e.target.closest('.clickable-line[data-field], .label-id');
            if (!clickableTarget) return;
            e.stopPropagation();
            selectedAircraft = aircrafts.find(a => a.id === ac.id);
            if (selectedAircraft) {
                document.querySelectorAll('.aircraft-label.selected').forEach(el => el.classList.remove('selected'));
                ac.labelElement.classList.add('selected');
                updateTopCenterButtonStates();
                if (clickableTarget.classList.contains('label-id')) {
                    selectedAircraft.showInfoPanel = !selectedAircraft.showInfoPanel;
                    updateAircraftLabelPositionDOM(selectedAircraft);
                } else {
                    const field = clickableTarget.dataset.field;
                    if (field) {
                        if (field === 'altitude' && !clickableTarget.classList.contains('target-altitude')) return;
                        showPopupForField(e.clientX, e.clientY, field);
                    }
                }
            }
        });
        ac.labelElement.addEventListener('mousedown', (e) => { startLabelDrag(e, ac, 'aircraft'); });
    }
    ac.labelElement.querySelector('.label-id').textContent = ac.id;
    ac.labelElement.querySelector('[data-field="heading"]').textContent = `${Math.round(ac.heading)}°`;
    ac.labelElement.querySelector('[data-field="speedKTS"]').textContent = `${Math.round(ac.speedKTS)}kts`;
    ac.labelElement.querySelector('.current-altitude').textContent = currentFL;
    ac.labelElement.querySelector('.target-altitude').textContent = `⇢${targetFL}`;
    ac.labelElement.querySelector('[data-field="rateOfDescent"]').textContent = ` RoD ${ac.rateOfDescent > 0 ? ac.rateOfDescent : (ac.rateOfClimb > 0 ? `+${ac.rateOfClimb}` : '0')}`;
    const infoPanel = ac.labelElement.querySelector('.aircraft-info-panel');
    const infoTypeSpan = infoPanel.querySelector('.info-type');
    const infoDepWaypointSpan = infoPanel.querySelector('.info-dep-waypoint');
    const infoTargetFLLine = infoPanel.querySelector('.info-target-fl-line');
    const infoTargetFLSpan = infoPanel.querySelector('.info-target-fl');
    if (ac.showInfoPanel) {
        infoPanel.style.display = 'block';
        infoTypeSpan.textContent = ac.type || 'N/A';
        if (ac.departureTargetFL && ac.targetWaypoint) {
            infoDepWaypointSpan.textContent = ac.targetWaypoint;
            infoDepWaypointSpan.style.display = 'inline';
        } else { infoDepWaypointSpan.textContent = ''; infoDepWaypointSpan.style.display = 'none'; }
        if (ac.departureTargetFL) {
            infoTargetFLLine.style.display = 'block';
            infoTargetFLSpan.textContent = `FL${ac.departureTargetFL}`;
        } else { infoTargetFLLine.style.display = 'none'; }
    } else { infoPanel.style.display = 'none'; }

    if (!(isDraggingLabel && draggedLabelItem === ac)) {
        const screenPos = worldToScreen(ac.x, ac.y);
        if (ac.labelDragged) {
            ac.labelX = screenPos.x + ac.draggedLabelDeltaX;
            ac.labelY = screenPos.y + ac.draggedLabelDeltaY;
        } else {
            ac.labelX = screenPos.x + 15;
            ac.labelY = screenPos.y - (ac.labelElement ? ac.labelElement.offsetHeight / 2 : 10);
        }
        if (ac.labelElement) {
            const labelWidth = ac.labelElement.offsetWidth;
            const labelHeight = ac.labelElement.offsetHeight;
            ac.labelX = Math.max(0, Math.min(ac.labelX, window.innerWidth - labelWidth));
            ac.labelY = Math.max(0, Math.min(ac.labelY, window.innerHeight - labelHeight));
            ac.labelElement.style.left = `${ac.labelX}px`;
            ac.labelElement.style.top = `${ac.labelY}px`;
        }
    }
    if (ac.labelElement) {
        ac.labelElement.style.fontSize = `${labelFontSize}px`;
        ac.labelElement.classList.toggle('selected', ac === selectedAircraft);
        ac.labelElement.classList.toggle('glow', !!ac.highlighted);
    }
}

function createMeasurementLabel(measurement) {
    const label = document.createElement('div');
    label.className = 'dynamic-label measurement-label';
    label.dataset.measurementId = measurement.id;
    let labelContent = "";
    if (measurement.start.type === 'aircraft' && measurement.end.type === 'aircraft') {
        const relativeBearingText = `<span class="measurement-relative-bearing">${formatRelativeBearing(measurement.relativeBearing1)} / ${formatRelativeBearing(measurement.relativeBearing2)}</span>`;
        const distAltText = `<span class="measurement-dist-alt">${measurement.distanceNM.toFixed(1)} NM</span>`;
        labelContent = relativeBearingText + distAltText;
    } else if ((measurement.start.type === 'aircraft' && measurement.end.type === 'runwayCenter') || (measurement.start.type === 'runwayCenter' && measurement.end.type === 'aircraft')) {
        const bearingText = `<span class="measurement-bearing">${formatBearing(measurement.bearing)} / ${formatBearing(measurement.reciprocalBearing)}</span>`;
        let distAltText = `<span class="measurement-dist-alt">${measurement.distanceNM.toFixed(1)} NM`;
        let extraInfo = "";
        if (measurement.start.type === 'aircraft' && measurement.estimatedAltitude !== null && measurement.estimatedAltitude !== undefined) {
            distAltText += ` / ~${formatFlightLevel(measurement.estimatedAltitude)} (to RWY)`;
        } else if (measurement.start.type === 'runwayCenter' && measurement.end.type === 'aircraft') {
            const acEnd = aircrafts.find(a => a.id === measurement.end.id);
            if (acEnd) {
                distAltText += ` / ${formatFlightLevel(acEnd.altitude)}`;
                if(measurement.relativeBearing2 !== null) { extraInfo = `<span class="measurement-relative-bearing">AC to RWY: ${formatRelativeBearing(measurement.relativeBearing2)}</span>`; }
            }
        }
        distAltText += `</span>`; labelContent = bearingText + extraInfo + distAltText;
    } else {
        const bearingText = `<span class="measurement-bearing">${formatBearing(measurement.bearing)} / ${formatBearing(measurement.reciprocalBearing)}</span>`;
        let distAltText = `<span class="measurement-dist-alt">${measurement.distanceNM.toFixed(1)} NM`;
        if (measurement.estimatedAltitude !== null && measurement.estimatedAltitude !== undefined) { distAltText += ` / ~${formatFlightLevel(measurement.estimatedAltitude)}`; }
        distAltText += `</span>`; labelContent = bearingText + distAltText;
    }
    label.innerHTML = labelContent; document.body.appendChild(label);
    measurement.labelElement = label; measurement.labelDragged = false;
    measurement.draggedLabelDeltaX = 0; measurement.draggedLabelDeltaY = 0;
    updateMeasurementLabelPositionDOM(measurement);
    label.addEventListener('mousedown', (e) => startLabelDrag(e, measurement, 'measurement'));
    label.addEventListener('contextmenu', (e) => {
        e.preventDefault(); measurements = measurements.filter(m => m.id !== measurement.id); label.remove();
    });
}
function updateMeasurementLabelPositionDOM(measurement) {
    if (measurement.labelElement) {
        if (!(isDraggingLabel && draggedLabelItem === measurement)) {
            const midXWorld = (measurement.start.x + measurement.end.x) / 2;
            const midYWorld = (measurement.start.y + measurement.end.y) / 2;
            const screenPos = worldToScreen(midXWorld, midYWorld);
            const labelHeight = measurement.labelElement.offsetHeight || 20;
            if (measurement.labelDragged) {
                measurement.labelX = screenPos.x + measurement.draggedLabelDeltaX;
                measurement.labelY = screenPos.y + measurement.draggedLabelDeltaY;
            } else {
                measurement.labelX = screenPos.x + 10;
                measurement.labelY = screenPos.y - (labelHeight / 2);
            }
            const labelWidth = measurement.labelElement.offsetWidth || 80;
            measurement.labelX = Math.max(0, Math.min(measurement.labelX, window.innerWidth - labelWidth));
            measurement.labelY = Math.max(0, Math.min(measurement.labelY, window.innerHeight - labelHeight));
            measurement.labelElement.style.left = `${measurement.labelX}px`;
            measurement.labelElement.style.top = `${measurement.labelY}px`;
        }
        measurement.labelElement.style.fontSize = `${labelFontSize}px`;
    }
}

function showPopupForField(x, y, field) {
    if (!selectedAircraft) return; popup.innerHTML = '';
    let values = []; let current;
    let tempCommandedTurnDirection = (selectedAircraft.turning && selectedAircraft.commandedTurnDirection !== 0) ? selectedAircraft.commandedTurnDirection : 0;
    if (field === 'heading') {
        current = selectedAircraft.targetHeading;
        popup.innerHTML = `
            <div id="headingValues" style="max-height: 140px; overflow-y: auto; scrollbar-width: thin; scrollbar-color: #0f0 #555; margin-bottom: 5px;"></div>
            <div id="turnButtons" style="margin-bottom: 5px;">
                <div class="turn-btn control-button" data-direction="-1">LEFT</div>
                <div class="turn-btn control-button" data-direction="1">RIGHT</div>
            </div>
            <div id="manualHeadingEntry" style="display: flex; align-items: center; border-top: 1px solid #777; padding-top: 5px;">
                <input type="number" id="manualHeadingInput" min="0" max="359" step="1" style="width: 50px; text-align: right; margin-right: 5px; padding: 3px; font-size:12px; background-color: #eee; color: #333; border: 1px solid #777; border-radius:2px;" placeholder="HDG">
                <button id="submitManualHeading" class="control-button" style="padding: 3px 8px; font-size: 11px; min-width: unset; margin-bottom:0px; background-color: #4CAF50; border-color: #4CAF50;">Set</button>
            </div>`;
        const headingValuesContainer = document.getElementById('headingValues');
        const turnButtonsContainer = document.getElementById('turnButtons');
        const manualHeadingInput = document.getElementById('manualHeadingInput');
        const submitManualHeadingBtn = document.getElementById('submitManualHeading');
        const applyHeadingChange = (newHeadingStr) => {
            const newHeading = parseInt(newHeadingStr, 10);
            if (isNaN(newHeading) || newHeading < 0 || newHeading > 359) {
                if (parseInt(newHeadingStr, 10) === 360) { selectedAircraft.targetHeading = 0; }
                else {
                    if(manualHeadingInput) manualHeadingInput.style.borderColor = 'red';
                    setTimeout(() => { if(manualHeadingInput) manualHeadingInput.style.borderColor = '#777'; }, 1500); return;
                }
            } else { selectedAircraft.targetHeading = newHeading; }
            if (selectedAircraft.isIntercepting) { selectedAircraft.isIntercepting = false; }
            selectedAircraft.turning = true; selectedAircraft.commandedTurnDirection = tempCommandedTurnDirection;
            popup.style.display = 'none'; updateTopCenterButtonStates();
        };
        submitManualHeadingBtn.addEventListener('click', () => { applyHeadingChange(manualHeadingInput.value); });
        manualHeadingInput.addEventListener('keypress', (e) => { if (e.key === 'Enter') { submitManualHeadingBtn.click(); } });
        turnButtonsContainer.querySelectorAll('.turn-btn').forEach(btn => {
            if (parseInt(btn.dataset.direction) === tempCommandedTurnDirection) btn.classList.add('active');
            btn.addEventListener('click', (e) => {
                e.stopPropagation(); const clickedDir = parseInt(e.target.dataset.direction);
                if (tempCommandedTurnDirection === clickedDir) { tempCommandedTurnDirection = 0; e.target.classList.remove('active'); }
                else { tempCommandedTurnDirection = clickedDir; turnButtonsContainer.querySelectorAll('.turn-btn').forEach(b => b.classList.remove('active')); e.target.classList.add('active'); }
            });
        });
        const div360 = document.createElement('div'); div360.textContent = `360°`; div360.onclick = () => applyHeadingChange(0); headingValuesContainer.appendChild(div360);
        for (let i = 355; i >= 0; i -= 5) {
            const val = i; const div = document.createElement('div');
            div.textContent = `${val.toString().padStart(3, '0')}°`;
            div.onclick = () => applyHeadingChange(val); headingValuesContainer.appendChild(div);
        }
    } else if (field === 'speedKTS') {
        current = selectedAircraft.speedKTS;
        values = Array.from({ length: (600 - 100) / 10 + 1 }, (_, i) => 100 + i * 10);
        values.forEach(val => {
            const div = document.createElement('div'); div.textContent = `${val} kts`;
            if (val === current) div.classList.add('current-value');
            div.onclick = () => { selectedAircraft.speedKTS = val; popup.style.display = 'none'; };
            popup.appendChild(div);
        });
    } else if (field === 'altitude') {
        current = selectedAircraft.targetAltitude;
        values = Array.from({ length: (450 - 10) / 5 + 1 }, (_, i) => (10 + i * 5) * 100);
        values.forEach(val => {
            const div = document.createElement('div'); div.textContent = formatFlightLevel(val);
            if (val === current) div.classList.add('current-value');
            div.onclick = () => {
                selectedAircraft.targetAltitude = val;
                if (selectedAircraft.altitude < val && selectedAircraft.rateOfClimb === 0) {
                    selectedAircraft.rateOfClimb = aircraftPerformanceROC[selectedAircraft.type] || DEFAULT_CLIMB_RATE;
                    selectedAircraft.rateOfDescent = 0;
                } else if (selectedAircraft.altitude > val && selectedAircraft.rateOfDescent === 0) {
                    selectedAircraft.rateOfDescent = DEFAULT_ROD; selectedAircraft.rateOfClimb = 0;
                }
                popup.style.display = 'none';
            };
            popup.appendChild(div);
        });
    } else if (field === 'rateOfDescent') {
        current = selectedAircraft.rateOfDescent > 0 ? selectedAircraft.rateOfDescent : (selectedAircraft.rateOfClimb > 0 ? -selectedAircraft.rateOfClimb : 0);
        values = [3000, 2500, 2000, 1500, 1000, 500, 0, -500, -1000, -1500, -2000, -2500, -3000];
        values.forEach(val => {
            const div = document.createElement('div');
            div.textContent = `${val > 0 ? val : (val < 0 ? '+' + Math.abs(val) : '0')} ft/min`;
            if (val === current) div.classList.add('current-value');
            div.onclick = () => {
                if (val > 0) { selectedAircraft.rateOfDescent = val; selectedAircraft.rateOfClimb = 0; }
                else if (val < 0) { selectedAircraft.rateOfClimb = Math.abs(val); selectedAircraft.rateOfDescent = 0; }
                else { selectedAircraft.rateOfDescent = 0; selectedAircraft.rateOfClimb = 0; }
                popup.style.display = 'none';
            };
            popup.appendChild(div);
        });
    }
    popup.style.width = '160px'; popup.style.maxHeight = '260px';
    popup.style.visibility = 'hidden'; popup.style.display = 'block';
    const actualPopupWidth = popup.offsetWidth; const actualPopupHeight = popup.offsetHeight;
    let finalX = x + 10; let finalY = y + 10; const screenMargin = 15;
    if (finalX + actualPopupWidth > window.innerWidth - screenMargin) finalX = x - actualPopupWidth - 10;
    if (finalX < screenMargin) finalX = screenMargin;
    if (finalY + actualPopupHeight > window.innerHeight - screenMargin) finalY = y - actualPopupHeight - 10;
    if (finalY < screenMargin) finalY = screenMargin;
    popup.style.left = `${finalX}px`; popup.style.top = `${finalY}px`;
    popup.style.visibility = 'visible';
}

// --- Olay Dinleyiciler ---
canvas.addEventListener('mousedown', function(event) {
    if (event.button === 1 || (event.button === 0 && event.ctrlKey)) {
        if (!isDraggingLabel) { isPanning = true; canvas.style.cursor = 'grabbing'; event.preventDefault(); }
    } else if (event.button === 0) {
        if (!isDraggingLabel) canvas.style.cursor = isMeasuring ? 'crosshair' : (isPlacingAircraft ? 'crosshair' : 'grab');
    }
});
canvas.addEventListener('contextmenu', function(event) {
    if (isMeasuring && measurementStartPoint) {
        event.preventDefault(); isMeasuring = false; measurementStartPoint = null;
        hoveredAircraftForMeasure = null; hoveredRunwayCenterForMeasure = false;
        if (measureButton) { measureButton.classList.remove('measuring'); measureButton.textContent = 'Ölçüm Yap'; }
        canvas.style.cursor = isPlacingAircraft ? 'crosshair' : 'grab';
        if (tempMeasurementLabel) tempMeasurementLabel.style.display = 'none';
    }
});

function handleGlobalMouseMove(event) {
    const currentMouseX = event.clientX; const currentMouseY = event.clientY;
    if (isDraggingLabel && draggedLabelItem) {
        let newX = currentMouseX - dragOffsetX; let newY = currentMouseY - dragOffsetY;
        const labelWidth = draggedLabelItem.labelElement.offsetWidth;
        const labelHeight = draggedLabelItem.labelElement.offsetHeight;
        newX = Math.max(0, Math.min(newX, window.innerWidth - labelWidth));
        newY = Math.max(0, Math.min(newY, window.innerHeight - labelHeight));
        draggedLabelItem.labelX = newX; draggedLabelItem.labelY = newY;
        if (draggedLabelItem.labelElement) {
            draggedLabelItem.labelElement.style.left = `${newX}px`;
            draggedLabelItem.labelElement.style.top = `${newY}px`;
        }
        if (runwayCenterHoverText) runwayCenterHoverText.style.display = 'none'; return;
    }
    if (isPanning && (event.buttons === 4 || (event.buttons === 1 && event.ctrlKey))) {
        const dx = currentMouseX - lastMouseX; const dy = currentMouseY - lastMouseY;
        let newPanX = panX + dx; let newPanY = panY + dy;
        const panLimitNM = 150; const panLimitWorldPixels = nmToWorldPixels(panLimitNM);
        const minPanX = centerX * (1 - zoom) - panLimitWorldPixels * zoom;
        const maxPanX = centerX * (1 - zoom) + panLimitWorldPixels * zoom;
        const minPanY = centerY * (1 - zoom) - panLimitWorldPixels * zoom;
        const maxPanY = centerY * (1 - zoom) + panLimitWorldPixels * zoom;
        newPanX = Math.max(minPanX, Math.min(newPanX, maxPanX));
        newPanY = Math.max(minPanY, Math.min(newPanY, maxPanY));
        panX = newPanX; panY = newPanY;
        lastMouseX = currentMouseX; lastMouseY = currentMouseY; event.preventDefault();
        if (runwayCenterHoverText) runwayCenterHoverText.style.display = 'none';
        hoveredAircraftForMeasure = null; hoveredRunwayCenterForMeasure = false; return;
    }
    const worldMousePosForHover = screenToWorld(currentMouseX, currentMouseY);
    const runwayCenterHoverRadiusWorld = 5 / zoom; let isHoveringRunwayCenter = false;
    if (centerX !== undefined && centerY !== undefined) {
        const distToRunwayCenter = Math.sqrt(Math.pow(worldMousePosForHover.x - centerX, 2) + Math.pow(worldMousePosForHover.y - centerY, 2));
        if (distToRunwayCenter < runwayCenterHoverRadiusWorld) isHoveringRunwayCenter = true;
    }
    if (isHoveringRunwayCenter && !isDraggingLabel && !isPanning) {
        if (runwayCenterHoverText) {
            runwayCenterHoverText.style.left = `${currentMouseX + 7}px`;
            runwayCenterHoverText.style.top = `${currentMouseY - 15}px`;
            runwayCenterHoverText.style.display = 'block';
        }
    } else { if (runwayCenterHoverText) runwayCenterHoverText.style.display = 'none'; }
    hoveredAircraftForMeasure = null; hoveredRunwayCenterForMeasure = false;
    if (isMeasuring) {
        const worldMousePos = screenToWorld(currentMouseX, currentMouseY);
        const runwayCenterClickRadiusWorld = 5 / zoom;
        const distToCenterForMeasure = Math.sqrt(Math.pow(worldMousePos.x - centerX, 2) + Math.pow(worldMousePos.y - centerY, 2));
        if (distToCenterForMeasure < runwayCenterClickRadiusWorld) {
            hoveredRunwayCenterForMeasure = true; canvas.style.cursor = 'crosshair';
        } else {
            const hoverThresholdWorld = 6 / zoom; let foundAircraft = null;
            for (const ac of aircrafts) {
                const dist = Math.sqrt(Math.pow(worldMousePos.x - ac.x, 2) + Math.pow(worldMousePos.y - ac.y, 2));
                if (dist < hoverThresholdWorld) { foundAircraft = ac; break; }
            }
            hoveredAircraftForMeasure = foundAircraft;
            if (!foundAircraft) canvas.style.cursor = 'crosshair';
        }
    } else { if (!isPanning && !isDraggingLabel) canvas.style.cursor = isPlacingAircraft ? 'crosshair' : 'grab'; }
    lastMouseX = currentMouseX; lastMouseY = currentMouseY;
}
document.addEventListener('mousemove', handleGlobalMouseMove);

canvas.addEventListener('mouseup', function(event) {
    if (isPanning && (event.button === 1 || (event.button === 0 && event.ctrlKey))) {
        isPanning = false; if (!isDraggingLabel) canvas.style.cursor = isMeasuring ? 'crosshair' : (isPlacingAircraft ? 'crosshair' : 'grab');
    }
});
document.addEventListener('mouseup', function(event) {
    if (event.button === 1) { // Orta tuş bırakıldığında
        if (isDraggingLabel && draggedLabelItem) {
            let anchorScreenX, anchorScreenY;
            if (draggedLabelType === 'aircraft') { const sP = worldToScreen(draggedLabelItem.x, draggedLabelItem.y); anchorScreenX = sP.x; anchorScreenY = sP.y; }
            else if (draggedLabelType === 'measurement') {
                const mXW = (draggedLabelItem.start.x + draggedLabelItem.end.x) / 2; const mYW = (draggedLabelItem.start.y + draggedLabelItem.end.y) / 2;
                const sP = worldToScreen(mXW, mYW); anchorScreenX = sP.x; anchorScreenY = sP.y;
            }
            if (anchorScreenX !== undefined && anchorScreenY !== undefined) {
                draggedLabelItem.draggedLabelDeltaX = draggedLabelItem.labelX - anchorScreenX;
                draggedLabelItem.draggedLabelDeltaY = draggedLabelItem.labelY - anchorScreenY;
            }
            draggedLabelItem.labelDragged = true;
            if (draggedLabelItem.labelElement) draggedLabelItem.labelElement.classList.remove('dragging');
            isDraggingLabel = false; draggedLabelItem = null; draggedLabelType = null;
            canvas.style.cursor = isMeasuring ? 'crosshair' : (isPlacingAircraft ? 'crosshair' : 'grab');
        }
        if (isPanning) { // Eğer orta tuşla pan yapılıyorsa
            isPanning = false;
            canvas.style.cursor = isMeasuring ? 'crosshair' : (isPlacingAircraft ? 'crosshair' : 'grab');
        }
    }
});
canvas.addEventListener('mouseleave', function() {
    hoveredAircraftForMeasure = null; hoveredRunwayCenterForMeasure = false;
    if (runwayCenterHoverText) runwayCenterHoverText.style.display = 'none';
});
canvas.addEventListener('click', function(event) {
    if (isMeasuring) {
        let clickTarget; const worldClickPosForCheck = screenToWorld(event.clientX, event.clientY);
        const runwayCenterClickRadiusWorld = 5 / zoom;
        const distToRunwayCenter = Math.sqrt(Math.pow(worldClickPosForCheck.x - centerX, 2) + Math.pow(worldClickPosForCheck.y - centerY, 2));
        if (distToRunwayCenter < runwayCenterClickRadiusWorld) {
            clickTarget = { x: centerX, y: centerY, type: 'runwayCenter', id: 'RUNWAY_CENTER' };
        } else {
            const clickThresholdWorld = 5 / zoom; let clickedAircraftCheck = null;
            for (const ac of aircrafts) {
                const distance = Math.sqrt(Math.pow(worldClickPosForCheck.x - ac.x, 2) + Math.pow(worldClickPosForCheck.y - ac.y, 2));
                if (distance < clickThresholdWorld) { clickedAircraftCheck = ac; break; }
            }
            if (clickedAircraftCheck) { clickTarget = { x: clickedAircraftCheck.x, y: clickedAircraftCheck.y, type: 'aircraft', id: clickedAircraftCheck.id }; }
            else { const worldClickPos = screenToWorld(event.clientX, event.clientY); clickTarget = { x: worldClickPos.x, y: worldClickPos.y, type: 'point', id: null }; }
        }
        if (!measurementStartPoint) {
            measurementStartPoint = clickTarget; canvas.style.cursor = 'crosshair';
            measureButton.textContent = 'Ölçüm: İkinci Nokta';
            hoveredAircraftForMeasure = null; hoveredRunwayCenterForMeasure = false;
            if (tempMeasurementLabel) tempMeasurementLabel.style.display = 'block';
        } else {
            try {
                const measurementEndPoint = clickTarget;
                const dx = measurementEndPoint.x - measurementStartPoint.x; const dy = measurementEndPoint.y - measurementStartPoint.y;
                const distanceWorldPixels = Math.sqrt(dx * dx + dy * dy); const distanceNM = worldPixelsToNm(distanceWorldPixels);
                let estimatedAltitude = null; let bearing = null; let reciprocalBearing = null; let relativeBearing1 = null; let relativeBearing2 = null;
                bearing = calculateBearing(measurementStartPoint.x, measurementStartPoint.y, measurementEndPoint.x, measurementEndPoint.y);
                reciprocalBearing = (bearing + 180) % 360;
                if (measurementStartPoint.type === 'aircraft') {
                    const startAircraft = aircrafts.find(a => a.id === measurementStartPoint.id);
                    if (startAircraft) {
                        if (measurementEndPoint.type === 'point' || measurementEndPoint.type === 'runwayCenter') {
                            if (startAircraft.speedKTS > 0) {
                                const timeHours = distanceNM / startAircraft.speedKTS; const timeMinutes = timeHours * 60;
                                let verticalDirection = 0; if (startAircraft.altitude !== startAircraft.targetAltitude) verticalDirection = Math.sign(startAircraft.targetAltitude - startAircraft.altitude);
                                let effectiveRodMagnitude = 0;
                                if (startAircraft.rateOfDescent !== 0 && verticalDirection < 0) effectiveRodMagnitude = Math.abs(startAircraft.rateOfDescent);
                                else if (startAircraft.rateOfClimb !== 0 && verticalDirection > 0) effectiveRodMagnitude = Math.abs(startAircraft.rateOfClimb);
                                else if (verticalDirection !== 0) effectiveRodMagnitude = verticalDirection > 0 ? DEFAULT_CLIMB_RATE : DEFAULT_ROD;
                                const altitudeChange = verticalDirection * effectiveRodMagnitude * timeMinutes;
                                estimatedAltitude = startAircraft.altitude + altitudeChange; estimatedAltitude = Math.max(0, estimatedAltitude);
                            }
                        } else if (measurementEndPoint.type === 'aircraft') {
                            const endAircraft = aircrafts.find(a => a.id === measurementEndPoint.id);
                            if (endAircraft) { relativeBearing1 = angleDiff(bearing, startAircraft.heading); relativeBearing2 = angleDiff(reciprocalBearing, endAircraft.heading); }
                        }
                    }
                } else if (measurementStartPoint.type === 'runwayCenter' && measurementEndPoint.type === 'aircraft') {
                    const endAircraft = aircrafts.find(a => a.id === measurementEndPoint.id);
                    if (endAircraft) relativeBearing2 = angleDiff(reciprocalBearing, endAircraft.heading);
                }
                const newMeasurement = {
                    id: Date.now(), start: { ...measurementStartPoint }, end: { ...measurementEndPoint }, distanceNM: distanceNM, bearing: bearing, reciprocalBearing: reciprocalBearing,
                    relativeBearing1: relativeBearing1, relativeBearing2: relativeBearing2, estimatedAltitude: estimatedAltitude,
                    labelElement: null, labelX: 0, labelY: 0, labelDragged: false, draggedLabelDeltaX: 0, draggedLabelDeltaY: 0
                };
                measurements.push(newMeasurement); createMeasurementLabel(newMeasurement);
            } catch (error) { console.error("Error during measurement completion:", error);
            } finally {
                isMeasuring = false; measurementStartPoint = null;
                hoveredAircraftForMeasure = null; hoveredRunwayCenterForMeasure = false;
                measureButton.classList.remove('measuring'); measureButton.textContent = 'Ölçüm Yap';
                canvas.style.cursor = isPlacingAircraft ? 'crosshair' : 'grab';
                if (tempMeasurementLabel) tempMeasurementLabel.style.display = 'none';
            }
        }
        event.stopPropagation(); return;
    }
    if (isPanning || isDraggingLabel || event.ctrlKey || event.button !== 0) return;
    const worldClickPos = screenToWorld(event.clientX, event.clientY); const mouseX = worldClickPos.x; const mouseY = worldClickPos.y;
    if (isPlacingAircraft) {
        pendingAircraftLocation = { x: mouseX, y: mouseY }; isPlacingAircraft = false; canvas.style.cursor = 'grab';
        addAircraftButton.classList.remove('placing'); addAircraftButton.textContent = 'Uçak Ekle';
        addAircraftForm.style.display = 'block'; formErrorDiv.textContent = ''; inputCallsign.focus(); event.stopPropagation(); return;
    }
    const clickThresholdWorld = 5 / zoom; let clickedAircraftCheck = null;
    for (const ac of aircrafts) { const distance = Math.sqrt(Math.pow(mouseX - ac.x, 2) + Math.pow(mouseY - ac.y, 2)); if (distance < clickThresholdWorld) { clickedAircraftCheck = ac; break; } }
    if (clickedAircraftCheck) {
        selectedAircraft = clickedAircraftCheck;
        document.querySelectorAll('.aircraft-label.selected').forEach(el => el.classList.remove('selected'));
        if(selectedAircraft.labelElement) selectedAircraft.labelElement.classList.add('selected');
        updateTopCenterButtonStates();
    } else {
        if (selectedAircraft && !popup.contains(event.target)) {
            selectedAircraft = null; popup.style.display = 'none';
            document.querySelectorAll('.aircraft-label.selected').forEach(el => el.classList.remove('selected'));
            updateTopCenterButtonStates();
        }
    }
});
canvas.addEventListener('wheel', function(event) {
    event.preventDefault(); const zoomIntensity = 0.1; const oldZoom = zoom;
    const delta = event.deltaY < 0 ? (1 + zoomIntensity) : (1 - zoomIntensity);
    zoom = Math.min(Math.max(oldZoom * delta, 0.2), 5.0);
    if (zoom !== oldZoom) {
        const rect = canvas.getBoundingClientRect();
        const mouseXCanvas = event.clientX - rect.left; const mouseYCanvas = event.clientY - rect.top;
        const mouseXWorldBefore = (mouseXCanvas - panX) / oldZoom;
        const mouseYWorldBefore = (mouseYCanvas - panY) / oldZoom;
        panX = mouseXCanvas - mouseXWorldBefore * zoom;
        panY = mouseYCanvas - mouseYWorldBefore * zoom;
    }
});

// --- Buton Olayları ---
fullscreenButton.addEventListener('click', () => {
    if (!document.fullscreenElement) document.documentElement.requestFullscreen().catch(err => console.error(`Tam ekran: ${err.message}`));
    else if (document.exitFullscreen) document.exitFullscreen().catch(err => console.error(`Tam ekrandan çıkış: ${err.message}`));
});
vectorToggle.addEventListener('click', () => { showVectors = !showVectors; vectorToggle.textContent = `Speed Vector: ${showVectors ? 'AÇIK' : 'KAPALI'}`; vectorToggle.classList.toggle('active', showVectors); });
document.querySelectorAll('#vectorControls button[data-minutes]').forEach(btn => {
    btn.addEventListener('click', function() { vectorMinutes = parseInt(this.dataset.minutes); document.querySelectorAll('#vectorControls button[data-minutes]').forEach(b => b.classList.remove('active')); this.classList.add('active'); });
});
labelSizeControl.addEventListener('input', function() { labelFontSize = parseInt(this.value); });
btnLoc21L.addEventListener('click', () => { showLocalizerLeft = !showLocalizerLeft; btnLoc21L.classList.toggle('active', showLocalizerLeft); });
btnLocRight.addEventListener('click', () => { showLocalizerRight = !showLocalizerRight; btnLocRight.classList.toggle('active', showLocalizerRight); });
measureButton.addEventListener('click', () => {
    isMeasuring = !isMeasuring;
    if (isMeasuring) {
        measureButton.classList.add('measuring'); measureButton.textContent = 'Ölçüm: İlk Nokta'; canvas.style.cursor = 'crosshair';
        measurementStartPoint = null; hoveredAircraftForMeasure = null; hoveredRunwayCenterForMeasure = false;
        isPlacingAircraft = false; addAircraftButton.classList.remove('placing'); addAircraftButton.textContent = 'Uçak Ekle';
        addAircraftForm.style.display = 'none'; pendingAircraftLocation = null; selectedAircraft = null; popup.style.display = 'none';
        document.querySelectorAll('.aircraft-label.selected').forEach(el => el.classList.remove('selected'));
        updateTopCenterButtonStates(); if (tempMeasurementLabel) tempMeasurementLabel.style.display = 'none';
        if(runwayCenterHoverText) runwayCenterHoverText.style.display = 'none';
    } else {
        measureButton.classList.remove('measuring'); measureButton.textContent = 'Ölçüm Yap'; canvas.style.cursor = isPlacingAircraft ? 'crosshair' : 'grab';
        measurementStartPoint = null; hoveredAircraftForMeasure = null; hoveredRunwayCenterForMeasure = false;
        if (tempMeasurementLabel) tempMeasurementLabel.style.display = 'none';
    }
});
addAircraftButton.addEventListener('click', () => {
    if (isPlacingAircraft) {
        isPlacingAircraft = false; canvas.style.cursor = 'grab'; addAircraftButton.classList.remove('placing'); addAircraftButton.textContent = 'Uçak Ekle'; pendingAircraftLocation = null;
    } else {
        isPlacingAircraft = true; canvas.style.cursor = 'crosshair'; addAircraftButton.classList.add('placing'); addAircraftButton.textContent = 'Yer Seç (İptal Et)';
        isMeasuring = false; measureButton.classList.remove('measuring'); measureButton.textContent = 'Ölçüm Yap';
        measurementStartPoint = null; hoveredAircraftForMeasure = null; hoveredRunwayCenterForMeasure = false;
        selectedAircraft = null; popup.style.display = 'none'; addAircraftForm.style.display = 'none'; pendingAircraftLocation = null;
        document.querySelectorAll('.aircraft-label.selected').forEach(el => el.classList.remove('selected'));
        updateTopCenterButtonStates(); if (tempMeasurementLabel) tempMeasurementLabel.style.display = 'none';
        if(runwayCenterHoverText) runwayCenterHoverText.style.display = 'none';
    }
});
inputType.addEventListener('change', function() {
    const selectedType = this.value; if (defaultAircraftSpeeds[selectedType]) inputSpeed.value = defaultAircraftSpeeds[selectedType];
});
submitNewAircraftBtn.addEventListener('click', () => {
    formErrorDiv.textContent = ''; const callsign = inputCallsign.value.trim().toUpperCase(); const type = inputType.value;
    const heading = parseInt(inputHeading.value); const speed = parseInt(inputSpeed.value);
    const altitudeFL = parseInt(inputAltitude.value); const altitude = altitudeFL * 100;
    const departureFLValue = inputDepartureFL.value.trim(); const departureFL = departureFLValue ? parseInt(departureFLValue) : null;
    let errorMsg = '';
    if (!callsign) errorMsg = 'Çağrı adı boş olamaz.';
    else if (callsign.length > 7) errorMsg = 'Çağrı adı en fazla 7 karakter olabilir.';
    else if (aircrafts.some(ac => ac.id === callsign)) errorMsg = 'Bu çağrı adı zaten kullanılıyor.';
    else if (!type) errorMsg = 'Uçak tipi seçilmelidir.';
    else if (isNaN(heading) || heading < 0 || heading > 359) errorMsg = 'Geçersiz yön (0-359).';
    else if (isNaN(speed) || speed < 100 || speed > 600) errorMsg = 'Geçersiz hız (100-600 kts).';
    else if (isNaN(altitudeFL) || altitude < 1000 || altitude > 45000) errorMsg = 'Geçersiz irtifa (FL010-FL450).';
    else if (departureFL !== null && (isNaN(departureFL) || departureFL < 10 || departureFL > 450)) errorMsg = 'Geçersiz tırmanış FL (FL010-FL450).';
    else if (!pendingAircraftLocation) errorMsg = 'Uçak konumu belirlenmemiş.';
    if (errorMsg) { formErrorDiv.textContent = errorMsg; return; }
    const newAircraft = {
        id: callsign, x: pendingAircraftLocation.x, y: pendingAircraftLocation.y, heading: heading, targetHeading: heading, speedKTS: speed, altitude: altitude, targetAltitude: altitude,
        rateOfDescent: 0, rateOfClimb: 0, isTakingOff: false, takeoffRunway: null, isIntercepting: false, isHandedOffToTower: false, showVector: false, labelElement: null, labelX: 0, labelY: 0, labelDragged: true,
        bankAngle: 0, maxBankAngle: 25, commandedTurnDirection: 0, turning: false, type: type, departureTargetFL: departureFL, showInfoPanel: false,
        draggedLabelDeltaX: 0, draggedLabelDeltaY: 0, lastHeadingUpdateTime: 0, initialPosSet: true
    };
    aircrafts.push(newAircraft); addAircraftForm.style.display = 'none'; pendingAircraftLocation = null;
    inputCallsign.value = ''; inputType.value = aircraftTypes[0] || ''; inputHeading.value = '';
    inputSpeed.value = defaultAircraftSpeeds[inputType.value] || ''; inputAltitude.value = ''; inputDepartureFL.value = '';
});
cancelNewAircraftBtn.addEventListener('click', () => {
    addAircraftForm.style.display = 'none'; pendingAircraftLocation = null;
    if (addAircraftButton.classList.contains('placing')) { isPlacingAircraft = false; canvas.style.cursor = 'grab'; addAircraftButton.classList.remove('placing'); addAircraftButton.textContent = 'Uçak Ekle'; }
    inputCallsign.value = ''; inputType.value = aircraftTypes[0] || ''; inputHeading.value = '';
    inputSpeed.value = defaultAircraftSpeeds[inputType.value] || ''; inputAltitude.value = ''; inputDepartureFL.value = ''; formErrorDiv.textContent = '';
});
speedButton.addEventListener('click', () => { speedControlContainer.style.display = speedControlContainer.style.display === 'block' ? 'none' : 'block'; });
// speedSlider event listener zaten en başta tanımlı.

playPauseButton.addEventListener('click', () => {
    isPaused = !isPaused;
    playPauseButton.textContent = isPaused ? 'Oynat' : 'Durdur';
    playPauseButton.classList.toggle('paused', isPaused);
    toggleTimer(isPaused); // toggleTimer'a isPaused durumunu gönder
    if (!isPaused && !animationFrameId) { // Eğer devam ediliyorsa ve loop durmuşsa yeniden başlat
        lastTime = performance.now(); // lastTime'ı güncelle
        gameLoop(lastTime);
    }
});
takeoffButton.addEventListener('click', () => { takeoffOptionsContainer.style.display = takeoffOptionsContainer.style.display === 'flex' ? 'none' : 'flex'; });
document.querySelectorAll('.takeoff-option-btn.runway-btn').forEach(btn => {
    btn.addEventListener('click', function() {
        const runway = this.dataset.runway; const select = this.parentElement.querySelector('.waypoint-select');
        const waypointName = select.value || null; if (!waypointName) { alert('Lütfen bir waypoint seçin!'); return; }
        launchAircraft(runway, waypointName); takeoffOptionsContainer.style.display = 'none';
    });
});
interceptButton033.addEventListener('click', () => {
    if (selectedAircraft && !interceptButton033.disabled) {
        selectedAircraft.isIntercepting = true; selectedAircraft.interceptCourse = INTERCEPT_TARGET_COURSE_033; // Hangi LOC'a intercept ettiğini sakla
        // Intercept açısını hesapla (örneğin 30-45 derece)
        let interceptAngle = INTERCEPT_TARGET_COURSE_033 - 45; // Sola 45 derece
        // Uçağın pozisyonuna göre daha akıllı bir intercept açısı da hesaplanabilir.
        // Şimdilik sabit bir açı kullanıyoruz.
        selectedAircraft.targetHeading = (Math.round(interceptAngle) + 360) % 360;
        selectedAircraft.turning = true; selectedAircraft.commandedTurnDirection = 0; selectedAircraft.isHandedOffToTower = false;
        updateTopCenterButtonStates(); popup.style.display = 'none';
    }
});
interceptButton21L.addEventListener('click', () => {
    if (selectedAircraft && !interceptButton21L.disabled) {
        selectedAircraft.isIntercepting = true; selectedAircraft.interceptCourse = INTERCEPT_TARGET_COURSE_21L;
        let interceptAngle = INTERCEPT_TARGET_COURSE_21L + 45; // Sağa 45 derece
        selectedAircraft.targetHeading = (Math.round(interceptAngle) + 360) % 360;
        selectedAircraft.turning = true; selectedAircraft.commandedTurnDirection = 0; selectedAircraft.isHandedOffToTower = false;
        updateTopCenterButtonStates(); popup.style.display = 'none';
    }
});
towerButton.addEventListener('click', () => {
    if (selectedAircraft && !towerButton.disabled) {
        if (selectedAircraft.isHandedOffToTower) selectedAircraft.isHandedOffToTower = false;
        else { selectedAircraft.isHandedOffToTower = true; selectedAircraft.isIntercepting = false; selectedAircraft.commandedTurnDirection = 0; }
        updateTopCenterButtonStates(); popup.style.display = 'none';
    }
});
removeButton.addEventListener('click', () => {
    if (selectedAircraft && !removeButton.disabled) {
        const indexToRemove = aircrafts.findIndex(ac => ac.id === selectedAircraft.id);
        if (indexToRemove > -1) {
            if (selectedAircraft.labelElement) selectedAircraft.labelElement.remove();
            aircrafts.splice(indexToRemove, 1); selectedAircraft = null;
            updateTopCenterButtonStates(); popup.style.display = 'none';
        }
    }
});

function updateTopCenterButtonStates() {
    let canBeEnabled033 = false; // Normal şartlarda intercept için uygun mu?
    let canBeEnabled21L = false; // Normal şartlarda intercept için uygun mu?
    let canTower = false;
    let canRemove = false;

    const btn033 = document.getElementById('interceptButton033');
    const btn21L = document.getElementById('interceptButton21L');
    const indicator033 = btn033 ? btn033.querySelector('.intercept-indicator') : null;
    const indicator21L = btn21L ? btn21L.querySelector('.intercept-indicator') : null;

    if (selectedAircraft) {
        canRemove = true;
        canTower = true;
        towerButton.classList.toggle('handed-off', selectedAircraft.isHandedOffToTower);

        const heading = selectedAircraft.heading;
        const generalInterceptPossible = !selectedAircraft.isHandedOffToTower;

        // LOC 033 için normal etkinleştirme koşulları
        const isInAngleRange033 = (heading >= 349 && heading < 360) || (heading >= 0 && heading <= 76);
        const distToLocNM033 = worldPixelsToNm(pointLineDistance(selectedAircraft.x, selectedAircraft.y, centerX, centerY,
            centerX + Math.sin(toRadians(INTERCEPT_TARGET_COURSE_033)) * nmToWorldPixels(localizerLengthNM + 5),
            centerY - Math.cos(toRadians(INTERCEPT_TARGET_COURSE_033)) * nmToWorldPixels(localizerLengthNM + 5)));
        if (generalInterceptPossible && distToLocNM033 <= INTERCEPT_MAX_DIST_NM && isInAngleRange033) {
            canBeEnabled033 = true;
        }

        // LOC 21L için normal etkinleştirme koşulları
        const isInAngleRange21L = (heading >= 169 && heading <= 256);
        const distToLocNM21L = worldPixelsToNm(pointLineDistance(selectedAircraft.x, selectedAircraft.y, centerX, centerY,
            centerX + Math.sin(toRadians(INTERCEPT_TARGET_COURSE_21L)) * nmToWorldPixels(localizerLengthNM + 5),
            centerY - Math.cos(toRadians(INTERCEPT_TARGET_COURSE_21L)) * nmToWorldPixels(localizerLengthNM + 5)));
        if (generalInterceptPossible && distToLocNM21L <= INTERCEPT_MAX_DIST_NM && isInAngleRange21L) {
            canBeEnabled21L = true;
        }

        // Buton 033'ün durumunu ayarla
        if (btn033 && indicator033) {
            if (selectedAircraft.isIntercepting && selectedAircraft.interceptCourse === INTERCEPT_TARGET_COURSE_033) {
                btn033.disabled = false; // Aktif intercept'i iptal etmek için her zaman etkin
                btn033.classList.add('intercepting');
                indicator033.textContent = '✓';
            } else {
                btn033.disabled = !canBeEnabled033; // Normal koşullara göre etkin/devre dışı
                btn033.classList.remove('intercepting');
                indicator033.textContent = '';
            }
        }

        // Buton 21L'nin durumunu ayarla
        if (btn21L && indicator21L) {
            if (selectedAircraft.isIntercepting && selectedAircraft.interceptCourse === INTERCEPT_TARGET_COURSE_21L) {
                btn21L.disabled = false; // Aktif intercept'i iptal etmek için her zaman etkin
                btn21L.classList.add('intercepting');
                indicator21L.textContent = '✓';
            } else {
                btn21L.disabled = !canBeEnabled21L; // Normal koşullara göre etkin/devre dışı
                btn21L.classList.remove('intercepting');
                indicator21L.textContent = '';
            }
        }

        // Bir LOC'a aktif intercept varsa, diğer LOC butonunu devre dışı bırak
        if (selectedAircraft.isIntercepting) {
            if (selectedAircraft.interceptCourse === INTERCEPT_TARGET_COURSE_033 && btn21L) {
                btn21L.disabled = true; // Diğeri aktifken bu kesinlikle devre dışı
                btn21L.classList.remove('intercepting');
                if(indicator21L) indicator21L.textContent = '';
            } else if (selectedAircraft.interceptCourse === INTERCEPT_TARGET_COURSE_21L && btn033) {
                btn033.disabled = true; // Diğeri aktifken bu kesinlikle devre dışı
                btn033.classList.remove('intercepting');
                if(indicator033) indicator033.textContent = '';
            }
        }

    } else { // Seçili uçak yoksa tüm intercept butonları devre dışı
        towerButton.classList.remove('handed-off');
        if (btn033 && indicator033) {
            btn033.disabled = true;
            btn033.classList.remove('intercepting');
            indicator033.textContent = '';
        }
        if (btn21L && indicator21L) {
            btn21L.disabled = true;
            btn21L.classList.remove('intercepting');
            indicator21L.textContent = '';
        }
    }

    towerButton.disabled = !canTower;
    removeButton.disabled = !canRemove;
}

function launchAircraft(runway, waypointName) {
    departureCounter++; const callsign = `DEP${departureCounter.toString().padStart(3, '0')}`;
    const type = aircraftTypes[Math.floor(Math.random() * aircraftTypes.length)];
    const speed = defaultAircraftSpeeds[type] || 250; const initialAltitude = 3000;
    const possibleTargetFLs = [180, 190, 200, 210, 250, 260, 280];
    const randomFLIndex = Math.floor(Math.random() * possibleTargetFLs.length);
    const selectedTargetFL = possibleTargetFLs[randomFLIndex];
    const targetAltitudeFeet = selectedTargetFL * 100;
    const climbRate = aircraftPerformanceROC[type] || DEFAULT_CLIMB_RATE;
    let initialHeading = (runway === '03R') ? 33 : ((runway === '21L') ? 213 : 33);
    const newAircraft = {
        id: callsign, x: centerX, y: centerY, heading: initialHeading, targetHeading: initialHeading,
        speedKTS: speed, altitude: initialAltitude, targetAltitude: targetAltitudeFeet,
        rateOfDescent: 0, rateOfClimb: climbRate, isTakingOff: true, takeoffRunway: runway,
        isIntercepting: false, isHandedOffToTower: false, showVector: false, labelElement: null,
        labelX: 0, labelY: 0, labelDragged: true, bankAngle: 0, maxBankAngle: 25,
        commandedTurnDirection: 0, turning: false, type: type, departureTargetFL: selectedTargetFL,
        showInfoPanel: false, draggedLabelDeltaX: 0, draggedLabelDeltaY: 0,
        lastHeadingUpdateTime: 0, initialPosSet: true, targetWaypoint: waypointName || null
    };
    aircrafts.push(newAircraft);
}

let animationFrameId = null;
function gameLoop(currentTime) {
    animationFrameId = requestAnimationFrame(gameLoop);
    if (isPaused) {
        // lastTime = currentTime; // Duraklatıldığında lastTime'ı güncellemeye devam etme
        return; // Eğer duraklatılmışsa, çizim ve güncelleme yapma
    }
    const deltaTime = (currentTime - lastTime) / 1000; // Saniye cinsinden
    lastTime = currentTime;
    updateAircrafts(deltaTime);
    drawRadar();
}

function initializeApp() {
    const typeDropdown = document.getElementById('acType');
    aircraftTypes.forEach(type => {
        const option = document.createElement('option'); option.value = type; option.textContent = type; typeDropdown.appendChild(option);
    });
    if (aircraftTypes.length > 0) {
        typeDropdown.value = aircraftTypes[0];
        if (defaultAircraftSpeeds[aircraftTypes[0]]) inputSpeed.value = defaultAircraftSpeeds[aircraftTypes[0]];
    }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();
    vectorToggle.classList.toggle('active', showVectors);
    btnLoc21L.classList.toggle('active', showLocalizerLeft);
    btnLocRight.classList.toggle('active', showLocalizerRight);
    updateTopCenterButtonStates();
    const initialSpeedIndex = speedMultipliers.findIndex(s => s === gameSpeedMultiplier);
    speedSlider.value = initialSpeedIndex !== -1 ? initialSpeedIndex : 3; // 1x hız için index 3
    speedButton.textContent = `Hız: ${gameSpeedMultiplier}x`;
    playPauseButton.textContent = isPaused ? 'Oynat' : 'Durdur'; // 'Devam' yerine 'Oynat'
    playPauseButton.classList.toggle('paused', isPaused);
    if (tempMeasurementLabel) tempMeasurementLabel.style.display = 'none';
    if (takeoffOptionsContainer) takeoffOptionsContainer.style.display = 'none';
    lastTime = performance.now();
    startGameTimer(); // Zamanlayıcıyı başlat
    gameLoop(lastTime); // Oyun döngüsünü başlat
}

const generateScenarioBtn = document.getElementById('generateScenarioBtn');
if (generateScenarioBtn) generateScenarioBtn.addEventListener('click', showRunwaySelection);
if (selectRunway03RBtn) selectRunway03RBtn.addEventListener('click', () => { initializeScenarioGeneration('03R'); });
if (selectRunway21LBtn) selectRunway21LBtn.addEventListener('click', () => { initializeScenarioGeneration('21L'); });
if (cancelRunwaySelectionBtn) cancelRunwaySelectionBtn.addEventListener('click', () => { hideRunwaySelection(); });

initializeApp();
</script>















</body>
</html>
